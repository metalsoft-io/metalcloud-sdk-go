/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VMInstanceGroupAPIService VMInstanceGroupAPI service
type VMInstanceGroupAPIService service

type VMInstanceGroupAPIApplyVMTypeOnVMInstanceGroupRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
	vmTypeId float32
}

func (r VMInstanceGroupAPIApplyVMTypeOnVMInstanceGroupRequest) Execute() (*VMInstanceGroup, *http.Response, error) {
	return r.ApiService.ApplyVMTypeOnVMInstanceGroupExecute(r)
}

/*
ApplyVMTypeOnVMInstanceGroup Applies a VM Type to a VM Instance Group

Applies a VM Type to a VM Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @param vmTypeId
 @return VMInstanceGroupAPIApplyVMTypeOnVMInstanceGroupRequest
*/
func (a *VMInstanceGroupAPIService) ApplyVMTypeOnVMInstanceGroup(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32, vmTypeId float32) VMInstanceGroupAPIApplyVMTypeOnVMInstanceGroupRequest {
	return VMInstanceGroupAPIApplyVMTypeOnVMInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
		vmTypeId: vmTypeId,
	}
}

// Execute executes the request
//  @return VMInstanceGroup
func (a *VMInstanceGroupAPIService) ApplyVMTypeOnVMInstanceGroupExecute(r VMInstanceGroupAPIApplyVMTypeOnVMInstanceGroupRequest) (*VMInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.ApplyVMTypeOnVMInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}/actions/apply-type/{vmTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmTypeId"+"}", url.PathEscape(parameterValueToString(r.vmTypeId, "vmTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPICreateVMInstanceGroupRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	createVMInstanceGroup *CreateVMInstanceGroup
}

// The VM Instance Group create object
func (r VMInstanceGroupAPICreateVMInstanceGroupRequest) CreateVMInstanceGroup(createVMInstanceGroup CreateVMInstanceGroup) VMInstanceGroupAPICreateVMInstanceGroupRequest {
	r.createVMInstanceGroup = &createVMInstanceGroup
	return r
}

func (r VMInstanceGroupAPICreateVMInstanceGroupRequest) Execute() (*VMInstanceGroup, *http.Response, error) {
	return r.ApiService.CreateVMInstanceGroupExecute(r)
}

/*
CreateVMInstanceGroup Creates a VM Instance Group

Creates a VM Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return VMInstanceGroupAPICreateVMInstanceGroupRequest
*/
func (a *VMInstanceGroupAPIService) CreateVMInstanceGroup(ctx context.Context, infrastructureId float32) VMInstanceGroupAPICreateVMInstanceGroupRequest {
	return VMInstanceGroupAPICreateVMInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return VMInstanceGroup
func (a *VMInstanceGroupAPIService) CreateVMInstanceGroupExecute(r VMInstanceGroupAPICreateVMInstanceGroupRequest) (*VMInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.CreateVMInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVMInstanceGroup == nil {
		return localVarReturnValue, nil, reportError("createVMInstanceGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVMInstanceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
	createVMInstanceGroupInterface *CreateVMInstanceGroupInterface
}

func (r VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest) CreateVMInstanceGroupInterface(createVMInstanceGroupInterface CreateVMInstanceGroupInterface) VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest {
	r.createVMInstanceGroupInterface = &createVMInstanceGroupInterface
	return r
}

func (r VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest) Execute() (*VMInstanceGroupInterface, *http.Response, error) {
	return r.ApiService.CreateVMInterfaceOnVMInstanceGroupExecute(r)
}

/*
CreateVMInterfaceOnVMInstanceGroup Creates a new Virtual Interface for the VM Instance Group

Creates a new Virtual Interface for the VM Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @return VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest
*/
func (a *VMInstanceGroupAPIService) CreateVMInterfaceOnVMInstanceGroup(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32) VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest {
	return VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
	}
}

// Execute executes the request
//  @return VMInstanceGroupInterface
func (a *VMInstanceGroupAPIService) CreateVMInterfaceOnVMInstanceGroupExecute(r VMInstanceGroupAPICreateVMInterfaceOnVMInstanceGroupRequest) (*VMInstanceGroupInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInstanceGroupInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.CreateVMInterfaceOnVMInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVMInstanceGroupInterface == nil {
		return localVarReturnValue, nil, reportError("createVMInstanceGroupInterface is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVMInstanceGroupInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPIDeleteVMInstanceGroupRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
}

func (r VMInstanceGroupAPIDeleteVMInstanceGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVMInstanceGroupExecute(r)
}

/*
DeleteVMInstanceGroup Deletes a VM Instance Group

Deletes a VM Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @return VMInstanceGroupAPIDeleteVMInstanceGroupRequest
*/
func (a *VMInstanceGroupAPIService) DeleteVMInstanceGroup(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32) VMInstanceGroupAPIDeleteVMInstanceGroupRequest {
	return VMInstanceGroupAPIDeleteVMInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
	}
}

// Execute executes the request
func (a *VMInstanceGroupAPIService) DeleteVMInstanceGroupExecute(r VMInstanceGroupAPIDeleteVMInstanceGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.DeleteVMInstanceGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VMInstanceGroupAPIGetVMInstanceGroupRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
}

func (r VMInstanceGroupAPIGetVMInstanceGroupRequest) Execute() (*VMInstanceGroup, *http.Response, error) {
	return r.ApiService.GetVMInstanceGroupExecute(r)
}

/*
GetVMInstanceGroup Get VM Instance Group information

Returns VM Instance Group information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @return VMInstanceGroupAPIGetVMInstanceGroupRequest
*/
func (a *VMInstanceGroupAPIService) GetVMInstanceGroup(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32) VMInstanceGroupAPIGetVMInstanceGroupRequest {
	return VMInstanceGroupAPIGetVMInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
	}
}

// Execute executes the request
//  @return VMInstanceGroup
func (a *VMInstanceGroupAPIService) GetVMInstanceGroupExecute(r VMInstanceGroupAPIGetVMInstanceGroupRequest) (*VMInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.GetVMInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPIGetVMInstanceGroupVMInstancesRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
}

func (r VMInstanceGroupAPIGetVMInstanceGroupVMInstancesRequest) Execute() ([]VMInstance, *http.Response, error) {
	return r.ApiService.GetVMInstanceGroupVMInstancesExecute(r)
}

/*
GetVMInstanceGroupVMInstances Get the VM Instances of VM Instance Group

Returns the VM Instances of VM Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @return VMInstanceGroupAPIGetVMInstanceGroupVMInstancesRequest
*/
func (a *VMInstanceGroupAPIService) GetVMInstanceGroupVMInstances(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32) VMInstanceGroupAPIGetVMInstanceGroupVMInstancesRequest {
	return VMInstanceGroupAPIGetVMInstanceGroupVMInstancesRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
	}
}

// Execute executes the request
//  @return []VMInstance
func (a *VMInstanceGroupAPIService) GetVMInstanceGroupVMInstancesExecute(r VMInstanceGroupAPIGetVMInstanceGroupVMInstancesRequest) ([]VMInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VMInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.GetVMInstanceGroupVMInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}/vm-instances"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPIGetVMInstanceGroupsRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
}

func (r VMInstanceGroupAPIGetVMInstanceGroupsRequest) Execute() ([]VMInstanceGroup, *http.Response, error) {
	return r.ApiService.GetVMInstanceGroupsExecute(r)
}

/*
GetVMInstanceGroups Get all VM Instance Groups

Returns list of all VM Instance Groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return VMInstanceGroupAPIGetVMInstanceGroupsRequest
*/
func (a *VMInstanceGroupAPIService) GetVMInstanceGroups(ctx context.Context, infrastructureId float32) VMInstanceGroupAPIGetVMInstanceGroupsRequest {
	return VMInstanceGroupAPIGetVMInstanceGroupsRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return []VMInstanceGroup
func (a *VMInstanceGroupAPIService) GetVMInstanceGroupsExecute(r VMInstanceGroupAPIGetVMInstanceGroupsRequest) ([]VMInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VMInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.GetVMInstanceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
	networkId float32
	updateVMInstanceGroupNetwork *UpdateVMInstanceGroupNetwork
}

// The VM Instance Group Network update object
func (r VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest) UpdateVMInstanceGroupNetwork(updateVMInstanceGroupNetwork UpdateVMInstanceGroupNetwork) VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest {
	r.updateVMInstanceGroupNetwork = &updateVMInstanceGroupNetwork
	return r
}

func (r VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest) Execute() (*VMInstanceGroup, *http.Response, error) {
	return r.ApiService.UpdateNetworkProfileOnVMInstanceGroupNetworkExecute(r)
}

/*
UpdateNetworkProfileOnVMInstanceGroupNetwork Applies the given Network Profile to the specified VM Instance Group Network

Applies the given Network Profile to the specified VM Instance Group Network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @param networkId
 @return VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest
*/
func (a *VMInstanceGroupAPIService) UpdateNetworkProfileOnVMInstanceGroupNetwork(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32, networkId float32) VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest {
	return VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return VMInstanceGroup
func (a *VMInstanceGroupAPIService) UpdateNetworkProfileOnVMInstanceGroupNetworkExecute(r VMInstanceGroupAPIUpdateNetworkProfileOnVMInstanceGroupNetworkRequest) (*VMInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.UpdateNetworkProfileOnVMInstanceGroupNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}/network/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateVMInstanceGroupNetwork == nil {
		return localVarReturnValue, nil, reportError("updateVMInstanceGroupNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMInstanceGroupNetwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VMInstanceGroupAPIUpdateVMInstanceGroupRequest struct {
	ctx context.Context
	ApiService *VMInstanceGroupAPIService
	infrastructureId float32
	vmInstanceGroupId float32
	updateVMInstanceGroup *UpdateVMInstanceGroup
}

// The VM Instance Group update object
func (r VMInstanceGroupAPIUpdateVMInstanceGroupRequest) UpdateVMInstanceGroup(updateVMInstanceGroup UpdateVMInstanceGroup) VMInstanceGroupAPIUpdateVMInstanceGroupRequest {
	r.updateVMInstanceGroup = &updateVMInstanceGroup
	return r
}

func (r VMInstanceGroupAPIUpdateVMInstanceGroupRequest) Execute() (*VMInstanceGroup, *http.Response, error) {
	return r.ApiService.UpdateVMInstanceGroupExecute(r)
}

/*
UpdateVMInstanceGroup Updates VM Instance Group information

Updates VM Instance Group information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @param vmInstanceGroupId
 @return VMInstanceGroupAPIUpdateVMInstanceGroupRequest
*/
func (a *VMInstanceGroupAPIService) UpdateVMInstanceGroup(ctx context.Context, infrastructureId float32, vmInstanceGroupId float32) VMInstanceGroupAPIUpdateVMInstanceGroupRequest {
	return VMInstanceGroupAPIUpdateVMInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
		vmInstanceGroupId: vmInstanceGroupId,
	}
}

// Execute executes the request
//  @return VMInstanceGroup
func (a *VMInstanceGroupAPIService) UpdateVMInstanceGroupExecute(r VMInstanceGroupAPIUpdateVMInstanceGroupRequest) (*VMInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VMInstanceGroupAPIService.UpdateVMInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/vm-instance-groups/{vmInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.vmInstanceGroupId, "vmInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateVMInstanceGroup == nil {
		return localVarReturnValue, nil, reportError("updateVMInstanceGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVMInstanceGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
