/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LogicalNetworkInterconnectAPIService LogicalNetworkInterconnectAPI service
type LogicalNetworkInterconnectAPIService service

type LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
	addLogicalNetworkToInterconnect *AddLogicalNetworkToInterconnect
}

// The logical network to add
func (r LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest) AddLogicalNetworkToInterconnect(addLogicalNetworkToInterconnect AddLogicalNetworkToInterconnect) LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest {
	r.addLogicalNetworkToInterconnect = &addLogicalNetworkToInterconnect
	return r
}

func (r LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest) Execute() (*LogicalNetworkInterconnectLogicalNetwork, *http.Response, error) {
	return r.ApiService.AddLogicalNetworkToLogicalNetworkInterconnectExecute(r)
}

/*
AddLogicalNetworkToLogicalNetworkInterconnect Add a logical network to a logical network interconnect

Creates a new association between a logical network and a logical network interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect
 @return LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest
*/
func (a *LogicalNetworkInterconnectAPIService) AddLogicalNetworkToLogicalNetworkInterconnect(ctx context.Context, id int32) LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest {
	return LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnectLogicalNetwork
func (a *LogicalNetworkInterconnectAPIService) AddLogicalNetworkToLogicalNetworkInterconnectExecute(r LogicalNetworkInterconnectAPIAddLogicalNetworkToLogicalNetworkInterconnectRequest) (*LogicalNetworkInterconnectLogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnectLogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.AddLogicalNetworkToLogicalNetworkInterconnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}/logical-networks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addLogicalNetworkToInterconnect == nil {
		return localVarReturnValue, nil, reportError("addLogicalNetworkToInterconnect is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addLogicalNetworkToInterconnect
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	createLogicalNetworkInterconnect *CreateLogicalNetworkInterconnect
}

// The logical network interconnect to create
func (r LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest) CreateLogicalNetworkInterconnect(createLogicalNetworkInterconnect CreateLogicalNetworkInterconnect) LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest {
	r.createLogicalNetworkInterconnect = &createLogicalNetworkInterconnect
	return r
}

func (r LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest) Execute() (*LogicalNetworkInterconnect, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkInterconnectExecute(r)
}

/*
CreateLogicalNetworkInterconnect Create a new logical network interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest
*/
func (a *LogicalNetworkInterconnectAPIService) CreateLogicalNetworkInterconnect(ctx context.Context) LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest {
	return LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnect
func (a *LogicalNetworkInterconnectAPIService) CreateLogicalNetworkInterconnectExecute(r LogicalNetworkInterconnectAPICreateLogicalNetworkInterconnectRequest) (*LogicalNetworkInterconnect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.CreateLogicalNetworkInterconnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkInterconnect == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkInterconnect is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkInterconnect
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest) IfMatch(ifMatch string) LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkInterconnectExecute(r)
}

/*
DeleteLogicalNetworkInterconnect Delete a logical network interconnect by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect to delete
 @return LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest
*/
func (a *LogicalNetworkInterconnectAPIService) DeleteLogicalNetworkInterconnect(ctx context.Context, id int32) LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest {
	return LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LogicalNetworkInterconnectAPIService) DeleteLogicalNetworkInterconnectExecute(r LogicalNetworkInterconnectAPIDeleteLogicalNetworkInterconnectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.DeleteLogicalNetworkInterconnect")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectByIdRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
}

func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectByIdRequest) Execute() (*LogicalNetworkInterconnect, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkInterconnectByIdExecute(r)
}

/*
GetLogicalNetworkInterconnectById Get a logical network interconnect by ID

Returns a logical network interconnect by its ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect to retrieve
 @return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectByIdRequest
*/
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectById(ctx context.Context, id int32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectByIdRequest {
	return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnect
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectByIdExecute(r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectByIdRequest) (*LogicalNetworkInterconnect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.GetLogicalNetworkInterconnectById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworkByIdRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
	logicalNetworkId int32
}

func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworkByIdRequest) Execute() (*LogicalNetworkInterconnectLogicalNetwork, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkInterconnectLogicalNetworkByIdExecute(r)
}

/*
GetLogicalNetworkInterconnectLogicalNetworkById Get a logical network in a logical network interconnect by logical network ID

Returns a logical network that is part of the specified interconnect by logical network ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect
 @param logicalNetworkId The ID of the logical network
 @return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworkByIdRequest
*/
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectLogicalNetworkById(ctx context.Context, id int32, logicalNetworkId int32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworkByIdRequest {
	return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworkByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		logicalNetworkId: logicalNetworkId,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnectLogicalNetwork
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectLogicalNetworkByIdExecute(r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworkByIdRequest) (*LogicalNetworkInterconnectLogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnectLogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.GetLogicalNetworkInterconnectLogicalNetworkById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}/logical-networks/{logicalNetworkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logicalNetworkId"+"}", url.PathEscape(parameterValueToString(r.logicalNetworkId, "logicalNetworkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
	page *float32
	limit *float32
	filterId *[]string
	filterLogicalNetworkId *[]string
	filterStatus *[]string
	filterCreatedAt *[]string
	filterUpdatedAt *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) Page(page float32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) Limit(limit float32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) FilterId(filterId []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.filterId = &filterId
	return r
}

// Filter by logicalNetworkId query param.  **Format:** filter.logicalNetworkId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.logicalNetworkId&#x3D;$btw:John Doe&amp;filter.logicalNetworkId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) FilterLogicalNetworkId(filterLogicalNetworkId []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.filterLogicalNetworkId = &filterLogicalNetworkId
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) FilterStatus(filterStatus []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter by createdAt query param.  **Format:** filter.createdAt&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.createdAt&#x3D;$btw:John Doe&amp;filter.createdAt&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) FilterCreatedAt(filterCreatedAt []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// Filter by updatedAt query param.  **Format:** filter.updatedAt&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.updatedAt&#x3D;$btw:John Doe&amp;filter.updatedAt&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) FilterUpdatedAt(filterUpdatedAt []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.filterUpdatedAt = &filterUpdatedAt
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;logicalNetworkId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - logicalNetworkId  - createdAt  - updatedAt 
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) SortBy(sortBy []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) Search(search string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:**    **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields**  
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) SearchBy(searchBy []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) Execute() (*LogicalNetworkInterconnectLogicalNetworkPaginatedList, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkInterconnectLogicalNetworksExecute(r)
}

/*
GetLogicalNetworkInterconnectLogicalNetworks Get all logical networks in a logical network interconnect

Returns list of all logical networks that are part of the specified interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect
 @return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest
*/
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectLogicalNetworks(ctx context.Context, id int32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest {
	return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnectLogicalNetworkPaginatedList
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectLogicalNetworksExecute(r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectLogicalNetworksRequest) (*LogicalNetworkInterconnectLogicalNetworkPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnectLogicalNetworkPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.GetLogicalNetworkInterconnectLogicalNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}/logical-networks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterLogicalNetworkId != nil {
		t := *r.filterLogicalNetworkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.logicalNetworkId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.logicalNetworkId", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.filterCreatedAt != nil {
		t := *r.filterCreatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", t, "form", "multi")
		}
	}
	if r.filterUpdatedAt != nil {
		t := *r.filterUpdatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterLabel *[]string
	filterName *[]string
	filterKind *[]string
	filterStatus *[]string
	filterFabricInterconnectId *[]string
	filterTransportId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) Page(page float32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) Limit(limit float32) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterId(filterId []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterId = &filterId
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$btw:John Doe&amp;filter.label&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterLabel(filterLabel []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.  **Format:** filter.name&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.name&#x3D;$btw:John Doe&amp;filter.name&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterName(filterName []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterName = &filterName
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterKind(filterKind []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterKind = &filterKind
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterStatus(filterStatus []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter by fabricInterconnectId query param.  **Format:** filter.fabricInterconnectId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricInterconnectId&#x3D;$btw:John Doe&amp;filter.fabricInterconnectId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterFabricInterconnectId(filterFabricInterconnectId []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterFabricInterconnectId = &filterFabricInterconnectId
	return r
}

// Filter by transportId query param.  **Format:** filter.transportId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.transportId&#x3D;$btw:John Doe&amp;filter.transportId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) FilterTransportId(filterTransportId []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.filterTransportId = &filterTransportId
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;name:DESC   **Default Value:** id:DESC  **Available Fields** - id  - name  - label  - createdAt  - updatedAt 
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) SortBy(sortBy []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) Search(search string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** name,label   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - name  - label 
func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) SearchBy(searchBy []string) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) Execute() (*LogicalNetworkInterconnectPaginatedList, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkInterconnectsExecute(r)
}

/*
GetLogicalNetworkInterconnects Get all logical network interconnects

Returns list of all logical network interconnects with pagination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest
*/
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnects(ctx context.Context) LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest {
	return LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnectPaginatedList
func (a *LogicalNetworkInterconnectAPIService) GetLogicalNetworkInterconnectsExecute(r LogicalNetworkInterconnectAPIGetLogicalNetworkInterconnectsRequest) (*LogicalNetworkInterconnectPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnectPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.GetLogicalNetworkInterconnects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.filterFabricInterconnectId != nil {
		t := *r.filterFabricInterconnectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricInterconnectId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricInterconnectId", t, "form", "multi")
		}
	}
	if r.filterTransportId != nil {
		t := *r.filterTransportId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.transportId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.transportId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIRemoveLogicalNetworkFromLogicalNetworkInterconnectRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
	logicalNetworkId int32
}

func (r LogicalNetworkInterconnectAPIRemoveLogicalNetworkFromLogicalNetworkInterconnectRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveLogicalNetworkFromLogicalNetworkInterconnectExecute(r)
}

/*
RemoveLogicalNetworkFromLogicalNetworkInterconnect Remove a logical network from a logical network interconnect

Removes the association between a logical network and a logical network interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect
 @param logicalNetworkId The ID of the logical network
 @return LogicalNetworkInterconnectAPIRemoveLogicalNetworkFromLogicalNetworkInterconnectRequest
*/
func (a *LogicalNetworkInterconnectAPIService) RemoveLogicalNetworkFromLogicalNetworkInterconnect(ctx context.Context, id int32, logicalNetworkId int32) LogicalNetworkInterconnectAPIRemoveLogicalNetworkFromLogicalNetworkInterconnectRequest {
	return LogicalNetworkInterconnectAPIRemoveLogicalNetworkFromLogicalNetworkInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		logicalNetworkId: logicalNetworkId,
	}
}

// Execute executes the request
func (a *LogicalNetworkInterconnectAPIService) RemoveLogicalNetworkFromLogicalNetworkInterconnectExecute(r LogicalNetworkInterconnectAPIRemoveLogicalNetworkFromLogicalNetworkInterconnectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.RemoveLogicalNetworkFromLogicalNetworkInterconnect")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}/logical-networks/{logicalNetworkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logicalNetworkId"+"}", url.PathEscape(parameterValueToString(r.logicalNetworkId, "logicalNetworkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkInterconnectAPIService
	id int32
	updateLogicalNetworkInterconnectDto *UpdateLogicalNetworkInterconnectDto
	ifMatch *string
}

// The logical network interconnect update entity
func (r LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest) UpdateLogicalNetworkInterconnectDto(updateLogicalNetworkInterconnectDto UpdateLogicalNetworkInterconnectDto) LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest {
	r.updateLogicalNetworkInterconnectDto = &updateLogicalNetworkInterconnectDto
	return r
}

// Entity tag
func (r LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest) IfMatch(ifMatch string) LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest) Execute() (*LogicalNetworkInterconnect, *http.Response, error) {
	return r.ApiService.UpdateLogicalNetworkInterconnectExecute(r)
}

/*
UpdateLogicalNetworkInterconnect Update a logical network interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the logical network interconnect to update
 @return LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest
*/
func (a *LogicalNetworkInterconnectAPIService) UpdateLogicalNetworkInterconnect(ctx context.Context, id int32) LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest {
	return LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnect
func (a *LogicalNetworkInterconnectAPIService) UpdateLogicalNetworkInterconnectExecute(r LogicalNetworkInterconnectAPIUpdateLogicalNetworkInterconnectRequest) (*LogicalNetworkInterconnect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkInterconnectAPIService.UpdateLogicalNetworkInterconnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-interconnects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLogicalNetworkInterconnectDto == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetworkInterconnectDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateLogicalNetworkInterconnectDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
