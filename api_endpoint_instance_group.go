/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// EndpointInstanceGroupAPIService EndpointInstanceGroupAPI service
type EndpointInstanceGroupAPIService service

type EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	infrastructureId int32
	endpointInstanceGroupCreate *EndpointInstanceGroupCreate
}

// The Endpoint Instance Group to create
func (r EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest) EndpointInstanceGroupCreate(endpointInstanceGroupCreate EndpointInstanceGroupCreate) EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest {
	r.endpointInstanceGroupCreate = &endpointInstanceGroupCreate
	return r
}

func (r EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest) Execute() (*EndpointInstanceGroup, *http.Response, error) {
	return r.ApiService.CreateEndpointInstanceGroupExecute(r)
}

/*
CreateEndpointInstanceGroup Add a Endpoint Instance Group to an infrastructure. By default it will not have any instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest
*/
func (a *EndpointInstanceGroupAPIService) CreateEndpointInstanceGroup(ctx context.Context, infrastructureId int32) EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest {
	return EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroup
func (a *EndpointInstanceGroupAPIService) CreateEndpointInstanceGroupExecute(r EndpointInstanceGroupAPICreateEndpointInstanceGroupRequest) (*EndpointInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.CreateEndpointInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/endpoint-instance-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointInstanceGroupCreate == nil {
		return localVarReturnValue, nil, reportError("endpointInstanceGroupCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointInstanceGroupCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
	createLogicalNetworkACL *CreateLogicalNetworkACL
}

// The security rule to create
func (r EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest) CreateLogicalNetworkACL(createLogicalNetworkACL CreateLogicalNetworkACL) EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest {
	r.createLogicalNetworkACL = &createLogicalNetworkACL
	return r
}

func (r EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest) Execute() (*LogicalNetworkACL, *http.Response, error) {
	return r.ApiService.CreateEndpointInstanceGroupLogicalNetworkACLExecute(r)
}

/*
CreateEndpointInstanceGroupLogicalNetworkACL Create a security rule for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @return EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest
*/
func (a *EndpointInstanceGroupAPIService) CreateEndpointInstanceGroupLogicalNetworkACL(ctx context.Context, endpointInstanceGroupId int32, connectionId int32) EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest {
	return EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACL
func (a *EndpointInstanceGroupAPIService) CreateEndpointInstanceGroupLogicalNetworkACLExecute(r EndpointInstanceGroupAPICreateEndpointInstanceGroupLogicalNetworkACLRequest) (*LogicalNetworkACL, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.CreateEndpointInstanceGroupLogicalNetworkACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}/security/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkACL == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkACL is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkACL
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	createEndpointInstanceGroupNetworkConnection *CreateEndpointInstanceGroupNetworkConnection
}

// The network connection object to create
func (r EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest) CreateEndpointInstanceGroupNetworkConnection(createEndpointInstanceGroupNetworkConnection CreateEndpointInstanceGroupNetworkConnection) EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest {
	r.createEndpointInstanceGroupNetworkConnection = &createEndpointInstanceGroupNetworkConnection
	return r
}

func (r EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest) Execute() (*EndpointInstanceGroupNetworkConnection, *http.Response, error) {
	return r.ApiService.CreateEndpointInstanceGroupNetworkConfigurationConnectionExecute(r)
}

/*
CreateEndpointInstanceGroupNetworkConfigurationConnection Create a network connection for a endpoint instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest
*/
func (a *EndpointInstanceGroupAPIService) CreateEndpointInstanceGroupNetworkConfigurationConnection(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest {
	return EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupNetworkConnection
func (a *EndpointInstanceGroupAPIService) CreateEndpointInstanceGroupNetworkConfigurationConnectionExecute(r EndpointInstanceGroupAPICreateEndpointInstanceGroupNetworkConfigurationConnectionRequest) (*EndpointInstanceGroupNetworkConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupNetworkConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.CreateEndpointInstanceGroupNetworkConfigurationConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createEndpointInstanceGroupNetworkConnection == nil {
		return localVarReturnValue, nil, reportError("createEndpointInstanceGroupNetworkConnection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEndpointInstanceGroupNetworkConnection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	ifMatch *string
}

// Entity tag
func (r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest) IfMatch(ifMatch string) EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEndpointInstanceGroupExecute(r)
}

/*
DeleteEndpointInstanceGroup Delete Endpoint Instance Group. Will not take effect if there are instances in this group.

Delete Endpoint Instance Group. Will not take effect if there are instances in this group. To delete the instances in a group mark them for delete individually.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest
*/
func (a *EndpointInstanceGroupAPIService) DeleteEndpointInstanceGroup(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest {
	return EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
func (a *EndpointInstanceGroupAPIService) DeleteEndpointInstanceGroupExecute(r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.DeleteEndpointInstanceGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIDeleteEndpointInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
	ruleId int32
}

func (r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupLogicalNetworkACLRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEndpointInstanceGroupLogicalNetworkACLExecute(r)
}

/*
DeleteEndpointInstanceGroupLogicalNetworkACL Delete a security rule for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @param ruleId
 @return EndpointInstanceGroupAPIDeleteEndpointInstanceGroupLogicalNetworkACLRequest
*/
func (a *EndpointInstanceGroupAPIService) DeleteEndpointInstanceGroupLogicalNetworkACL(ctx context.Context, endpointInstanceGroupId int32, connectionId int32, ruleId int32) EndpointInstanceGroupAPIDeleteEndpointInstanceGroupLogicalNetworkACLRequest {
	return EndpointInstanceGroupAPIDeleteEndpointInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
		ruleId: ruleId,
	}
}

// Execute executes the request
func (a *EndpointInstanceGroupAPIService) DeleteEndpointInstanceGroupLogicalNetworkACLExecute(r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupLogicalNetworkACLRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.DeleteEndpointInstanceGroupLogicalNetworkACL")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}/security/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIDeleteEndpointInstanceGroupNetworkConfigurationConnectionRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
}

func (r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupNetworkConfigurationConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEndpointInstanceGroupNetworkConfigurationConnectionExecute(r)
}

/*
DeleteEndpointInstanceGroupNetworkConfigurationConnection Delete a network connection for a endpoint instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @return EndpointInstanceGroupAPIDeleteEndpointInstanceGroupNetworkConfigurationConnectionRequest
*/
func (a *EndpointInstanceGroupAPIService) DeleteEndpointInstanceGroupNetworkConfigurationConnection(ctx context.Context, endpointInstanceGroupId int32, connectionId int32) EndpointInstanceGroupAPIDeleteEndpointInstanceGroupNetworkConfigurationConnectionRequest {
	return EndpointInstanceGroupAPIDeleteEndpointInstanceGroupNetworkConfigurationConnectionRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
func (a *EndpointInstanceGroupAPIService) DeleteEndpointInstanceGroupNetworkConfigurationConnectionExecute(r EndpointInstanceGroupAPIDeleteEndpointInstanceGroupNetworkConfigurationConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.DeleteEndpointInstanceGroupNetworkConfigurationConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupRequest) Execute() (*EndpointInstanceGroup, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupExecute(r)
}

/*
GetEndpointInstanceGroup Get Endpoint Instance Groups details

Returns the details of the specified Endpoint Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroup(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroup
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupRequest) (*EndpointInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupConfigRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupConfigRequest) Execute() (*EndpointInstanceGroupConfiguration, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupConfigExecute(r)
}

/*
GetEndpointInstanceGroupConfig Get Endpoint Instance Group config details

Returns the config details of the specified Endpoint Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupConfigRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupConfig(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupConfigRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupConfigRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupConfiguration
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupConfigExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupConfigRequest) (*EndpointInstanceGroupConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterGroupId *[]string
	filterEndpointId *[]string
	filterServiceStatus *[]string
	filterConfigEndpointId *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) Page(page float32) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) Limit(limit float32) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterInfrastructureId(filterInfrastructureId []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by groupId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.groupId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.groupId&#x3D;$not:$like:John Doe&amp;filter.groupId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterGroupId(filterGroupId []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterGroupId = &filterGroupId
	return r
}

// Filter by endpointId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.endpointId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.endpointId&#x3D;$not:$like:John Doe&amp;filter.endpointId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterEndpointId(filterEndpointId []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterEndpointId = &filterEndpointId
	return r
}

// Filter by serviceStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serviceStatus&#x3D;$not:$like:John Doe&amp;filter.serviceStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterServiceStatus(filterServiceStatus []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.endpointId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.endpointId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.endpointId&#x3D;$not:$like:John Doe&amp;filter.config.endpointId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterConfigEndpointId(filterConfigEndpointId []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterConfigEndpointId = &filterConfigEndpointId
	return r
}

// Filter by config.deployStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployStatus&#x3D;$not:$like:John Doe&amp;filter.config.deployStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployType&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployType&#x3D;$not:$like:John Doe&amp;filter.config.deployType&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) FilterConfigDeployType(filterConfigDeployType []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;       
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) SortBy(sortBy []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) Search(search string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; label           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;         
func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) SearchBy(searchBy []string) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	r.searchBy = &searchBy
	return r
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) Execute() (*EndpointInstancePaginatedList, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupEndpointInstancesExecute(r)
}

/*
GetEndpointInstanceGroupEndpointInstances List Endpoint Instances for a Endpoint Instance Group

Returns list of Endpoint Instances in the specified group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupEndpointInstances(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return EndpointInstancePaginatedList
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupEndpointInstancesExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupEndpointInstancesRequest) (*EndpointInstancePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstancePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupEndpointInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/endpoint-instances"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterGroupId != nil {
		t := *r.filterGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", t, "form", "multi")
		}
	}
	if r.filterEndpointId != nil {
		t := *r.filterEndpointId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.endpointId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.endpointId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigEndpointId != nil {
		t := *r.filterConfigEndpointId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.endpointId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.endpointId", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLRequest) Execute() (*LogicalNetworkACL, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupLogicalNetworkACLExecute(r)
}

/*
GetEndpointInstanceGroupLogicalNetworkACL Get the security rules for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupLogicalNetworkACL(ctx context.Context, endpointInstanceGroupId int32, connectionId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACL
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupLogicalNetworkACLExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLRequest) (*LogicalNetworkACL, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupLogicalNetworkACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}/security/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLByIdRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
	ruleId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLByIdRequest) Execute() (*LogicalNetworkACL, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupLogicalNetworkACLByIdExecute(r)
}

/*
GetEndpointInstanceGroupLogicalNetworkACLById Get a security rule for a logical network by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @param ruleId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLByIdRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupLogicalNetworkACLById(ctx context.Context, endpointInstanceGroupId int32, connectionId int32, ruleId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLByIdRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLByIdRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACL
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupLogicalNetworkACLByIdExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupLogicalNetworkACLByIdRequest) (*LogicalNetworkACL, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupLogicalNetworkACLById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}/security/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationRequest) Execute() (*NetworkEndpointGroup, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupNetworkConfigurationExecute(r)
}

/*
GetEndpointInstanceGroupNetworkConfiguration Get endpoint instance group network configuration

Returns the network configuration of the specified endpoint instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupNetworkConfiguration(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return NetworkEndpointGroup
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupNetworkConfigurationExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationRequest) (*NetworkEndpointGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkEndpointGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupNetworkConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionByIdRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionByIdRequest) Execute() (*EndpointInstanceGroupNetworkConnection, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupNetworkConfigurationConnectionByIdExecute(r)
}

/*
GetEndpointInstanceGroupNetworkConfigurationConnectionById Get endpoint instance group network configuration connection by id

Returns the connection by id of the specified endpoint instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionByIdRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupNetworkConfigurationConnectionById(ctx context.Context, endpointInstanceGroupId int32, connectionId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionByIdRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionByIdRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupNetworkConnection
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupNetworkConfigurationConnectionByIdExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionByIdRequest) (*EndpointInstanceGroupNetworkConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupNetworkConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupNetworkConfigurationConnectionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionsRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
}

func (r EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionsRequest) Execute() (*EndpointInstanceGroupNetworkConnectionsList, *http.Response, error) {
	return r.ApiService.GetEndpointInstanceGroupNetworkConfigurationConnectionsExecute(r)
}

/*
GetEndpointInstanceGroupNetworkConfigurationConnections Get endpoint instance group's network connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionsRequest
*/
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupNetworkConfigurationConnections(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionsRequest {
	return EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionsRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupNetworkConnectionsList
func (a *EndpointInstanceGroupAPIService) GetEndpointInstanceGroupNetworkConfigurationConnectionsExecute(r EndpointInstanceGroupAPIGetEndpointInstanceGroupNetworkConfigurationConnectionsRequest) (*EndpointInstanceGroupNetworkConnectionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupNetworkConnectionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetEndpointInstanceGroupNetworkConfigurationConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	infrastructureId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterExtensionInstanceId *[]string
	filterServiceStatus *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) Page(page float32) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) Limit(limit float32) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) FilterInfrastructureId(filterInfrastructureId []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by extensionInstanceId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.extensionInstanceId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.extensionInstanceId&#x3D;$not:$like:John Doe&amp;filter.extensionInstanceId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) FilterExtensionInstanceId(filterExtensionInstanceId []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.filterExtensionInstanceId = &filterExtensionInstanceId
	return r
}

// Filter by serviceStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serviceStatus&#x3D;$not:$like:John Doe&amp;filter.serviceStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) FilterServiceStatus(filterServiceStatus []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.deployStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployStatus&#x3D;$not:$like:John Doe&amp;filter.config.deployStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployType&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployType&#x3D;$not:$like:John Doe&amp;filter.config.deployType&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) FilterConfigDeployType(filterConfigDeployType []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;       
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) SortBy(sortBy []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) Search(search string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; label           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;         
func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) SearchBy(searchBy []string) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	r.searchBy = &searchBy
	return r
}

func (r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) Execute() (*EndpointInstanceGroupPaginatedList, *http.Response, error) {
	return r.ApiService.GetInfrastructureEndpointInstanceGroupsExecute(r)
}

/*
GetInfrastructureEndpointInstanceGroups List Endpoint Instance Groups for an infrastructure

Returns list of Endpoint Instance Groups in the specified infrastructure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest
*/
func (a *EndpointInstanceGroupAPIService) GetInfrastructureEndpointInstanceGroups(ctx context.Context, infrastructureId int32) EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest {
	return EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupPaginatedList
func (a *EndpointInstanceGroupAPIService) GetInfrastructureEndpointInstanceGroupsExecute(r EndpointInstanceGroupAPIGetInfrastructureEndpointInstanceGroupsRequest) (*EndpointInstanceGroupPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.GetInfrastructureEndpointInstanceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/endpoint-instance-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterExtensionInstanceId != nil {
		t := *r.filterExtensionInstanceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.extensionInstanceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.extensionInstanceId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	endpointInstanceGroupUpdate *EndpointInstanceGroupUpdate
	ifMatch *string
}

// The Endpoint Instance Group configuration changes
func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest) EndpointInstanceGroupUpdate(endpointInstanceGroupUpdate EndpointInstanceGroupUpdate) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest {
	r.endpointInstanceGroupUpdate = &endpointInstanceGroupUpdate
	return r
}

// Entity tag
func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest) IfMatch(ifMatch string) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest) Execute() (*EndpointInstanceGroupConfiguration, *http.Response, error) {
	return r.ApiService.UpdateEndpointInstanceGroupConfigExecute(r)
}

/*
UpdateEndpointInstanceGroupConfig Updates Endpoint Instance Group configuration

Updates the specified Endpoint Instance Group configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest
*/
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupConfig(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest {
	return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupConfiguration
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupConfigExecute(r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupConfigRequest) (*EndpointInstanceGroupConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.UpdateEndpointInstanceGroupConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointInstanceGroupUpdate == nil {
		return localVarReturnValue, nil, reportError("endpointInstanceGroupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.endpointInstanceGroupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId int32
	ruleId int32
	updateLogicalNetworkACL *UpdateLogicalNetworkACL
}

// The security rule to update
func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest) UpdateLogicalNetworkACL(updateLogicalNetworkACL UpdateLogicalNetworkACL) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest {
	r.updateLogicalNetworkACL = &updateLogicalNetworkACL
	return r
}

func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest) Execute() (*LogicalNetworkACL, *http.Response, error) {
	return r.ApiService.UpdateEndpointInstanceGroupLogicalNetworkACLExecute(r)
}

/*
UpdateEndpointInstanceGroupLogicalNetworkACL Update a security rule for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @param ruleId
 @return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest
*/
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupLogicalNetworkACL(ctx context.Context, endpointInstanceGroupId int32, connectionId int32, ruleId int32) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest {
	return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACL
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupLogicalNetworkACLExecute(r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupLogicalNetworkACLRequest) (*LogicalNetworkACL, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.UpdateEndpointInstanceGroupLogicalNetworkACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}/security/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLogicalNetworkACL == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetworkACL is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLogicalNetworkACL
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	genericMeta *GenericMeta
}

// The Endpoint Instance Group meta information
func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest) GenericMeta(genericMeta GenericMeta) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest {
	r.genericMeta = &genericMeta
	return r
}

func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEndpointInstanceGroupMetaExecute(r)
}

/*
UpdateEndpointInstanceGroupMeta Update an Endpoint Instance Group meta information

Updates the specified Endpoint Instance Group meta information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest
*/
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupMeta(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest {
	return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupMetaExecute(r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupMetaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.UpdateEndpointInstanceGroupMeta")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.genericMeta == nil {
		return nil, reportError("genericMeta is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.genericMeta
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
}

func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationRequest) Execute() (*NetworkEndpointGroup, *http.Response, error) {
	return r.ApiService.UpdateEndpointInstanceGroupNetworkConfigurationExecute(r)
}

/*
UpdateEndpointInstanceGroupNetworkConfiguration Create or return the network configuration of the specified endpoint instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationRequest
*/
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupNetworkConfiguration(ctx context.Context, endpointInstanceGroupId int32) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationRequest {
	return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
	}
}

// Execute executes the request
//  @return NetworkEndpointGroup
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupNetworkConfigurationExecute(r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationRequest) (*NetworkEndpointGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkEndpointGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.UpdateEndpointInstanceGroupNetworkConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest struct {
	ctx context.Context
	ApiService *EndpointInstanceGroupAPIService
	endpointInstanceGroupId int32
	connectionId float32
	updateNetworkEndpointGroupLogicalNetwork *UpdateNetworkEndpointGroupLogicalNetwork
}

// The network connection object to update
func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest) UpdateNetworkEndpointGroupLogicalNetwork(updateNetworkEndpointGroupLogicalNetwork UpdateNetworkEndpointGroupLogicalNetwork) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest {
	r.updateNetworkEndpointGroupLogicalNetwork = &updateNetworkEndpointGroupLogicalNetwork
	return r
}

func (r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest) Execute() (*EndpointInstanceGroupNetworkConnection, *http.Response, error) {
	return r.ApiService.UpdateEndpointInstanceGroupNetworkConfigurationConnectionExecute(r)
}

/*
UpdateEndpointInstanceGroupNetworkConfigurationConnection Update a network connection for a endpoint instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointInstanceGroupId
 @param connectionId
 @return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest
*/
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupNetworkConfigurationConnection(ctx context.Context, endpointInstanceGroupId int32, connectionId float32) EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest {
	return EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest{
		ApiService: a,
		ctx: ctx,
		endpointInstanceGroupId: endpointInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return EndpointInstanceGroupNetworkConnection
func (a *EndpointInstanceGroupAPIService) UpdateEndpointInstanceGroupNetworkConfigurationConnectionExecute(r EndpointInstanceGroupAPIUpdateEndpointInstanceGroupNetworkConfigurationConnectionRequest) (*EndpointInstanceGroupNetworkConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointInstanceGroupNetworkConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointInstanceGroupAPIService.UpdateEndpointInstanceGroupNetworkConfigurationConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/endpoint-instance-groups/{endpointInstanceGroupId}/config/networking/connections/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.endpointInstanceGroupId, "endpointInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateNetworkEndpointGroupLogicalNetwork == nil {
		return localVarReturnValue, nil, reportError("updateNetworkEndpointGroupLogicalNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkEndpointGroupLogicalNetwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
