/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// NetworkFabricInterconnectAPIService NetworkFabricInterconnectAPI service
type NetworkFabricInterconnectAPIService service

type NetworkFabricInterconnectAPIAcceptNetworkFabricInterconnectDeployRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id float32
}

func (r NetworkFabricInterconnectAPIAcceptNetworkFabricInterconnectDeployRequest) Execute() (*http.Response, error) {
	return r.ApiService.AcceptNetworkFabricInterconnectDeployExecute(r)
}

/*
AcceptNetworkFabricInterconnectDeploy Accepts the deployment of the specified network fabric interconnect

Accepts the deployment of the specified network fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return NetworkFabricInterconnectAPIAcceptNetworkFabricInterconnectDeployRequest
*/
func (a *NetworkFabricInterconnectAPIService) AcceptNetworkFabricInterconnectDeploy(ctx context.Context, id float32) NetworkFabricInterconnectAPIAcceptNetworkFabricInterconnectDeployRequest {
	return NetworkFabricInterconnectAPIAcceptNetworkFabricInterconnectDeployRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *NetworkFabricInterconnectAPIService) AcceptNetworkFabricInterconnectDeployExecute(r NetworkFabricInterconnectAPIAcceptNetworkFabricInterconnectDeployRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.AcceptNetworkFabricInterconnectDeploy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/actions/accept-deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPICreateInterconnectLinkRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
	createNetworkFabricInterconnectLink *CreateNetworkFabricInterconnectLink
}

// The network fabric link to create
func (r NetworkFabricInterconnectAPICreateInterconnectLinkRequest) CreateNetworkFabricInterconnectLink(createNetworkFabricInterconnectLink CreateNetworkFabricInterconnectLink) NetworkFabricInterconnectAPICreateInterconnectLinkRequest {
	r.createNetworkFabricInterconnectLink = &createNetworkFabricInterconnectLink
	return r
}

func (r NetworkFabricInterconnectAPICreateInterconnectLinkRequest) Execute() (*NetworkFabricInterconnectLink, *http.Response, error) {
	return r.ApiService.CreateInterconnectLinkExecute(r)
}

/*
CreateInterconnectLink Create a new link within an interconnect

Creates a new network fabric interconnect link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect
 @return NetworkFabricInterconnectAPICreateInterconnectLinkRequest
*/
func (a *NetworkFabricInterconnectAPIService) CreateInterconnectLink(ctx context.Context, id int32) NetworkFabricInterconnectAPICreateInterconnectLinkRequest {
	return NetworkFabricInterconnectAPICreateInterconnectLinkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnectLink
func (a *NetworkFabricInterconnectAPIService) CreateInterconnectLinkExecute(r NetworkFabricInterconnectAPICreateInterconnectLinkRequest) (*NetworkFabricInterconnectLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnectLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.CreateInterconnectLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNetworkFabricInterconnectLink == nil {
		return localVarReturnValue, nil, reportError("createNetworkFabricInterconnectLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkFabricInterconnectLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	createNetworkFabricInterconnect *CreateNetworkFabricInterconnect
}

// The network fabric interconnect to create
func (r NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest) CreateNetworkFabricInterconnect(createNetworkFabricInterconnect CreateNetworkFabricInterconnect) NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest {
	r.createNetworkFabricInterconnect = &createNetworkFabricInterconnect
	return r
}

func (r NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest) Execute() (*NetworkFabricInterconnect, *http.Response, error) {
	return r.ApiService.CreateNetworkFabricInterconnectExecute(r)
}

/*
CreateNetworkFabricInterconnect Create a new network fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest
*/
func (a *NetworkFabricInterconnectAPIService) CreateNetworkFabricInterconnect(ctx context.Context) NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest {
	return NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnect
func (a *NetworkFabricInterconnectAPIService) CreateNetworkFabricInterconnectExecute(r NetworkFabricInterconnectAPICreateNetworkFabricInterconnectRequest) (*NetworkFabricInterconnect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.CreateNetworkFabricInterconnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNetworkFabricInterconnect == nil {
		return localVarReturnValue, nil, reportError("createNetworkFabricInterconnect is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkFabricInterconnect
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
	linkId int32
	ifMatch *string
}

// Entity tag
func (r NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest) IfMatch(ifMatch string) NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInterconnectLinkExecute(r)
}

/*
DeleteInterconnectLink Delete a specific fabric interconnect link

Deletes a specific network fabric link that is part of the specified fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect
 @param linkId The ID of the network fabric link
 @return NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest
*/
func (a *NetworkFabricInterconnectAPIService) DeleteInterconnectLink(ctx context.Context, id int32, linkId int32) NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest {
	return NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		linkId: linkId,
	}
}

// Execute executes the request
func (a *NetworkFabricInterconnectAPIService) DeleteInterconnectLinkExecute(r NetworkFabricInterconnectAPIDeleteInterconnectLinkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.DeleteInterconnectLink")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/links/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", url.PathEscape(parameterValueToString(r.linkId, "linkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIDeleteNetworkFabricInterconnectRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
}

func (r NetworkFabricInterconnectAPIDeleteNetworkFabricInterconnectRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNetworkFabricInterconnectExecute(r)
}

/*
DeleteNetworkFabricInterconnect Delete a network fabric interconnect by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect to delete
 @return NetworkFabricInterconnectAPIDeleteNetworkFabricInterconnectRequest
*/
func (a *NetworkFabricInterconnectAPIService) DeleteNetworkFabricInterconnect(ctx context.Context, id int32) NetworkFabricInterconnectAPIDeleteNetworkFabricInterconnectRequest {
	return NetworkFabricInterconnectAPIDeleteNetworkFabricInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *NetworkFabricInterconnectAPIService) DeleteNetworkFabricInterconnectExecute(r NetworkFabricInterconnectAPIDeleteNetworkFabricInterconnectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.DeleteNetworkFabricInterconnect")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id float32
	networkFabricInterconnectDeployOptions *NetworkFabricInterconnectDeployOptions
}

// Network fabric interconnect deploy options
func (r NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest) NetworkFabricInterconnectDeployOptions(networkFabricInterconnectDeployOptions NetworkFabricInterconnectDeployOptions) NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest {
	r.networkFabricInterconnectDeployOptions = &networkFabricInterconnectDeployOptions
	return r
}

func (r NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest) Execute() (*JobInfo, *http.Response, error) {
	return r.ApiService.DeployNetworkFabricInterconnectExecute(r)
}

/*
DeployNetworkFabricInterconnect Deploys the specified network fabric interconnect

Deploys the specified network fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest
*/
func (a *NetworkFabricInterconnectAPIService) DeployNetworkFabricInterconnect(ctx context.Context, id float32) NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest {
	return NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobInfo
func (a *NetworkFabricInterconnectAPIService) DeployNetworkFabricInterconnectExecute(r NetworkFabricInterconnectAPIDeployNetworkFabricInterconnectRequest) (*JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.DeployNetworkFabricInterconnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/actions/deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkFabricInterconnectDeployOptions == nil {
		return localVarReturnValue, nil, reportError("networkFabricInterconnectDeployOptions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkFabricInterconnectDeployOptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
	page *float32
	limit *float32
	filterId *[]string
	filterName *[]string
	filterDescription *[]string
	filterStatus *[]string
	filterSiteId *[]string
	filterFabricConfigurationFabricType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) Page(page float32) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) Limit(limit float32) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) FilterId(filterId []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.filterId = &filterId
	return r
}

// Filter by name query param.  **Format:** filter.name&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.name&#x3D;$btw:John Doe&amp;filter.name&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) FilterName(filterName []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.filterName = &filterName
	return r
}

// Filter by description query param.  **Format:** filter.description&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.description&#x3D;$btw:John Doe&amp;filter.description&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) FilterDescription(filterDescription []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.filterDescription = &filterDescription
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) FilterStatus(filterStatus []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter by siteId query param.  **Format:** filter.siteId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.siteId&#x3D;$btw:John Doe&amp;filter.siteId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) FilterSiteId(filterSiteId []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.filterSiteId = &filterSiteId
	return r
}

// Filter by fabricConfiguration.fabricType query param.  **Format:** filter.fabricConfiguration.fabricType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricConfiguration.fabricType&#x3D;$btw:John Doe&amp;filter.fabricConfiguration.fabricType&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) FilterFabricConfigurationFabricType(filterFabricConfigurationFabricType []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.filterFabricConfigurationFabricType = &filterFabricConfigurationFabricType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;siteId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - siteId  - name  - createdTimestamp  - updatedTimestamp 
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) SortBy(sortBy []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) Search(search string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** name,description,status,siteId,fabricConfiguration.fabricType   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - name  - description  - status  - siteId  - fabricConfiguration.fabricType 
func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) SearchBy(searchBy []string) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	r.searchBy = &searchBy
	return r
}

func (r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) Execute() (*NetworkFabricPaginatedList, *http.Response, error) {
	return r.ApiService.GetFabricInterconnectAvailableFabricsExecute(r)
}

/*
GetFabricInterconnectAvailableFabrics Get the available fabrics for a fabric interconnect

Returns a paginated list of network fabrics that can be added to the specified fabric interconnect and are not already part of it

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect
 @return NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetFabricInterconnectAvailableFabrics(ctx context.Context, id int32) NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest {
	return NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetworkFabricPaginatedList
func (a *NetworkFabricInterconnectAPIService) GetFabricInterconnectAvailableFabricsExecute(r NetworkFabricInterconnectAPIGetFabricInterconnectAvailableFabricsRequest) (*NetworkFabricPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetFabricInterconnectAvailableFabrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/fabrics-available"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterDescription != nil {
		t := *r.filterDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.description", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.filterSiteId != nil {
		t := *r.filterSiteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", t, "form", "multi")
		}
	}
	if r.filterFabricConfigurationFabricType != nil {
		t := *r.filterFabricConfigurationFabricType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricConfiguration.fabricType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricConfiguration.fabricType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetFabricInterconnectFabricsRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
}

func (r NetworkFabricInterconnectAPIGetFabricInterconnectFabricsRequest) Execute() (*NetworkFabricList, *http.Response, error) {
	return r.ApiService.GetFabricInterconnectFabricsExecute(r)
}

/*
GetFabricInterconnectFabrics Get the fabrics for a fabric interconnect

Returns a list of network fabrics that are part of the specified fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect
 @return NetworkFabricInterconnectAPIGetFabricInterconnectFabricsRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetFabricInterconnectFabrics(ctx context.Context, id int32) NetworkFabricInterconnectAPIGetFabricInterconnectFabricsRequest {
	return NetworkFabricInterconnectAPIGetFabricInterconnectFabricsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetworkFabricList
func (a *NetworkFabricInterconnectAPIService) GetFabricInterconnectFabricsExecute(r NetworkFabricInterconnectAPIGetFabricInterconnectFabricsRequest) (*NetworkFabricList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetFabricInterconnectFabrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/fabrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetInterconnectLinkRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
	linkId int32
}

func (r NetworkFabricInterconnectAPIGetInterconnectLinkRequest) Execute() (*NetworkFabricInterconnectLink, *http.Response, error) {
	return r.ApiService.GetInterconnectLinkExecute(r)
}

/*
GetInterconnectLink Get a specific fabric interconnect link

Returns a specific network fabric link that is part of the specified fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect
 @param linkId The ID of the network fabric link
 @return NetworkFabricInterconnectAPIGetInterconnectLinkRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetInterconnectLink(ctx context.Context, id int32, linkId int32) NetworkFabricInterconnectAPIGetInterconnectLinkRequest {
	return NetworkFabricInterconnectAPIGetInterconnectLinkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		linkId: linkId,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnectLink
func (a *NetworkFabricInterconnectAPIService) GetInterconnectLinkExecute(r NetworkFabricInterconnectAPIGetInterconnectLinkRequest) (*NetworkFabricInterconnectLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnectLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetInterconnectLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/links/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", url.PathEscape(parameterValueToString(r.linkId, "linkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetInterconnectLinksRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
	page *float32
	limit *float32
	filterId *[]string
	filterInterconnectId *[]string
	filterFabricAId *[]string
	filterFabricANetworkEquipmentId *[]string
	filterFabricBId *[]string
	filterFabricBNetworkEquipmentId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
	select_ *string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) Page(page float32) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) Limit(limit float32) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) FilterId(filterId []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.filterId = &filterId
	return r
}

// Filter by interconnectId query param.  **Format:** filter.interconnectId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.interconnectId&#x3D;$btw:John Doe&amp;filter.interconnectId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) FilterInterconnectId(filterInterconnectId []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.filterInterconnectId = &filterInterconnectId
	return r
}

// Filter by fabricAId query param.  **Format:** filter.fabricAId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricAId&#x3D;$btw:John Doe&amp;filter.fabricAId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) FilterFabricAId(filterFabricAId []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.filterFabricAId = &filterFabricAId
	return r
}

// Filter by fabricANetworkEquipmentId query param.  **Format:** filter.fabricANetworkEquipmentId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricANetworkEquipmentId&#x3D;$btw:John Doe&amp;filter.fabricANetworkEquipmentId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) FilterFabricANetworkEquipmentId(filterFabricANetworkEquipmentId []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.filterFabricANetworkEquipmentId = &filterFabricANetworkEquipmentId
	return r
}

// Filter by fabricBId query param.  **Format:** filter.fabricBId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricBId&#x3D;$btw:John Doe&amp;filter.fabricBId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) FilterFabricBId(filterFabricBId []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.filterFabricBId = &filterFabricBId
	return r
}

// Filter by fabricBNetworkEquipmentId query param.  **Format:** filter.fabricBNetworkEquipmentId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricBNetworkEquipmentId&#x3D;$btw:John Doe&amp;filter.fabricBNetworkEquipmentId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) FilterFabricBNetworkEquipmentId(filterFabricBNetworkEquipmentId []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.filterFabricBNetworkEquipmentId = &filterFabricBNetworkEquipmentId
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;interconnectId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - interconnectId  - status  - fabricAId  - fabricANetworkEquipmentId  - fabricBId  - fabricBNetworkEquipmentId 
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) SortBy(sortBy []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) Search(search string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:**    **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields**  
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) SearchBy(searchBy []string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.searchBy = &searchBy
	return r
}

// List of fields to select.  **Example:** id,revision,status,interconnectId,fabricAId   **Default Value:** By default all fields returns. If you want to select only some fields, provide them in query param  
func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) Select_(select_ string) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	r.select_ = &select_
	return r
}

func (r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) Execute() (*NetworkFabricInterconnectLinksPaginatedList, *http.Response, error) {
	return r.ApiService.GetInterconnectLinksExecute(r)
}

/*
GetInterconnectLinks Get all fabric interconnect links

Returns list of all network fabric links that are part of the specified fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect
 @return NetworkFabricInterconnectAPIGetInterconnectLinksRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetInterconnectLinks(ctx context.Context, id int32) NetworkFabricInterconnectAPIGetInterconnectLinksRequest {
	return NetworkFabricInterconnectAPIGetInterconnectLinksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnectLinksPaginatedList
func (a *NetworkFabricInterconnectAPIService) GetInterconnectLinksExecute(r NetworkFabricInterconnectAPIGetInterconnectLinksRequest) (*NetworkFabricInterconnectLinksPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnectLinksPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetInterconnectLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterInterconnectId != nil {
		t := *r.filterInterconnectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.interconnectId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.interconnectId", t, "form", "multi")
		}
	}
	if r.filterFabricAId != nil {
		t := *r.filterFabricAId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricAId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricAId", t, "form", "multi")
		}
	}
	if r.filterFabricANetworkEquipmentId != nil {
		t := *r.filterFabricANetworkEquipmentId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricANetworkEquipmentId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricANetworkEquipmentId", t, "form", "multi")
		}
	}
	if r.filterFabricBId != nil {
		t := *r.filterFabricBId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricBId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricBId", t, "form", "multi")
		}
	}
	if r.filterFabricBNetworkEquipmentId != nil {
		t := *r.filterFabricBNetworkEquipmentId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricBNetworkEquipmentId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricBNetworkEquipmentId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetNetworkFabricInterconnectByIdRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
}

func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectByIdRequest) Execute() (*NetworkFabricInterconnect, *http.Response, error) {
	return r.ApiService.GetNetworkFabricInterconnectByIdExecute(r)
}

/*
GetNetworkFabricInterconnectById Get a network fabric interconnect by ID

Returns a network fabric interconnect by its ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect to retrieve
 @return NetworkFabricInterconnectAPIGetNetworkFabricInterconnectByIdRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetNetworkFabricInterconnectById(ctx context.Context, id int32) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectByIdRequest {
	return NetworkFabricInterconnectAPIGetNetworkFabricInterconnectByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnect
func (a *NetworkFabricInterconnectAPIService) GetNetworkFabricInterconnectByIdExecute(r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectByIdRequest) (*NetworkFabricInterconnect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetNetworkFabricInterconnectById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetNetworkFabricInterconnectTemplateByTypeRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	interconnectType NetworkFabricInterconnectType
}

func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectTemplateByTypeRequest) Execute() (*NetworkFabricInterconnectTemplate, *http.Response, error) {
	return r.ApiService.GetNetworkFabricInterconnectTemplateByTypeExecute(r)
}

/*
GetNetworkFabricInterconnectTemplateByType Get a network fabric interconnect template configuration by type

Returns a network fabric interconnect template by its type as suggested by the Metalsoft software

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interconnectType The type of the network fabric interconnect (e.g., dci-evpn)
 @return NetworkFabricInterconnectAPIGetNetworkFabricInterconnectTemplateByTypeRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetNetworkFabricInterconnectTemplateByType(ctx context.Context, interconnectType NetworkFabricInterconnectType) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectTemplateByTypeRequest {
	return NetworkFabricInterconnectAPIGetNetworkFabricInterconnectTemplateByTypeRequest{
		ApiService: a,
		ctx: ctx,
		interconnectType: interconnectType,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnectTemplate
func (a *NetworkFabricInterconnectAPIService) GetNetworkFabricInterconnectTemplateByTypeExecute(r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectTemplateByTypeRequest) (*NetworkFabricInterconnectTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnectTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetNetworkFabricInterconnectTemplateByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/template/{interconnectType}"
	localVarPath = strings.Replace(localVarPath, "{"+"interconnectType"+"}", url.PathEscape(parameterValueToString(r.interconnectType, "interconnectType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterLabel *[]string
	filterName *[]string
	filterDescription *[]string
	filterStatus *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) Page(page float32) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) Limit(limit float32) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) FilterId(filterId []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.filterId = &filterId
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$btw:John Doe&amp;filter.label&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) FilterLabel(filterLabel []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.  **Format:** filter.name&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.name&#x3D;$btw:John Doe&amp;filter.name&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) FilterName(filterName []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.filterName = &filterName
	return r
}

// Filter by description query param.  **Format:** filter.description&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.description&#x3D;$btw:John Doe&amp;filter.description&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) FilterDescription(filterDescription []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.filterDescription = &filterDescription
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) FilterStatus(filterStatus []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.filterStatus = &filterStatus
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;name:DESC   **Default Value:** id:DESC  **Available Fields** - id  - name  - createdTimestamp  - updatedTimestamp 
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) SortBy(sortBy []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) Search(search string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** name,label,description   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - name  - label  - description 
func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) SearchBy(searchBy []string) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	r.searchBy = &searchBy
	return r
}

func (r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) Execute() (*NetworkFabricInterconnectPaginatedList, *http.Response, error) {
	return r.ApiService.GetNetworkFabricInterconnectsExecute(r)
}

/*
GetNetworkFabricInterconnects Get all network fabric interconnects

Returns list of all fabric interconnects with pagination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest
*/
func (a *NetworkFabricInterconnectAPIService) GetNetworkFabricInterconnects(ctx context.Context) NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest {
	return NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnectPaginatedList
func (a *NetworkFabricInterconnectAPIService) GetNetworkFabricInterconnectsExecute(r NetworkFabricInterconnectAPIGetNetworkFabricInterconnectsRequest) (*NetworkFabricInterconnectPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnectPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.GetNetworkFabricInterconnects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterDescription != nil {
		t := *r.filterDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.description", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIRejectNetworkFabricInterconnectDeployRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id float32
}

func (r NetworkFabricInterconnectAPIRejectNetworkFabricInterconnectDeployRequest) Execute() (*http.Response, error) {
	return r.ApiService.RejectNetworkFabricInterconnectDeployExecute(r)
}

/*
RejectNetworkFabricInterconnectDeploy Rejects the deployment of the specified network fabric interconnect

Rejects the deployment of the specified network fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return NetworkFabricInterconnectAPIRejectNetworkFabricInterconnectDeployRequest
*/
func (a *NetworkFabricInterconnectAPIService) RejectNetworkFabricInterconnectDeploy(ctx context.Context, id float32) NetworkFabricInterconnectAPIRejectNetworkFabricInterconnectDeployRequest {
	return NetworkFabricInterconnectAPIRejectNetworkFabricInterconnectDeployRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *NetworkFabricInterconnectAPIService) RejectNetworkFabricInterconnectDeployExecute(r NetworkFabricInterconnectAPIRejectNetworkFabricInterconnectDeployRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.RejectNetworkFabricInterconnectDeploy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}/actions/reject-deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest struct {
	ctx context.Context
	ApiService *NetworkFabricInterconnectAPIService
	id int32
	updateNetworkFabricInterconnect *UpdateNetworkFabricInterconnect
	ifMatch *string
}

// The network fabric interconnect update entity
func (r NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest) UpdateNetworkFabricInterconnect(updateNetworkFabricInterconnect UpdateNetworkFabricInterconnect) NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest {
	r.updateNetworkFabricInterconnect = &updateNetworkFabricInterconnect
	return r
}

// Entity tag
func (r NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest) IfMatch(ifMatch string) NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest) Execute() (*NetworkFabricInterconnect, *http.Response, error) {
	return r.ApiService.UpdateNetworkFabricInterconnectExecute(r)
}

/*
UpdateNetworkFabricInterconnect Update a network fabric interconnect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the network fabric interconnect to update
 @return NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest
*/
func (a *NetworkFabricInterconnectAPIService) UpdateNetworkFabricInterconnect(ctx context.Context, id int32) NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest {
	return NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NetworkFabricInterconnect
func (a *NetworkFabricInterconnectAPIService) UpdateNetworkFabricInterconnectExecute(r NetworkFabricInterconnectAPIUpdateNetworkFabricInterconnectRequest) (*NetworkFabricInterconnect, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkFabricInterconnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkFabricInterconnectAPIService.UpdateNetworkFabricInterconnect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-fabric-interconnects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateNetworkFabricInterconnect == nil {
		return localVarReturnValue, nil, reportError("updateNetworkFabricInterconnect is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateNetworkFabricInterconnect
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
