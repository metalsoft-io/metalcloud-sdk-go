/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// JobAPIService JobAPI service
type JobAPIService service

type JobAPICreateCronJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	createCronJob *CreateCronJob
}

// The cron job details
func (r JobAPICreateCronJobRequest) CreateCronJob(createCronJob CreateCronJob) JobAPICreateCronJobRequest {
	r.createCronJob = &createCronJob
	return r
}

func (r JobAPICreateCronJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCronJobExecute(r)
}

/*
CreateCronJob Creates a new cron job

Creates a new cron job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPICreateCronJobRequest
*/
func (a *JobAPIService) CreateCronJob(ctx context.Context) JobAPICreateCronJobRequest {
	return JobAPICreateCronJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobAPIService) CreateCronJobExecute(r JobAPICreateCronJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.CreateCronJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cron-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCronJob == nil {
		return nil, reportError("createCronJob is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCronJob
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JobAPIDeleteCronJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	cronJobId float32
}

func (r JobAPIDeleteCronJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCronJobExecute(r)
}

/*
DeleteCronJob Delete cron job

Deletes a cron job by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cronJobId
 @return JobAPIDeleteCronJobRequest
*/
func (a *JobAPIService) DeleteCronJob(ctx context.Context, cronJobId float32) JobAPIDeleteCronJobRequest {
	return JobAPIDeleteCronJobRequest{
		ApiService: a,
		ctx: ctx,
		cronJobId: cronJobId,
	}
}

// Execute executes the request
func (a *JobAPIService) DeleteCronJobExecute(r JobAPIDeleteCronJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.DeleteCronJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cron-jobs/{cronJobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cronJobId"+"}", url.PathEscape(parameterValueToString(r.cronJobId, "cronJobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JobAPIGetCronJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	cronJobId float32
}

func (r JobAPIGetCronJobRequest) Execute() (*CronJob, *http.Response, error) {
	return r.ApiService.GetCronJobExecute(r)
}

/*
GetCronJob Get cron job information

Returns cron job information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cronJobId
 @return JobAPIGetCronJobRequest
*/
func (a *JobAPIService) GetCronJob(ctx context.Context, cronJobId float32) JobAPIGetCronJobRequest {
	return JobAPIGetCronJobRequest{
		ApiService: a,
		ctx: ctx,
		cronJobId: cronJobId,
	}
}

// Execute executes the request
//  @return CronJob
func (a *JobAPIService) GetCronJobExecute(r JobAPIGetCronJobRequest) (*CronJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CronJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetCronJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cron-jobs/{cronJobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cronJobId"+"}", url.PathEscape(parameterValueToString(r.cronJobId, "cronJobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetCronJobsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	page *float32
	limit *float32
	filterLabel *[]string
	filterDescription *[]string
	filterFunctionName *[]string
	filterDisabled *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r JobAPIGetCronJobsRequest) Page(page float32) JobAPIGetCronJobsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r JobAPIGetCronJobsRequest) Limit(limit float32) JobAPIGetCronJobsRequest {
	r.limit = &limit
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$ilike:John Doe  **Available Operations** - $ilike  - $and  - $or
func (r JobAPIGetCronJobsRequest) FilterLabel(filterLabel []string) JobAPIGetCronJobsRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by description query param.  **Format:** filter.description&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.description&#x3D;$ilike:John Doe  **Available Operations** - $ilike  - $and  - $or
func (r JobAPIGetCronJobsRequest) FilterDescription(filterDescription []string) JobAPIGetCronJobsRequest {
	r.filterDescription = &filterDescription
	return r
}

// Filter by functionName query param.  **Format:** filter.functionName&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.functionName&#x3D;$ilike:John Doe  **Available Operations** - $ilike  - $and  - $or
func (r JobAPIGetCronJobsRequest) FilterFunctionName(filterFunctionName []string) JobAPIGetCronJobsRequest {
	r.filterFunctionName = &filterFunctionName
	return r
}

// Filter by disabled query param.  **Format:** filter.disabled&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.disabled&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r JobAPIGetCronJobsRequest) FilterDisabled(filterDisabled []string) JobAPIGetCronJobsRequest {
	r.filterDisabled = &filterDisabled
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;label:DESC&amp;sortBy&#x3D;functionName:DESC   **Default Value:** id:ASC  **Available Fields** - label  - functionName  - disabled 
func (r JobAPIGetCronJobsRequest) SortBy(sortBy []string) JobAPIGetCronJobsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r JobAPIGetCronJobsRequest) Search(search string) JobAPIGetCronJobsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** label,description,functionName   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - label  - description  - functionName 
func (r JobAPIGetCronJobsRequest) SearchBy(searchBy []string) JobAPIGetCronJobsRequest {
	r.searchBy = &searchBy
	return r
}

func (r JobAPIGetCronJobsRequest) Execute() (*CronJobPaginatedList, *http.Response, error) {
	return r.ApiService.GetCronJobsExecute(r)
}

/*
GetCronJobs Get a list of cron jobs

Returns a list of cron Jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPIGetCronJobsRequest
*/
func (a *JobAPIService) GetCronJobs(ctx context.Context) JobAPIGetCronJobsRequest {
	return JobAPIGetCronJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CronJobPaginatedList
func (a *JobAPIService) GetCronJobsExecute(r JobAPIGetCronJobsRequest) (*CronJobPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CronJobPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetCronJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cron-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterDescription != nil {
		t := *r.filterDescription
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.description", t, "form", "multi")
		}
	}
	if r.filterFunctionName != nil {
		t := *r.filterFunctionName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.functionName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.functionName", t, "form", "multi")
		}
	}
	if r.filterDisabled != nil {
		t := *r.filterDisabled
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.disabled", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.disabled", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetCronJobsSupportedFunctionsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
}

func (r JobAPIGetCronJobsSupportedFunctionsRequest) Execute() ([]CronJobFunction, *http.Response, error) {
	return r.ApiService.GetCronJobsSupportedFunctionsExecute(r)
}

/*
GetCronJobsSupportedFunctions Get a list of supported functions for cron jobs

Returns a list of supported functions for cron jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPIGetCronJobsSupportedFunctionsRequest
*/
func (a *JobAPIService) GetCronJobsSupportedFunctions(ctx context.Context) JobAPIGetCronJobsSupportedFunctionsRequest {
	return JobAPIGetCronJobsSupportedFunctionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CronJobFunction
func (a *JobAPIService) GetCronJobsSupportedFunctionsExecute(r JobAPIGetCronJobsSupportedFunctionsRequest) ([]CronJobFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CronJobFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetCronJobsSupportedFunctions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cron-jobs/supported-functions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId float32
}

func (r JobAPIGetJobRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.GetJobExecute(r)
}

/*
GetJob Get Job information

Returns Job information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return JobAPIGetJobRequest
*/
func (a *JobAPIService) GetJob(ctx context.Context, jobId float32) JobAPIGetJobRequest {
	return JobAPIGetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return Job
func (a *JobAPIService) GetJobExecute(r JobAPIGetJobRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobExceptionsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId float32
	page *float32
	limit *float32
	filterExceptionId *[]string
	filterArchiveId *[]string
	filterCreatedTimestamp *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r JobAPIGetJobExceptionsRequest) Page(page float32) JobAPIGetJobExceptionsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r JobAPIGetJobExceptionsRequest) Limit(limit float32) JobAPIGetJobExceptionsRequest {
	r.limit = &limit
	return r
}

// Filter by exceptionId query param.  **Format:** filter.exceptionId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.exceptionId&#x3D;$btw:John Doe&amp;filter.exceptionId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobExceptionsRequest) FilterExceptionId(filterExceptionId []string) JobAPIGetJobExceptionsRequest {
	r.filterExceptionId = &filterExceptionId
	return r
}

// Filter by archiveId query param.  **Format:** filter.archiveId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.archiveId&#x3D;$btw:John Doe&amp;filter.archiveId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobExceptionsRequest) FilterArchiveId(filterArchiveId []string) JobAPIGetJobExceptionsRequest {
	r.filterArchiveId = &filterArchiveId
	return r
}

// Filter by createdTimestamp query param.  **Format:** filter.createdTimestamp&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.createdTimestamp&#x3D;$btw:John Doe&amp;filter.createdTimestamp&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobExceptionsRequest) FilterCreatedTimestamp(filterCreatedTimestamp []string) JobAPIGetJobExceptionsRequest {
	r.filterCreatedTimestamp = &filterCreatedTimestamp
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;exceptionId:DESC&amp;sortBy&#x3D;createdTimestamp:DESC   **Default Value:** exceptionId:DESC  **Available Fields** - exceptionId  - createdTimestamp 
func (r JobAPIGetJobExceptionsRequest) SortBy(sortBy []string) JobAPIGetJobExceptionsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r JobAPIGetJobExceptionsRequest) Search(search string) JobAPIGetJobExceptionsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** exceptionId,archiveId,createdTimestamp   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - exceptionId  - archiveId  - createdTimestamp 
func (r JobAPIGetJobExceptionsRequest) SearchBy(searchBy []string) JobAPIGetJobExceptionsRequest {
	r.searchBy = &searchBy
	return r
}

func (r JobAPIGetJobExceptionsRequest) Execute() (*JobExceptionPaginatedList, *http.Response, error) {
	return r.ApiService.GetJobExceptionsExecute(r)
}

/*
GetJobExceptions Get a list of Job Exceptions

Returns a list of Job Exceptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return JobAPIGetJobExceptionsRequest
*/
func (a *JobAPIService) GetJobExceptions(ctx context.Context, jobId float32) JobAPIGetJobExceptionsRequest {
	return JobAPIGetJobExceptionsRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return JobExceptionPaginatedList
func (a *JobAPIService) GetJobExceptionsExecute(r JobAPIGetJobExceptionsRequest) (*JobExceptionPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobExceptionPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobExceptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/{jobId}/exceptions"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterExceptionId != nil {
		t := *r.filterExceptionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.exceptionId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.exceptionId", t, "form", "multi")
		}
	}
	if r.filterArchiveId != nil {
		t := *r.filterArchiveId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.archiveId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.archiveId", t, "form", "multi")
		}
	}
	if r.filterCreatedTimestamp != nil {
		t := *r.filterCreatedTimestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdTimestamp", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdTimestamp", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobFromArchiveRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId float32
}

func (r JobAPIGetJobFromArchiveRequest) Execute() (*JobArchive, *http.Response, error) {
	return r.ApiService.GetJobFromArchiveExecute(r)
}

/*
GetJobFromArchive Get Job from archive information

Returns Job from archive information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return JobAPIGetJobFromArchiveRequest
*/
func (a *JobAPIService) GetJobFromArchive(ctx context.Context, jobId float32) JobAPIGetJobFromArchiveRequest {
	return JobAPIGetJobFromArchiveRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return JobArchive
func (a *JobAPIService) GetJobFromArchiveExecute(r JobAPIGetJobFromArchiveRequest) (*JobArchive, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobArchive
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobFromArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/archive/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobGroupRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobGroupId float32
}

func (r JobAPIGetJobGroupRequest) Execute() (*JobGroup, *http.Response, error) {
	return r.ApiService.GetJobGroupExecute(r)
}

/*
GetJobGroup Get Job Group information

Returns Group information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobGroupId
 @return JobAPIGetJobGroupRequest
*/
func (a *JobAPIService) GetJobGroup(ctx context.Context, jobGroupId float32) JobAPIGetJobGroupRequest {
	return JobAPIGetJobGroupRequest{
		ApiService: a,
		ctx: ctx,
		jobGroupId: jobGroupId,
	}
}

// Execute executes the request
//  @return JobGroup
func (a *JobAPIService) GetJobGroupExecute(r JobAPIGetJobGroupRequest) (*JobGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job-groups/{jobGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobGroupId"+"}", url.PathEscape(parameterValueToString(r.jobGroupId, "jobGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobGroupStatisticsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobGroupId float32
}

func (r JobAPIGetJobGroupStatisticsRequest) Execute() (*JobGroupStatistics, *http.Response, error) {
	return r.ApiService.GetJobGroupStatisticsExecute(r)
}

/*
GetJobGroupStatistics Get Job Group statistics

Returns Group statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobGroupId
 @return JobAPIGetJobGroupStatisticsRequest
*/
func (a *JobAPIService) GetJobGroupStatistics(ctx context.Context, jobGroupId float32) JobAPIGetJobGroupStatisticsRequest {
	return JobAPIGetJobGroupStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		jobGroupId: jobGroupId,
	}
}

// Execute executes the request
//  @return JobGroupStatistics
func (a *JobAPIService) GetJobGroupStatisticsExecute(r JobAPIGetJobGroupStatisticsRequest) (*JobGroupStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobGroupStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobGroupStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job-groups/{jobGroupId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"jobGroupId"+"}", url.PathEscape(parameterValueToString(r.jobGroupId, "jobGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobGroupsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterType *[]string
	filterCreatedTimestamp *[]string
	filterFinishedTimestamp *[]string
	filterServerId *[]string
	filterDriveId *[]string
	filterInfrastructureId *[]string
	filterVmPoolId *[]string
	filterStorageId *[]string
	filterNetworkDeviceId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r JobAPIGetJobGroupsRequest) Page(page float32) JobAPIGetJobGroupsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r JobAPIGetJobGroupsRequest) Limit(limit float32) JobAPIGetJobGroupsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterId(filterId []string) JobAPIGetJobGroupsRequest {
	r.filterId = &filterId
	return r
}

// Filter by type query param.  **Format:** filter.type&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.type&#x3D;$btw:John Doe&amp;filter.type&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterType(filterType []string) JobAPIGetJobGroupsRequest {
	r.filterType = &filterType
	return r
}

// Filter by createdTimestamp query param.  **Format:** filter.createdTimestamp&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.createdTimestamp&#x3D;$btw:John Doe&amp;filter.createdTimestamp&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterCreatedTimestamp(filterCreatedTimestamp []string) JobAPIGetJobGroupsRequest {
	r.filterCreatedTimestamp = &filterCreatedTimestamp
	return r
}

// Filter by finishedTimestamp query param.  **Format:** filter.finishedTimestamp&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.finishedTimestamp&#x3D;$btw:John Doe&amp;filter.finishedTimestamp&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterFinishedTimestamp(filterFinishedTimestamp []string) JobAPIGetJobGroupsRequest {
	r.filterFinishedTimestamp = &filterFinishedTimestamp
	return r
}

// Filter by serverId query param.  **Format:** filter.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serverId&#x3D;$btw:John Doe&amp;filter.serverId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterServerId(filterServerId []string) JobAPIGetJobGroupsRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by driveId query param.  **Format:** filter.driveId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.driveId&#x3D;$btw:John Doe&amp;filter.driveId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterDriveId(filterDriveId []string) JobAPIGetJobGroupsRequest {
	r.filterDriveId = &filterDriveId
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$btw:John Doe&amp;filter.infrastructureId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterInfrastructureId(filterInfrastructureId []string) JobAPIGetJobGroupsRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by vmPoolId query param.  **Format:** filter.vmPoolId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.vmPoolId&#x3D;$btw:John Doe&amp;filter.vmPoolId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterVmPoolId(filterVmPoolId []string) JobAPIGetJobGroupsRequest {
	r.filterVmPoolId = &filterVmPoolId
	return r
}

// Filter by storageId query param.  **Format:** filter.storageId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.storageId&#x3D;$btw:John Doe&amp;filter.storageId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterStorageId(filterStorageId []string) JobAPIGetJobGroupsRequest {
	r.filterStorageId = &filterStorageId
	return r
}

// Filter by networkDeviceId query param.  **Format:** filter.networkDeviceId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.networkDeviceId&#x3D;$btw:John Doe&amp;filter.networkDeviceId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobGroupsRequest) FilterNetworkDeviceId(filterNetworkDeviceId []string) JobAPIGetJobGroupsRequest {
	r.filterNetworkDeviceId = &filterNetworkDeviceId
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdTimestamp:DESC   **Default Value:** id:DESC  **Available Fields** - id  - createdTimestamp  - finishedTimestamp 
func (r JobAPIGetJobGroupsRequest) SortBy(sortBy []string) JobAPIGetJobGroupsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r JobAPIGetJobGroupsRequest) Search(search string) JobAPIGetJobGroupsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,type,serverId,driveId,infrastructureId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - type  - serverId  - driveId  - infrastructureId  - vmPoolId  - storageId  - networkDeviceId  - createdTimestamp  - finishedTimestamp 
func (r JobAPIGetJobGroupsRequest) SearchBy(searchBy []string) JobAPIGetJobGroupsRequest {
	r.searchBy = &searchBy
	return r
}

func (r JobAPIGetJobGroupsRequest) Execute() (*JobGroupPaginatedList, *http.Response, error) {
	return r.ApiService.GetJobGroupsExecute(r)
}

/*
GetJobGroups Get a list of Job Groups

Returns a list of Job Groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPIGetJobGroupsRequest
*/
func (a *JobAPIService) GetJobGroups(ctx context.Context) JobAPIGetJobGroupsRequest {
	return JobAPIGetJobGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobGroupPaginatedList
func (a *JobAPIService) GetJobGroupsExecute(r JobAPIGetJobGroupsRequest) (*JobGroupPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobGroupPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/job-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterType != nil {
		t := *r.filterType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.type", t, "form", "multi")
		}
	}
	if r.filterCreatedTimestamp != nil {
		t := *r.filterCreatedTimestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdTimestamp", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdTimestamp", t, "form", "multi")
		}
	}
	if r.filterFinishedTimestamp != nil {
		t := *r.filterFinishedTimestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.finishedTimestamp", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.finishedTimestamp", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterDriveId != nil {
		t := *r.filterDriveId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.driveId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.driveId", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterVmPoolId != nil {
		t := *r.filterVmPoolId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vmPoolId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vmPoolId", t, "form", "multi")
		}
	}
	if r.filterStorageId != nil {
		t := *r.filterStorageId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storageId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storageId", t, "form", "multi")
		}
	}
	if r.filterNetworkDeviceId != nil {
		t := *r.filterNetworkDeviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.networkDeviceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.networkDeviceId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	page *float32
	limit *float32
	filterJobId *[]string
	filterInfrastructureId *[]string
	filterServerId *[]string
	filterVmPoolId *[]string
	filterStorageId *[]string
	filterNetworkDeviceId *[]string
	filterJobGroupId *[]string
	filterInstanceId *[]string
	filterFunctionName *[]string
	filterSiteId *[]string
	filterJobIdBlocked *[]string
	filterJobIdBlockedBy *[]string
	filterStatus *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r JobAPIGetJobsRequest) Page(page float32) JobAPIGetJobsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r JobAPIGetJobsRequest) Limit(limit float32) JobAPIGetJobsRequest {
	r.limit = &limit
	return r
}

// Filter by jobId query param.  **Format:** filter.jobId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobId&#x3D;$btw:John Doe&amp;filter.jobId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterJobId(filterJobId []string) JobAPIGetJobsRequest {
	r.filterJobId = &filterJobId
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$btw:John Doe&amp;filter.infrastructureId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterInfrastructureId(filterInfrastructureId []string) JobAPIGetJobsRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serverId query param.  **Format:** filter.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serverId&#x3D;$btw:John Doe&amp;filter.serverId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterServerId(filterServerId []string) JobAPIGetJobsRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by vmPoolId query param.  **Format:** filter.vmPoolId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.vmPoolId&#x3D;$btw:John Doe&amp;filter.vmPoolId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterVmPoolId(filterVmPoolId []string) JobAPIGetJobsRequest {
	r.filterVmPoolId = &filterVmPoolId
	return r
}

// Filter by storageId query param.  **Format:** filter.storageId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.storageId&#x3D;$btw:John Doe&amp;filter.storageId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterStorageId(filterStorageId []string) JobAPIGetJobsRequest {
	r.filterStorageId = &filterStorageId
	return r
}

// Filter by networkDeviceId query param.  **Format:** filter.networkDeviceId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.networkDeviceId&#x3D;$btw:John Doe&amp;filter.networkDeviceId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterNetworkDeviceId(filterNetworkDeviceId []string) JobAPIGetJobsRequest {
	r.filterNetworkDeviceId = &filterNetworkDeviceId
	return r
}

// Filter by jobGroupId query param.  **Format:** filter.jobGroupId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobGroupId&#x3D;$btw:John Doe&amp;filter.jobGroupId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterJobGroupId(filterJobGroupId []string) JobAPIGetJobsRequest {
	r.filterJobGroupId = &filterJobGroupId
	return r
}

// Filter by instanceId query param.  **Format:** filter.instanceId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.instanceId&#x3D;$btw:John Doe&amp;filter.instanceId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterInstanceId(filterInstanceId []string) JobAPIGetJobsRequest {
	r.filterInstanceId = &filterInstanceId
	return r
}

// Filter by functionName query param.  **Format:** filter.functionName&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.functionName&#x3D;$btw:John Doe&amp;filter.functionName&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterFunctionName(filterFunctionName []string) JobAPIGetJobsRequest {
	r.filterFunctionName = &filterFunctionName
	return r
}

// Filter by siteId query param.  **Format:** filter.siteId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.siteId&#x3D;$btw:John Doe&amp;filter.siteId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterSiteId(filterSiteId []string) JobAPIGetJobsRequest {
	r.filterSiteId = &filterSiteId
	return r
}

// Filter by jobIdBlocked query param.  **Format:** filter.jobIdBlocked&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobIdBlocked&#x3D;$btw:John Doe&amp;filter.jobIdBlocked&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterJobIdBlocked(filterJobIdBlocked []string) JobAPIGetJobsRequest {
	r.filterJobIdBlocked = &filterJobIdBlocked
	return r
}

// Filter by jobIdBlockedBy query param.  **Format:** filter.jobIdBlockedBy&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobIdBlockedBy&#x3D;$btw:John Doe&amp;filter.jobIdBlockedBy&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterJobIdBlockedBy(filterJobIdBlockedBy []string) JobAPIGetJobsRequest {
	r.filterJobIdBlockedBy = &filterJobIdBlockedBy
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsRequest) FilterStatus(filterStatus []string) JobAPIGetJobsRequest {
	r.filterStatus = &filterStatus
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;jobId:DESC&amp;sortBy&#x3D;jobGroupId:DESC   **Default Value:** jobId:DESC  **Available Fields** - jobId  - jobGroupId  - status  - createdTimestamp 
func (r JobAPIGetJobsRequest) SortBy(sortBy []string) JobAPIGetJobsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r JobAPIGetJobsRequest) Search(search string) JobAPIGetJobsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** jobId,infrastructureId,serverId,vmPoolId,storageId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - jobId  - infrastructureId  - serverId  - vmPoolId  - storageId  - networkDeviceId  - jobGroupId  - functionName  - siteId  - instanceId  - jobIdBlocked  - jobIdBlockedBy  - status 
func (r JobAPIGetJobsRequest) SearchBy(searchBy []string) JobAPIGetJobsRequest {
	r.searchBy = &searchBy
	return r
}

func (r JobAPIGetJobsRequest) Execute() (*JobPaginatedList, *http.Response, error) {
	return r.ApiService.GetJobsExecute(r)
}

/*
GetJobs Get a list of Jobs

Returns a list of Jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPIGetJobsRequest
*/
func (a *JobAPIService) GetJobs(ctx context.Context) JobAPIGetJobsRequest {
	return JobAPIGetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobPaginatedList
func (a *JobAPIService) GetJobsExecute(r JobAPIGetJobsRequest) (*JobPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterJobId != nil {
		t := *r.filterJobId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobId", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterVmPoolId != nil {
		t := *r.filterVmPoolId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vmPoolId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vmPoolId", t, "form", "multi")
		}
	}
	if r.filterStorageId != nil {
		t := *r.filterStorageId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storageId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storageId", t, "form", "multi")
		}
	}
	if r.filterNetworkDeviceId != nil {
		t := *r.filterNetworkDeviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.networkDeviceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.networkDeviceId", t, "form", "multi")
		}
	}
	if r.filterJobGroupId != nil {
		t := *r.filterJobGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobGroupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobGroupId", t, "form", "multi")
		}
	}
	if r.filterInstanceId != nil {
		t := *r.filterInstanceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.instanceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.instanceId", t, "form", "multi")
		}
	}
	if r.filterFunctionName != nil {
		t := *r.filterFunctionName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.functionName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.functionName", t, "form", "multi")
		}
	}
	if r.filterSiteId != nil {
		t := *r.filterSiteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", t, "form", "multi")
		}
	}
	if r.filterJobIdBlocked != nil {
		t := *r.filterJobIdBlocked
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlocked", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlocked", t, "form", "multi")
		}
	}
	if r.filterJobIdBlockedBy != nil {
		t := *r.filterJobIdBlockedBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlockedBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlockedBy", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobsFromArchiveRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	page *float32
	limit *float32
	filterJobId *[]string
	filterInfrastructureId *[]string
	filterServerId *[]string
	filterVmPoolId *[]string
	filterStorageId *[]string
	filterNetworkDeviceId *[]string
	filterJobGroupId *[]string
	filterInstanceId *[]string
	filterFunctionName *[]string
	filterSiteId *[]string
	filterJobIdBlocked *[]string
	filterJobIdBlockedBy *[]string
	filterStatus *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r JobAPIGetJobsFromArchiveRequest) Page(page float32) JobAPIGetJobsFromArchiveRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r JobAPIGetJobsFromArchiveRequest) Limit(limit float32) JobAPIGetJobsFromArchiveRequest {
	r.limit = &limit
	return r
}

// Filter by jobId query param.  **Format:** filter.jobId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobId&#x3D;$btw:John Doe&amp;filter.jobId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterJobId(filterJobId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterJobId = &filterJobId
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$btw:John Doe&amp;filter.infrastructureId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterInfrastructureId(filterInfrastructureId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serverId query param.  **Format:** filter.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serverId&#x3D;$btw:John Doe&amp;filter.serverId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterServerId(filterServerId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by vmPoolId query param.  **Format:** filter.vmPoolId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.vmPoolId&#x3D;$btw:John Doe&amp;filter.vmPoolId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterVmPoolId(filterVmPoolId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterVmPoolId = &filterVmPoolId
	return r
}

// Filter by storageId query param.  **Format:** filter.storageId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.storageId&#x3D;$btw:John Doe&amp;filter.storageId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterStorageId(filterStorageId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterStorageId = &filterStorageId
	return r
}

// Filter by networkDeviceId query param.  **Format:** filter.networkDeviceId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.networkDeviceId&#x3D;$btw:John Doe&amp;filter.networkDeviceId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterNetworkDeviceId(filterNetworkDeviceId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterNetworkDeviceId = &filterNetworkDeviceId
	return r
}

// Filter by jobGroupId query param.  **Format:** filter.jobGroupId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobGroupId&#x3D;$btw:John Doe&amp;filter.jobGroupId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterJobGroupId(filterJobGroupId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterJobGroupId = &filterJobGroupId
	return r
}

// Filter by instanceId query param.  **Format:** filter.instanceId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.instanceId&#x3D;$btw:John Doe&amp;filter.instanceId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterInstanceId(filterInstanceId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterInstanceId = &filterInstanceId
	return r
}

// Filter by functionName query param.  **Format:** filter.functionName&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.functionName&#x3D;$btw:John Doe&amp;filter.functionName&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterFunctionName(filterFunctionName []string) JobAPIGetJobsFromArchiveRequest {
	r.filterFunctionName = &filterFunctionName
	return r
}

// Filter by siteId query param.  **Format:** filter.siteId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.siteId&#x3D;$btw:John Doe&amp;filter.siteId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterSiteId(filterSiteId []string) JobAPIGetJobsFromArchiveRequest {
	r.filterSiteId = &filterSiteId
	return r
}

// Filter by jobIdBlocked query param.  **Format:** filter.jobIdBlocked&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobIdBlocked&#x3D;$btw:John Doe&amp;filter.jobIdBlocked&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterJobIdBlocked(filterJobIdBlocked []string) JobAPIGetJobsFromArchiveRequest {
	r.filterJobIdBlocked = &filterJobIdBlocked
	return r
}

// Filter by jobIdBlockedBy query param.  **Format:** filter.jobIdBlockedBy&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.jobIdBlockedBy&#x3D;$btw:John Doe&amp;filter.jobIdBlockedBy&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterJobIdBlockedBy(filterJobIdBlockedBy []string) JobAPIGetJobsFromArchiveRequest {
	r.filterJobIdBlockedBy = &filterJobIdBlockedBy
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r JobAPIGetJobsFromArchiveRequest) FilterStatus(filterStatus []string) JobAPIGetJobsFromArchiveRequest {
	r.filterStatus = &filterStatus
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;jobId:DESC&amp;sortBy&#x3D;jobGroupId:DESC   **Default Value:** jobId:DESC  **Available Fields** - jobId  - jobGroupId  - status  - createdTimestamp 
func (r JobAPIGetJobsFromArchiveRequest) SortBy(sortBy []string) JobAPIGetJobsFromArchiveRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r JobAPIGetJobsFromArchiveRequest) Search(search string) JobAPIGetJobsFromArchiveRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** jobId,infrastructureId,serverId,vmPoolId,storageId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - jobId  - infrastructureId  - serverId  - vmPoolId  - storageId  - networkDeviceId  - jobGroupId  - functionName  - siteId  - instanceId  - jobIdBlocked  - jobIdBlockedBy  - status 
func (r JobAPIGetJobsFromArchiveRequest) SearchBy(searchBy []string) JobAPIGetJobsFromArchiveRequest {
	r.searchBy = &searchBy
	return r
}

func (r JobAPIGetJobsFromArchiveRequest) Execute() (*JobArchivePaginatedList, *http.Response, error) {
	return r.ApiService.GetJobsFromArchiveExecute(r)
}

/*
GetJobsFromArchive Get a list of Jobs from archive

Returns a list of Jobs from archive

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPIGetJobsFromArchiveRequest
*/
func (a *JobAPIService) GetJobsFromArchive(ctx context.Context) JobAPIGetJobsFromArchiveRequest {
	return JobAPIGetJobsFromArchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobArchivePaginatedList
func (a *JobAPIService) GetJobsFromArchiveExecute(r JobAPIGetJobsFromArchiveRequest) (*JobArchivePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobArchivePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobsFromArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterJobId != nil {
		t := *r.filterJobId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobId", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterVmPoolId != nil {
		t := *r.filterVmPoolId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vmPoolId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vmPoolId", t, "form", "multi")
		}
	}
	if r.filterStorageId != nil {
		t := *r.filterStorageId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storageId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storageId", t, "form", "multi")
		}
	}
	if r.filterNetworkDeviceId != nil {
		t := *r.filterNetworkDeviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.networkDeviceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.networkDeviceId", t, "form", "multi")
		}
	}
	if r.filterJobGroupId != nil {
		t := *r.filterJobGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobGroupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobGroupId", t, "form", "multi")
		}
	}
	if r.filterInstanceId != nil {
		t := *r.filterInstanceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.instanceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.instanceId", t, "form", "multi")
		}
	}
	if r.filterFunctionName != nil {
		t := *r.filterFunctionName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.functionName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.functionName", t, "form", "multi")
		}
	}
	if r.filterSiteId != nil {
		t := *r.filterSiteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", t, "form", "multi")
		}
	}
	if r.filterJobIdBlocked != nil {
		t := *r.filterJobIdBlocked
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlocked", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlocked", t, "form", "multi")
		}
	}
	if r.filterJobIdBlockedBy != nil {
		t := *r.filterJobIdBlockedBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlockedBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.jobIdBlockedBy", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIGetJobsStatisticsRequest struct {
	ctx context.Context
	ApiService *JobAPIService
}

func (r JobAPIGetJobsStatisticsRequest) Execute() (*JobStatistics, *http.Response, error) {
	return r.ApiService.GetJobsStatisticsExecute(r)
}

/*
GetJobsStatistics Get Jobs statistics

Returns Jobs statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return JobAPIGetJobsStatisticsRequest
*/
func (a *JobAPIService) GetJobsStatistics(ctx context.Context) JobAPIGetJobsStatisticsRequest {
	return JobAPIGetJobsStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobStatistics
func (a *JobAPIService) GetJobsStatisticsExecute(r JobAPIGetJobsStatisticsRequest) (*JobStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.GetJobsStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type JobAPIIssueCommandForJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId float32
	jobCommandInfo *JobCommandInfo
}

// The job retry options
func (r JobAPIIssueCommandForJobRequest) JobCommandInfo(jobCommandInfo JobCommandInfo) JobAPIIssueCommandForJobRequest {
	r.jobCommandInfo = &jobCommandInfo
	return r
}

func (r JobAPIIssueCommandForJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.IssueCommandForJobExecute(r)
}

/*
IssueCommandForJob Issues a command for a job that changes the operational state of the job

Issues a command for a job that changes the operational state of the job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return JobAPIIssueCommandForJobRequest
*/
func (a *JobAPIService) IssueCommandForJob(ctx context.Context, jobId float32) JobAPIIssueCommandForJobRequest {
	return JobAPIIssueCommandForJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *JobAPIService) IssueCommandForJobExecute(r JobAPIIssueCommandForJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.IssueCommandForJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/{jobId}/actions/issue-command"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobCommandInfo == nil {
		return nil, reportError("jobCommandInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobCommandInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JobAPIRetryJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId float32
	jobRetryInfo *JobRetryInfo
}

// The job retry options
func (r JobAPIRetryJobRequest) JobRetryInfo(jobRetryInfo JobRetryInfo) JobAPIRetryJobRequest {
	r.jobRetryInfo = &jobRetryInfo
	return r
}

func (r JobAPIRetryJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.RetryJobExecute(r)
}

/*
RetryJob Retries a job

Retries a job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return JobAPIRetryJobRequest
*/
func (a *JobAPIService) RetryJob(ctx context.Context, jobId float32) JobAPIRetryJobRequest {
	return JobAPIRetryJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *JobAPIService) RetryJobExecute(r JobAPIRetryJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.RetryJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/{jobId}/actions/retry"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobRetryInfo == nil {
		return nil, reportError("jobRetryInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobRetryInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JobAPISkipJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	jobId float32
}

func (r JobAPISkipJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.SkipJobExecute(r)
}

/*
SkipJob Skips a job

Skips a job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return JobAPISkipJobRequest
*/
func (a *JobAPIService) SkipJob(ctx context.Context, jobId float32) JobAPISkipJobRequest {
	return JobAPISkipJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *JobAPIService) SkipJobExecute(r JobAPISkipJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.SkipJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/jobs/{jobId}/actions/skip"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type JobAPIUpdateCronJobRequest struct {
	ctx context.Context
	ApiService *JobAPIService
	cronJobId float32
	updateCronJob *UpdateCronJob
}

// The cron job details
func (r JobAPIUpdateCronJobRequest) UpdateCronJob(updateCronJob UpdateCronJob) JobAPIUpdateCronJobRequest {
	r.updateCronJob = &updateCronJob
	return r
}

func (r JobAPIUpdateCronJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCronJobExecute(r)
}

/*
UpdateCronJob Updates an existing cron job

Updates an existing cron job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cronJobId
 @return JobAPIUpdateCronJobRequest
*/
func (a *JobAPIService) UpdateCronJob(ctx context.Context, cronJobId float32) JobAPIUpdateCronJobRequest {
	return JobAPIUpdateCronJobRequest{
		ApiService: a,
		ctx: ctx,
		cronJobId: cronJobId,
	}
}

// Execute executes the request
func (a *JobAPIService) UpdateCronJobExecute(r JobAPIUpdateCronJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobAPIService.UpdateCronJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cron-jobs/{cronJobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cronJobId"+"}", url.PathEscape(parameterValueToString(r.cronJobId, "cronJobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCronJob == nil {
		return nil, reportError("updateCronJob is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCronJob
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
