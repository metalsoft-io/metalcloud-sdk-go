/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LogicalNetworkAPIService LogicalNetworkAPI service
type LogicalNetworkAPIService service

type LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	applyProfilesToLogicalNetworkConfig *ApplyProfilesToLogicalNetworkConfig
}

// Entity tag
func (r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) IfMatch(ifMatch string) LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) ApplyProfilesToLogicalNetworkConfig(applyProfilesToLogicalNetworkConfig ApplyProfilesToLogicalNetworkConfig) LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest {
	r.applyProfilesToLogicalNetworkConfig = &applyProfilesToLogicalNetworkConfig
	return r
}

func (r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) Execute() (*GetLogicalNetworkConfig200Response, *http.Response, error) {
	return r.ApiService.ApplyProfilesToLogicalNetworkConfigExecute(r)
}

/*
ApplyProfilesToLogicalNetworkConfig Apply profiles to Logical Network config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest
*/
func (a *LogicalNetworkAPIService) ApplyProfilesToLogicalNetworkConfig(ctx context.Context, id float32) LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest {
	return LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetLogicalNetworkConfig200Response
func (a *LogicalNetworkAPIService) ApplyProfilesToLogicalNetworkConfigExecute(r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) (*GetLogicalNetworkConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetLogicalNetworkConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ApplyProfilesToLogicalNetworkConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/actions/apply-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.applyProfilesToLogicalNetworkConfig == nil {
		return localVarReturnValue, nil, reportError("applyProfilesToLogicalNetworkConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.applyProfilesToLogicalNetworkConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	createLogicalNetworkRequest *CreateLogicalNetworkRequest
}

func (r LogicalNetworkAPICreateLogicalNetworkRequest) CreateLogicalNetworkRequest(createLogicalNetworkRequest CreateLogicalNetworkRequest) LogicalNetworkAPICreateLogicalNetworkRequest {
	r.createLogicalNetworkRequest = &createLogicalNetworkRequest
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkRequest) Execute() (*CreateLogicalNetwork201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkExecute(r)
}

/*
CreateLogicalNetwork Create a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkAPICreateLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetwork(ctx context.Context) LogicalNetworkAPICreateLogicalNetworkRequest {
	return LogicalNetworkAPICreateLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLogicalNetwork201Response
func (a *LogicalNetworkAPIService) CreateLogicalNetworkExecute(r LogicalNetworkAPICreateLogicalNetworkRequest) (*CreateLogicalNetwork201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetwork201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigIpv4SubnetAllocationStrategy Create Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigIpv6SubnetAllocationStrategy Create Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createLogicalNetworkProfileVlanAllocationStrategyRequest *CreateLogicalNetworkProfileVlanAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) CreateLogicalNetworkProfileVlanAllocationStrategyRequest(createLogicalNetworkProfileVlanAllocationStrategyRequest CreateLogicalNetworkProfileVlanAllocationStrategyRequest) LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.createLogicalNetworkProfileVlanAllocationStrategyRequest = &createLogicalNetworkProfileVlanAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigVlanAllocationStrategy Create Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVlanAllocationStrategy201Response
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVlanAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileVlanAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVlanAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVlanAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createLogicalNetworkProfileVniAllocationStrategyRequest *CreateLogicalNetworkProfileVniAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) CreateLogicalNetworkProfileVniAllocationStrategyRequest(createLogicalNetworkProfileVniAllocationStrategyRequest CreateLogicalNetworkProfileVniAllocationStrategyRequest) LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest {
	r.createLogicalNetworkProfileVniAllocationStrategyRequest = &createLogicalNetworkProfileVniAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigVniAllocationStrategy Create Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVniAllocationStrategy201Response
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVniAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileVniAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVniAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVniAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkFromProfileRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	createLogicalNetworkFromProfile *CreateLogicalNetworkFromProfile
}

func (r LogicalNetworkAPICreateLogicalNetworkFromProfileRequest) CreateLogicalNetworkFromProfile(createLogicalNetworkFromProfile CreateLogicalNetworkFromProfile) LogicalNetworkAPICreateLogicalNetworkFromProfileRequest {
	r.createLogicalNetworkFromProfile = &createLogicalNetworkFromProfile
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkFromProfileRequest) Execute() (*CreateLogicalNetwork201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkFromProfileExecute(r)
}

/*
CreateLogicalNetworkFromProfile Create a Logical Network from a profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkAPICreateLogicalNetworkFromProfileRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkFromProfile(ctx context.Context) LogicalNetworkAPICreateLogicalNetworkFromProfileRequest {
	return LogicalNetworkAPICreateLogicalNetworkFromProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLogicalNetwork201Response
func (a *LogicalNetworkAPIService) CreateLogicalNetworkFromProfileExecute(r LogicalNetworkAPICreateLogicalNetworkFromProfileRequest) (*CreateLogicalNetwork201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetwork201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkFromProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/actions/create-from-profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkFromProfile == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkFromProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkFromProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
}

func (r LogicalNetworkAPIDeleteLogicalNetworkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkExecute(r)
}

/*
DeleteLogicalNetwork Delete a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIDeleteLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetwork(ctx context.Context, id float32) LogicalNetworkAPIDeleteLogicalNetworkRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkExecute(r LogicalNetworkAPIDeleteLogicalNetworkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetwork")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategy Delete Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategy Delete Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigVlanAllocationStrategy Delete Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigVniAllocationStrategy Delete Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
}

func (r LogicalNetworkAPIGetLogicalNetworkRequest) Execute() (*CreateLogicalNetwork201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkExecute(r)
}

/*
GetLogicalNetwork Get a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetwork(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkRequest {
	return LogicalNetworkAPIGetLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetwork201Response
func (a *LogicalNetworkAPIService) GetLogicalNetworkExecute(r LogicalNetworkAPIGetLogicalNetworkRequest) (*CreateLogicalNetwork201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetwork201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigRequest) Execute() (*GetLogicalNetworkConfig200Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigExecute(r)
}

/*
GetLogicalNetworkConfig Get the config for a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfig(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetLogicalNetworkConfig200Response
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigExecute(r LogicalNetworkAPIGetLogicalNetworkConfigRequest) (*GetLogicalNetworkConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetLogicalNetworkConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) Execute() (*PaginatedIpv4SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigIpv4SubnetAllocationStrategies Get all Ipv4 Subnet allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIpv4SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) (*PaginatedIpv4SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIpv4SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigIpv4SubnetAllocationStrategy Get a Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) Execute() (*PaginatedIpv6SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigIpv6SubnetAllocationStrategies Get all Ipv6 Subnet allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIpv6SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) (*PaginatedIpv6SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIpv6SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigIpv6SubnetAllocationStrategy Get a Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) Execute() (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVlanAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigVlanAllocationStrategies Get all Vlan allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVlanAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVlanAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigVlanAllocationStrategy Get a Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVlanAllocationStrategy201Response
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest) (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVlanAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) Execute() (*PaginatedVniAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVniAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigVniAllocationStrategies Get all Vni allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVniAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) (*PaginatedVniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVniAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigVniAllocationStrategy Get a Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVniAllocationStrategy201Response
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest) (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVniAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworksRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	filterLabel *[]string
	filterName *[]string
	filterFabricId *[]string
	filterInfrastructureId *[]string
	filterServiceStatus *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkAPIGetLogicalNetworksRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 5000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkAPIGetLogicalNetworksRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterKind = &filterKind
	return r
}

// Filter by label query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.label&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.label&#x3D;$not:$like:John Doe&amp;filter.label&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterLabel(filterLabel []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.name&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.name&#x3D;$not:$like:John Doe&amp;filter.name&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterName(filterName []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterName = &filterName
	return r
}

// Filter by fabricId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fabricId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fabricId&#x3D;$not:$like:John Doe&amp;filter.fabricId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterFabricId(filterFabricId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterFabricId = &filterFabricId
	return r
}

// Filter by infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterInfrastructureId(filterInfrastructureId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serviceStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serviceStatus&#x3D;$not:$like:John Doe&amp;filter.serviceStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterServiceStatus(filterServiceStatus []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkAPIGetLogicalNetworksRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r LogicalNetworkAPIGetLogicalNetworksRequest) Search(search string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,label,name           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt; &lt;li&gt;name&lt;/li&gt;&lt;/ul&gt;         
func (r LogicalNetworkAPIGetLogicalNetworksRequest) SearchBy(searchBy []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworksRequest) Execute() (*PaginatedLogicalNetwork, *http.Response, error) {
	return r.ApiService.GetLogicalNetworksExecute(r)
}

/*
GetLogicalNetworks Get all Logical Networks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkAPIGetLogicalNetworksRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworks(ctx context.Context) LogicalNetworkAPIGetLogicalNetworksRequest {
	return LogicalNetworkAPIGetLogicalNetworksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedLogicalNetwork
func (a *LogicalNetworkAPIService) GetLogicalNetworksExecute(r LogicalNetworkAPIGetLogicalNetworksRequest) (*PaginatedLogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterFabricId != nil {
		t := *r.filterFabricId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategy Replace Ipv4 Subnet allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategy Replace Ipv6 Subnet allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createLogicalNetworkProfileVlanAllocationStrategyRequest *CreateLogicalNetworkProfileVlanAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) CreateLogicalNetworkProfileVlanAllocationStrategyRequest(createLogicalNetworkProfileVlanAllocationStrategyRequest CreateLogicalNetworkProfileVlanAllocationStrategyRequest) LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.createLogicalNetworkProfileVlanAllocationStrategyRequest = &createLogicalNetworkProfileVlanAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigVlanAllocationStrategy Replace Vlan allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVlanAllocationStrategy201Response
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVlanAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileVlanAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVlanAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVlanAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createLogicalNetworkProfileVniAllocationStrategyRequest *CreateLogicalNetworkProfileVniAllocationStrategyRequest
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) CreateLogicalNetworkProfileVniAllocationStrategyRequest(createLogicalNetworkProfileVniAllocationStrategyRequest CreateLogicalNetworkProfileVniAllocationStrategyRequest) LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest {
	r.createLogicalNetworkProfileVniAllocationStrategyRequest = &createLogicalNetworkProfileVniAllocationStrategyRequest
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigVniAllocationStrategy Replace Vni allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVniAllocationStrategy201Response
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVniAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createLogicalNetworkProfileVniAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVniAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVniAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIUpdateLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	updateLogicalNetwork *UpdateLogicalNetwork
}

// Entity tag
func (r LogicalNetworkAPIUpdateLogicalNetworkRequest) IfMatch(ifMatch string) LogicalNetworkAPIUpdateLogicalNetworkRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkRequest) UpdateLogicalNetwork(updateLogicalNetwork UpdateLogicalNetwork) LogicalNetworkAPIUpdateLogicalNetworkRequest {
	r.updateLogicalNetwork = &updateLogicalNetwork
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkRequest) Execute() (*CreateLogicalNetwork201Response, *http.Response, error) {
	return r.ApiService.UpdateLogicalNetworkExecute(r)
}

/*
UpdateLogicalNetwork Update Logical Network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIUpdateLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) UpdateLogicalNetwork(ctx context.Context, id float32) LogicalNetworkAPIUpdateLogicalNetworkRequest {
	return LogicalNetworkAPIUpdateLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetwork201Response
func (a *LogicalNetworkAPIService) UpdateLogicalNetworkExecute(r LogicalNetworkAPIUpdateLogicalNetworkRequest) (*CreateLogicalNetwork201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetwork201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.UpdateLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.updateLogicalNetwork == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.updateLogicalNetwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIUpdateLogicalNetworkConfigRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	updateLogicalNetworkConfig *UpdateLogicalNetworkConfig
}

// Entity tag
func (r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) IfMatch(ifMatch string) LogicalNetworkAPIUpdateLogicalNetworkConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) UpdateLogicalNetworkConfig(updateLogicalNetworkConfig UpdateLogicalNetworkConfig) LogicalNetworkAPIUpdateLogicalNetworkConfigRequest {
	r.updateLogicalNetworkConfig = &updateLogicalNetworkConfig
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) Execute() (*GetLogicalNetworkConfig200Response, *http.Response, error) {
	return r.ApiService.UpdateLogicalNetworkConfigExecute(r)
}

/*
UpdateLogicalNetworkConfig Update Logical Network config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIUpdateLogicalNetworkConfigRequest
*/
func (a *LogicalNetworkAPIService) UpdateLogicalNetworkConfig(ctx context.Context, id float32) LogicalNetworkAPIUpdateLogicalNetworkConfigRequest {
	return LogicalNetworkAPIUpdateLogicalNetworkConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetLogicalNetworkConfig200Response
func (a *LogicalNetworkAPIService) UpdateLogicalNetworkConfigExecute(r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) (*GetLogicalNetworkConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetLogicalNetworkConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.UpdateLogicalNetworkConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.updateLogicalNetworkConfig == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetworkConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.updateLogicalNetworkConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
