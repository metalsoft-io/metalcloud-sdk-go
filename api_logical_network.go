/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LogicalNetworkAPIService LogicalNetworkAPI service
type LogicalNetworkAPIService service

type LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	applyProfilesToLogicalNetworkConfig *ApplyProfilesToLogicalNetworkConfig
}

// Entity tag
func (r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) IfMatch(ifMatch string) LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) ApplyProfilesToLogicalNetworkConfig(applyProfilesToLogicalNetworkConfig ApplyProfilesToLogicalNetworkConfig) LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest {
	r.applyProfilesToLogicalNetworkConfig = &applyProfilesToLogicalNetworkConfig
	return r
}

func (r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) Execute() (*LogicalNetworkConfig, *http.Response, error) {
	return r.ApiService.ApplyProfilesToLogicalNetworkConfigExecute(r)
}

/*
ApplyProfilesToLogicalNetworkConfig Apply profiles to Logical Network config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest
*/
func (a *LogicalNetworkAPIService) ApplyProfilesToLogicalNetworkConfig(ctx context.Context, id float32) LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest {
	return LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkConfig
func (a *LogicalNetworkAPIService) ApplyProfilesToLogicalNetworkConfigExecute(r LogicalNetworkAPIApplyProfilesToLogicalNetworkConfigRequest) (*LogicalNetworkConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ApplyProfilesToLogicalNetworkConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/actions/apply-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.applyProfilesToLogicalNetworkConfig == nil {
		return localVarReturnValue, nil, reportError("applyProfilesToLogicalNetworkConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.applyProfilesToLogicalNetworkConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	createLogicalNetwork *CreateLogicalNetwork
}

// The logical network to create
func (r LogicalNetworkAPICreateLogicalNetworkRequest) CreateLogicalNetwork(createLogicalNetwork CreateLogicalNetwork) LogicalNetworkAPICreateLogicalNetworkRequest {
	r.createLogicalNetwork = &createLogicalNetwork
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkRequest) Execute() (*LogicalNetwork, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkExecute(r)
}

/*
CreateLogicalNetwork Create a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkAPICreateLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetwork(ctx context.Context) LogicalNetworkAPICreateLogicalNetworkRequest {
	return LogicalNetworkAPICreateLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogicalNetwork
func (a *LogicalNetworkAPIService) CreateLogicalNetworkExecute(r LogicalNetworkAPICreateLogicalNetworkRequest) (*LogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetwork == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createIpv4SubnetAllocationStrategy *CreateIpv4SubnetAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) CreateIpv4SubnetAllocationStrategy(createIpv4SubnetAllocationStrategy CreateIpv4SubnetAllocationStrategy) LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.createIpv4SubnetAllocationStrategy = &createIpv4SubnetAllocationStrategy
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*Ipv4SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigIpv4SubnetAllocationStrategy Create Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ipv4SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*Ipv4SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ipv4SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createIpv4SubnetAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createIpv4SubnetAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createIpv4SubnetAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createIpv6SubnetAllocationStrategy *CreateIpv6SubnetAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) CreateIpv6SubnetAllocationStrategy(createIpv6SubnetAllocationStrategy CreateIpv6SubnetAllocationStrategy) LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.createIpv6SubnetAllocationStrategy = &createIpv6SubnetAllocationStrategy
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*Ipv6SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigIpv6SubnetAllocationStrategy Create Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Ipv6SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*Ipv6SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ipv6SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createIpv6SubnetAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createIpv6SubnetAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createIpv6SubnetAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createPkeyAllocationStrategy *CreatePkeyAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest) CreatePkeyAllocationStrategy(createPkeyAllocationStrategy CreatePkeyAllocationStrategy) LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest {
	r.createPkeyAllocationStrategy = &createPkeyAllocationStrategy
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest) Execute() (*PkeyAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigPkeyAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigPkeyAllocationStrategy Create Pkey allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigPkeyAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PkeyAllocationStrategy
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigPkeyAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigPkeyAllocationStrategyRequest) (*PkeyAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PkeyAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigPkeyAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/pkey/pkey-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createPkeyAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createPkeyAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createPkeyAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createVlanAllocationStrategy *CreateVlanAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) CreateVlanAllocationStrategy(createVlanAllocationStrategy CreateVlanAllocationStrategy) LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.createVlanAllocationStrategy = &createVlanAllocationStrategy
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*VlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigVlanAllocationStrategy Create Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VlanAllocationStrategy
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigVlanAllocationStrategyRequest) (*VlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVlanAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVlanAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVlanAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createVniAllocationStrategy *CreateVniAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) CreateVniAllocationStrategy(createVniAllocationStrategy CreateVniAllocationStrategy) LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest {
	r.createVniAllocationStrategy = &createVniAllocationStrategy
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*VniAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigVniAllocationStrategy Create Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VniAllocationStrategy
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigVniAllocationStrategyRequest) (*VniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVniAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVniAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVniAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	createZoneAllocationStrategy *CreateZoneAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest) CreateZoneAllocationStrategy(createZoneAllocationStrategy CreateZoneAllocationStrategy) LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest {
	r.createZoneAllocationStrategy = &createZoneAllocationStrategy
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest) Execute() (*ZoneAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkConfigZoneAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkConfigZoneAllocationStrategy Create Zone allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigZoneAllocationStrategy(ctx context.Context, id float32) LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest {
	return LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ZoneAllocationStrategy
func (a *LogicalNetworkAPIService) CreateLogicalNetworkConfigZoneAllocationStrategyExecute(r LogicalNetworkAPICreateLogicalNetworkConfigZoneAllocationStrategyRequest) (*ZoneAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkConfigZoneAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/zone/zone-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createZoneAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createZoneAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createZoneAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPICreateLogicalNetworkFromProfileRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	createLogicalNetworkFromProfile *CreateLogicalNetworkFromProfile
}

func (r LogicalNetworkAPICreateLogicalNetworkFromProfileRequest) CreateLogicalNetworkFromProfile(createLogicalNetworkFromProfile CreateLogicalNetworkFromProfile) LogicalNetworkAPICreateLogicalNetworkFromProfileRequest {
	r.createLogicalNetworkFromProfile = &createLogicalNetworkFromProfile
	return r
}

func (r LogicalNetworkAPICreateLogicalNetworkFromProfileRequest) Execute() (*LogicalNetwork, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkFromProfileExecute(r)
}

/*
CreateLogicalNetworkFromProfile Create a Logical Network from a profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkAPICreateLogicalNetworkFromProfileRequest
*/
func (a *LogicalNetworkAPIService) CreateLogicalNetworkFromProfile(ctx context.Context) LogicalNetworkAPICreateLogicalNetworkFromProfileRequest {
	return LogicalNetworkAPICreateLogicalNetworkFromProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogicalNetwork
func (a *LogicalNetworkAPIService) CreateLogicalNetworkFromProfileExecute(r LogicalNetworkAPICreateLogicalNetworkFromProfileRequest) (*LogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.CreateLogicalNetworkFromProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/actions/create-from-profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkFromProfile == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkFromProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkFromProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkExecute(r)
}

/*
DeleteLogicalNetwork Delete a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIDeleteLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetwork(ctx context.Context, id float32) LogicalNetworkAPIDeleteLogicalNetworkRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkExecute(r LogicalNetworkAPIDeleteLogicalNetworkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetwork")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategy Delete Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategy Delete Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigPkeyAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigPkeyAllocationStrategy Delete Pkey allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigPkeyAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigPkeyAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigPkeyAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigPkeyAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/pkey/pkey-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigVlanAllocationStrategy Delete Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigVlanAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigVniAllocationStrategy Delete Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigVniAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkConfigZoneAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkConfigZoneAllocationStrategy Delete Zone allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigZoneAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest {
	return LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DeleteLogicalNetworkConfigZoneAllocationStrategyExecute(r LogicalNetworkAPIDeleteLogicalNetworkConfigZoneAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DeleteLogicalNetworkConfigZoneAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/zone/zone-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIDetachExternalConnectionLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	externalConnectionId float32
}

func (r LogicalNetworkAPIDetachExternalConnectionLogicalNetworkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DetachExternalConnectionLogicalNetworkExecute(r)
}

/*
DetachExternalConnectionLogicalNetwork Detaches an external connection from a logical network

Detaches an external connection from a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param externalConnectionId
 @return LogicalNetworkAPIDetachExternalConnectionLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) DetachExternalConnectionLogicalNetwork(ctx context.Context, id float32, externalConnectionId float32) LogicalNetworkAPIDetachExternalConnectionLogicalNetworkRequest {
	return LogicalNetworkAPIDetachExternalConnectionLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
func (a *LogicalNetworkAPIService) DetachExternalConnectionLogicalNetworkExecute(r LogicalNetworkAPIDetachExternalConnectionLogicalNetworkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.DetachExternalConnectionLogicalNetwork")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/external-connections/{externalConnectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
}

func (r LogicalNetworkAPIGetLogicalNetworkRequest) Execute() (*LogicalNetwork, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkExecute(r)
}

/*
GetLogicalNetwork Get a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetwork(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkRequest {
	return LogicalNetworkAPIGetLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetwork
func (a *LogicalNetworkAPIService) GetLogicalNetworkExecute(r LogicalNetworkAPIGetLogicalNetworkRequest) (*LogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterExternalConnectionId *[]string
	filterCreatedAt *[]string
	filterUpdatedAt *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.filterId = &filterId
	return r
}

// Filter by externalConnectionId query param.  **Format:** filter.externalConnectionId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.externalConnectionId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) FilterExternalConnectionId(filterExternalConnectionId []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.filterExternalConnectionId = &filterExternalConnectionId
	return r
}

// Filter by createdAt query param.  **Format:** filter.createdAt&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.createdAt&#x3D;$btw:John Doe&amp;filter.createdAt&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) FilterCreatedAt(filterCreatedAt []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// Filter by updatedAt query param.  **Format:** filter.updatedAt&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.updatedAt&#x3D;$btw:John Doe&amp;filter.updatedAt&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) FilterUpdatedAt(filterUpdatedAt []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.filterUpdatedAt = &filterUpdatedAt
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:DESC   **Default Value:** id:DESC  **Available Fields** - id  - createdAt  - updatedAt  - externalConnectionId  - logicalNetworkId 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) Execute() (*ExternalConnectionLogicalNetworkPaginatedList, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkAttachedExternalConnectionLogicalNetworksExecute(r)
}

/*
GetLogicalNetworkAttachedExternalConnectionLogicalNetworks Get all external connection logical networks

Returns list of all external connection logical networks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkAttachedExternalConnectionLogicalNetworks(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest {
	return LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalConnectionLogicalNetworkPaginatedList
func (a *LogicalNetworkAPIService) GetLogicalNetworkAttachedExternalConnectionLogicalNetworksExecute(r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionLogicalNetworksRequest) (*ExternalConnectionLogicalNetworkPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionLogicalNetworkPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkAttachedExternalConnectionLogicalNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/external-connection-logical-networks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterExternalConnectionId != nil {
		t := *r.filterExternalConnectionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.externalConnectionId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.externalConnectionId", t, "form", "multi")
		}
	}
	if r.filterCreatedAt != nil {
		t := *r.filterCreatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", t, "form", "multi")
		}
	}
	if r.filterUpdatedAt != nil {
		t := *r.filterUpdatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterFabricId *[]string
	filterCreatedAt *[]string
	filterUpdatedAt *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.limit = &limit
	return r
}

// Filter by fabricId query param.  **Format:** filter.fabricId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) FilterFabricId(filterFabricId []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.filterFabricId = &filterFabricId
	return r
}

// Filter by createdAt query param.  **Format:** filter.createdAt&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.createdAt&#x3D;$btw:John Doe&amp;filter.createdAt&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) FilterCreatedAt(filterCreatedAt []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// Filter by updatedAt query param.  **Format:** filter.updatedAt&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.updatedAt&#x3D;$btw:John Doe&amp;filter.updatedAt&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) FilterUpdatedAt(filterUpdatedAt []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.filterUpdatedAt = &filterUpdatedAt
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:DESC   **Default Value:** id:DESC  **Available Fields** - id  - createdAt  - updatedAt 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) Search(search string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** name,label   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - name  - label 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) SearchBy(searchBy []string) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) Execute() (*ExternalConnectionPaginatedList, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkAttachedExternalConnectionsExecute(r)
}

/*
GetLogicalNetworkAttachedExternalConnections List external connections attached to a logical network

Returns list of external connections attached to a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkAttachedExternalConnections(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest {
	return LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalConnectionPaginatedList
func (a *LogicalNetworkAPIService) GetLogicalNetworkAttachedExternalConnectionsExecute(r LogicalNetworkAPIGetLogicalNetworkAttachedExternalConnectionsRequest) (*ExternalConnectionPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkAttachedExternalConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/external-connections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterFabricId != nil {
		t := *r.filterFabricId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", t, "form", "multi")
		}
	}
	if r.filterCreatedAt != nil {
		t := *r.filterCreatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", t, "form", "multi")
		}
	}
	if r.filterUpdatedAt != nil {
		t := *r.filterUpdatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterLabel *[]string
	filterName *[]string
	filterKind *[]string
	filterStatus *[]string
	filterFabricInterconnectId *[]string
	filterTransportId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterId = &filterId
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$btw:John Doe&amp;filter.label&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterLabel(filterLabel []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.  **Format:** filter.name&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.name&#x3D;$btw:John Doe&amp;filter.name&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterName(filterName []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterName = &filterName
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterKind = &filterKind
	return r
}

// Filter by status query param.  **Format:** filter.status&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.status&#x3D;$btw:John Doe&amp;filter.status&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterStatus(filterStatus []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter by fabricInterconnectId query param.  **Format:** filter.fabricInterconnectId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricInterconnectId&#x3D;$btw:John Doe&amp;filter.fabricInterconnectId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterFabricInterconnectId(filterFabricInterconnectId []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterFabricInterconnectId = &filterFabricInterconnectId
	return r
}

// Filter by transportId query param.  **Format:** filter.transportId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.transportId&#x3D;$btw:John Doe&amp;filter.transportId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) FilterTransportId(filterTransportId []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.filterTransportId = &filterTransportId
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;name:DESC   **Default Value:** id:DESC  **Available Fields** - id  - name  - label  - createdAt  - updatedAt 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) Search(search string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** name,label   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - name  - label 
func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) SearchBy(searchBy []string) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) Execute() (*LogicalNetworkInterconnectPaginatedList, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkAttachedLogicalNetworkInterconnectsExecute(r)
}

/*
GetLogicalNetworkAttachedLogicalNetworkInterconnects List logical network interconnects that this logical network is attached to

Returns list of logical network interconnects attached to a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkAttachedLogicalNetworkInterconnects(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest {
	return LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkInterconnectPaginatedList
func (a *LogicalNetworkAPIService) GetLogicalNetworkAttachedLogicalNetworkInterconnectsExecute(r LogicalNetworkAPIGetLogicalNetworkAttachedLogicalNetworkInterconnectsRequest) (*LogicalNetworkInterconnectPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkInterconnectPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkAttachedLogicalNetworkInterconnects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/logical-network-interconnects"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.filterFabricInterconnectId != nil {
		t := *r.filterFabricInterconnectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricInterconnectId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricInterconnectId", t, "form", "multi")
		}
	}
	if r.filterTransportId != nil {
		t := *r.filterTransportId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.transportId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.transportId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigRequest) Execute() (*LogicalNetworkConfig, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigExecute(r)
}

/*
GetLogicalNetworkConfig Get the config for a Logical Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfig(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkConfig
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigExecute(r LogicalNetworkAPIGetLogicalNetworkConfigRequest) (*LogicalNetworkConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) Execute() (*PaginatedIpv4SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigIpv4SubnetAllocationStrategies Get all Ipv4 Subnet allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIpv4SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategiesRequest) (*PaginatedIpv4SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIpv4SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*Ipv4SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigIpv4SubnetAllocationStrategy Get a Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return Ipv4SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*Ipv4SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ipv4SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) Execute() (*PaginatedIpv6SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigIpv6SubnetAllocationStrategies Get all Ipv6 Subnet allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIpv6SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategiesRequest) (*PaginatedIpv6SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIpv6SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*Ipv6SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigIpv6SubnetAllocationStrategy Get a Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return Ipv6SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*Ipv6SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ipv6SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) Execute() (*PaginatedPkeyAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigPkeyAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigPkeyAllocationStrategies Get all Pkey allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigPkeyAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedPkeyAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigPkeyAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategiesRequest) (*PaginatedPkeyAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPkeyAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigPkeyAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/pkey/pkey-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategyRequest) Execute() (*PkeyAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigPkeyAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigPkeyAllocationStrategy Get a Pkey allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigPkeyAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return PkeyAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigPkeyAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigPkeyAllocationStrategyRequest) (*PkeyAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PkeyAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigPkeyAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/pkey/pkey-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) Execute() (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVlanAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigVlanAllocationStrategies Get all Vlan allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVlanAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategiesRequest) (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVlanAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*VlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigVlanAllocationStrategy Get a Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VlanAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVlanAllocationStrategyRequest) (*VlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) Execute() (*PaginatedVniAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVniAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigVniAllocationStrategies Get all Vni allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVniAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategiesRequest) (*PaginatedVniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVniAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*VniAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigVniAllocationStrategy Get a Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VniAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigVniAllocationStrategyRequest) (*VniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) Execute() (*PaginatedZoneAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigZoneAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkConfigZoneAllocationStrategies Get all Zone allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigZoneAllocationStrategies(ctx context.Context, id float32) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedZoneAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigZoneAllocationStrategiesExecute(r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategiesRequest) (*PaginatedZoneAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedZoneAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigZoneAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/zone/zone-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategyRequest) Execute() (*ZoneAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkConfigZoneAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkConfigZoneAllocationStrategy Get a Zone allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigZoneAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategyRequest {
	return LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return ZoneAllocationStrategy
func (a *LogicalNetworkAPIService) GetLogicalNetworkConfigZoneAllocationStrategyExecute(r LogicalNetworkAPIGetLogicalNetworkConfigZoneAllocationStrategyRequest) (*ZoneAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworkConfigZoneAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/zone/zone-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIGetLogicalNetworksRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	filterLabel *[]string
	filterName *[]string
	filterFabricId *[]string
	filterInfrastructureId *[]string
	filterServiceStatus *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	filterRouteDomainId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r LogicalNetworkAPIGetLogicalNetworksRequest) Page(page float32) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** -1   If provided value is greater than max value, max value will be applied. 
func (r LogicalNetworkAPIGetLogicalNetworksRequest) Limit(limit float32) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$eq:John Doe&amp;filter.id&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterId(filterId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$eq:John Doe&amp;filter.kind&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterKind(filterKind []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterKind = &filterKind
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterLabel(filterLabel []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.  **Format:** filter.name&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.name&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterName(filterName []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterName = &filterName
	return r
}

// Filter by fabricId query param.  **Format:** filter.fabricId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricId&#x3D;$eq:John Doe&amp;filter.fabricId&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterFabricId(filterFabricId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterFabricId = &filterFabricId
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$eq:John Doe&amp;filter.infrastructureId&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $not  - $null  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterInfrastructureId(filterInfrastructureId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe&amp;filter.serviceStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterServiceStatus(filterServiceStatus []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterConfigDeployType(filterConfigDeployType []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Filter by routeDomainId query param.  **Format:** filter.routeDomainId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.routeDomainId&#x3D;$eq:John Doe&amp;filter.routeDomainId&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $not  - $null  - $and  - $or
func (r LogicalNetworkAPIGetLogicalNetworksRequest) FilterRouteDomainId(filterRouteDomainId []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.filterRouteDomainId = &filterRouteDomainId
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r LogicalNetworkAPIGetLogicalNetworksRequest) SortBy(sortBy []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r LogicalNetworkAPIGetLogicalNetworksRequest) Search(search string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,label,name   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - label  - name 
func (r LogicalNetworkAPIGetLogicalNetworksRequest) SearchBy(searchBy []string) LogicalNetworkAPIGetLogicalNetworksRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkAPIGetLogicalNetworksRequest) Execute() (*PaginatedLogicalNetworkList, *http.Response, error) {
	return r.ApiService.GetLogicalNetworksExecute(r)
}

/*
GetLogicalNetworks Get all Logical Networks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkAPIGetLogicalNetworksRequest
*/
func (a *LogicalNetworkAPIService) GetLogicalNetworks(ctx context.Context) LogicalNetworkAPIGetLogicalNetworksRequest {
	return LogicalNetworkAPIGetLogicalNetworksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedLogicalNetworkList
func (a *LogicalNetworkAPIService) GetLogicalNetworksExecute(r LogicalNetworkAPIGetLogicalNetworksRequest) (*PaginatedLogicalNetworkList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLogicalNetworkList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.GetLogicalNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterFabricId != nil {
		t := *r.filterFabricId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.filterRouteDomainId != nil {
		t := *r.filterRouteDomainId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.routeDomainId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.routeDomainId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createIpv4SubnetAllocationStrategy *CreateIpv4SubnetAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) CreateIpv4SubnetAllocationStrategy(createIpv4SubnetAllocationStrategy CreateIpv4SubnetAllocationStrategy) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	r.createIpv4SubnetAllocationStrategy = &createIpv4SubnetAllocationStrategy
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) Execute() (*Ipv4SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategy Replace Ipv4 Subnet allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return Ipv4SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategyRequest) (*Ipv4SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ipv4SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createIpv4SubnetAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createIpv4SubnetAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createIpv4SubnetAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createIpv6SubnetAllocationStrategy *CreateIpv6SubnetAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) CreateIpv6SubnetAllocationStrategy(createIpv6SubnetAllocationStrategy CreateIpv6SubnetAllocationStrategy) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	r.createIpv6SubnetAllocationStrategy = &createIpv6SubnetAllocationStrategy
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) Execute() (*Ipv6SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategy Replace Ipv6 Subnet allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return Ipv6SubnetAllocationStrategy
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategyRequest) (*Ipv6SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ipv6SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createIpv6SubnetAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createIpv6SubnetAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createIpv6SubnetAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createPkeyAllocationStrategy *CreatePkeyAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest) CreatePkeyAllocationStrategy(createPkeyAllocationStrategy CreatePkeyAllocationStrategy) LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest {
	r.createPkeyAllocationStrategy = &createPkeyAllocationStrategy
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest) Execute() (*PkeyAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigPkeyAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigPkeyAllocationStrategy Replace Pkey allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigPkeyAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return PkeyAllocationStrategy
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigPkeyAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigPkeyAllocationStrategyRequest) (*PkeyAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PkeyAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigPkeyAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/pkey/pkey-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createPkeyAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createPkeyAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createPkeyAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createVlanAllocationStrategy *CreateVlanAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) CreateVlanAllocationStrategy(createVlanAllocationStrategy CreateVlanAllocationStrategy) LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest {
	r.createVlanAllocationStrategy = &createVlanAllocationStrategy
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) Execute() (*VlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigVlanAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigVlanAllocationStrategy Replace Vlan allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VlanAllocationStrategy
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVlanAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigVlanAllocationStrategyRequest) (*VlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVlanAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVlanAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVlanAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createVniAllocationStrategy *CreateVniAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) CreateVniAllocationStrategy(createVniAllocationStrategy CreateVniAllocationStrategy) LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest {
	r.createVniAllocationStrategy = &createVniAllocationStrategy
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) Execute() (*VniAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigVniAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigVniAllocationStrategy Replace Vni allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VniAllocationStrategy
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigVniAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigVniAllocationStrategyRequest) (*VniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVniAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVniAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVniAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createZoneAllocationStrategy *CreateZoneAllocationStrategy
}

// Entity tag
func (r LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest) CreateZoneAllocationStrategy(createZoneAllocationStrategy CreateZoneAllocationStrategy) LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest {
	r.createZoneAllocationStrategy = &createZoneAllocationStrategy
	return r
}

func (r LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest) Execute() (*ZoneAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkConfigZoneAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkConfigZoneAllocationStrategy Replace Zone allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest
*/
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigZoneAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest {
	return LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return ZoneAllocationStrategy
func (a *LogicalNetworkAPIService) ReplaceLogicalNetworkConfigZoneAllocationStrategyExecute(r LogicalNetworkAPIReplaceLogicalNetworkConfigZoneAllocationStrategyRequest) (*ZoneAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ZoneAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.ReplaceLogicalNetworkConfigZoneAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config/zone/zone-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createZoneAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createZoneAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createZoneAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIUpdateLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	updateLogicalNetwork *UpdateLogicalNetwork
}

// Entity tag
func (r LogicalNetworkAPIUpdateLogicalNetworkRequest) IfMatch(ifMatch string) LogicalNetworkAPIUpdateLogicalNetworkRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkRequest) UpdateLogicalNetwork(updateLogicalNetwork UpdateLogicalNetwork) LogicalNetworkAPIUpdateLogicalNetworkRequest {
	r.updateLogicalNetwork = &updateLogicalNetwork
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkRequest) Execute() (*LogicalNetwork, *http.Response, error) {
	return r.ApiService.UpdateLogicalNetworkExecute(r)
}

/*
UpdateLogicalNetwork Update Logical Network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIUpdateLogicalNetworkRequest
*/
func (a *LogicalNetworkAPIService) UpdateLogicalNetwork(ctx context.Context, id float32) LogicalNetworkAPIUpdateLogicalNetworkRequest {
	return LogicalNetworkAPIUpdateLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetwork
func (a *LogicalNetworkAPIService) UpdateLogicalNetworkExecute(r LogicalNetworkAPIUpdateLogicalNetworkRequest) (*LogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.UpdateLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.updateLogicalNetwork == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.updateLogicalNetwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkAPIUpdateLogicalNetworkConfigRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkAPIService
	id float32
	ifMatch *string
	updateLogicalNetworkConfigGlobalSettings *UpdateLogicalNetworkConfigGlobalSettings
}

// Entity tag
func (r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) IfMatch(ifMatch string) LogicalNetworkAPIUpdateLogicalNetworkConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) UpdateLogicalNetworkConfigGlobalSettings(updateLogicalNetworkConfigGlobalSettings UpdateLogicalNetworkConfigGlobalSettings) LogicalNetworkAPIUpdateLogicalNetworkConfigRequest {
	r.updateLogicalNetworkConfigGlobalSettings = &updateLogicalNetworkConfigGlobalSettings
	return r
}

func (r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) Execute() (*LogicalNetworkConfig, *http.Response, error) {
	return r.ApiService.UpdateLogicalNetworkConfigExecute(r)
}

/*
UpdateLogicalNetworkConfig Update Logical Network config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkAPIUpdateLogicalNetworkConfigRequest
*/
func (a *LogicalNetworkAPIService) UpdateLogicalNetworkConfig(ctx context.Context, id float32) LogicalNetworkAPIUpdateLogicalNetworkConfigRequest {
	return LogicalNetworkAPIUpdateLogicalNetworkConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return LogicalNetworkConfig
func (a *LogicalNetworkAPIService) UpdateLogicalNetworkConfigExecute(r LogicalNetworkAPIUpdateLogicalNetworkConfigRequest) (*LogicalNetworkConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkAPIService.UpdateLogicalNetworkConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-networks/{id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.updateLogicalNetworkConfigGlobalSettings == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetworkConfigGlobalSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.updateLogicalNetworkConfigGlobalSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
