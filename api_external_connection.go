/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ExternalConnectionAPIService ExternalConnectionAPI service
type ExternalConnectionAPIService service

type ExternalConnectionAPICreateExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	createExternalConnection *CreateExternalConnection
}

// The external connection to create
func (r ExternalConnectionAPICreateExternalConnectionRequest) CreateExternalConnection(createExternalConnection CreateExternalConnection) ExternalConnectionAPICreateExternalConnectionRequest {
	r.createExternalConnection = &createExternalConnection
	return r
}

func (r ExternalConnectionAPICreateExternalConnectionRequest) Execute() (*ExternalConnection, *http.Response, error) {
	return r.ApiService.CreateExternalConnectionExecute(r)
}

/*
CreateExternalConnection Create a new external connection

Creates a new external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalConnectionAPICreateExternalConnectionRequest
*/
func (a *ExternalConnectionAPIService) CreateExternalConnection(ctx context.Context) ExternalConnectionAPICreateExternalConnectionRequest {
	return ExternalConnectionAPICreateExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExternalConnection
func (a *ExternalConnectionAPIService) CreateExternalConnectionExecute(r ExternalConnectionAPICreateExternalConnectionRequest) (*ExternalConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.CreateExternalConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createExternalConnection == nil {
		return localVarReturnValue, nil, reportError("createExternalConnection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExternalConnection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPICreateExternalConnectionInterfaceRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	createExternalConnectionInterface *CreateExternalConnectionInterface
}

// The external connection interface to create
func (r ExternalConnectionAPICreateExternalConnectionInterfaceRequest) CreateExternalConnectionInterface(createExternalConnectionInterface CreateExternalConnectionInterface) ExternalConnectionAPICreateExternalConnectionInterfaceRequest {
	r.createExternalConnectionInterface = &createExternalConnectionInterface
	return r
}

func (r ExternalConnectionAPICreateExternalConnectionInterfaceRequest) Execute() (*ExternalConnectionInterface, *http.Response, error) {
	return r.ApiService.CreateExternalConnectionInterfaceExecute(r)
}

/*
CreateExternalConnectionInterface Create a new external connection interface

Creates a new external connection interface for the specified external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @return ExternalConnectionAPICreateExternalConnectionInterfaceRequest
*/
func (a *ExternalConnectionAPIService) CreateExternalConnectionInterface(ctx context.Context, externalConnectionId int32) ExternalConnectionAPICreateExternalConnectionInterfaceRequest {
	return ExternalConnectionAPICreateExternalConnectionInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
//  @return ExternalConnectionInterface
func (a *ExternalConnectionAPIService) CreateExternalConnectionInterfaceExecute(r ExternalConnectionAPICreateExternalConnectionInterfaceRequest) (*ExternalConnectionInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.CreateExternalConnectionInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createExternalConnectionInterface == nil {
		return localVarReturnValue, nil, reportError("createExternalConnectionInterface is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExternalConnectionInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	createExternalConnectionLogicalNetwork *CreateExternalConnectionLogicalNetwork
}

// The external connection logical network to create
func (r ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest) CreateExternalConnectionLogicalNetwork(createExternalConnectionLogicalNetwork CreateExternalConnectionLogicalNetwork) ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest {
	r.createExternalConnectionLogicalNetwork = &createExternalConnectionLogicalNetwork
	return r
}

func (r ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest) Execute() (*ExternalConnectionLogicalNetwork, *http.Response, error) {
	return r.ApiService.CreateExternalConnectionLogicalNetworkExecute(r)
}

/*
CreateExternalConnectionLogicalNetwork Create a new external connection logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId The id of the external connection
 @return ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest
*/
func (a *ExternalConnectionAPIService) CreateExternalConnectionLogicalNetwork(ctx context.Context, externalConnectionId int32) ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest {
	return ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
//  @return ExternalConnectionLogicalNetwork
func (a *ExternalConnectionAPIService) CreateExternalConnectionLogicalNetworkExecute(r ExternalConnectionAPICreateExternalConnectionLogicalNetworkRequest) (*ExternalConnectionLogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionLogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.CreateExternalConnectionLogicalNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/logical-networks"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createExternalConnectionLogicalNetwork == nil {
		return localVarReturnValue, nil, reportError("createExternalConnectionLogicalNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createExternalConnectionLogicalNetwork
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIDeleteExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
}

func (r ExternalConnectionAPIDeleteExternalConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExternalConnectionExecute(r)
}

/*
DeleteExternalConnection Delete external connection

Deletes the specified external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @return ExternalConnectionAPIDeleteExternalConnectionRequest
*/
func (a *ExternalConnectionAPIService) DeleteExternalConnection(ctx context.Context, externalConnectionId int32) ExternalConnectionAPIDeleteExternalConnectionRequest {
	return ExternalConnectionAPIDeleteExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
func (a *ExternalConnectionAPIService) DeleteExternalConnectionExecute(r ExternalConnectionAPIDeleteExternalConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.DeleteExternalConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	externalConnectionInterfaceId int32
	ifMatch *string
}

// Entity tag
func (r ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest) IfMatch(ifMatch string) ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExternalConnectionInterfaceExecute(r)
}

/*
DeleteExternalConnectionInterface Delete external connection interface

Deletes the specified external connection interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @param externalConnectionInterfaceId
 @return ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest
*/
func (a *ExternalConnectionAPIService) DeleteExternalConnectionInterface(ctx context.Context, externalConnectionId int32, externalConnectionInterfaceId int32) ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest {
	return ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
		externalConnectionInterfaceId: externalConnectionInterfaceId,
	}
}

// Execute executes the request
func (a *ExternalConnectionAPIService) DeleteExternalConnectionInterfaceExecute(r ExternalConnectionAPIDeleteExternalConnectionInterfaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.DeleteExternalConnectionInterface")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/interfaces/{externalConnectionInterfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionInterfaceId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionInterfaceId, "externalConnectionInterfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExternalConnectionAPIDeleteExternalConnectionLogicalNetworkRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	id int32
}

func (r ExternalConnectionAPIDeleteExternalConnectionLogicalNetworkRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExternalConnectionLogicalNetworkExecute(r)
}

/*
DeleteExternalConnectionLogicalNetwork Start deletion of an external connection logical network. Only those in pending_activation state will be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId The ID of the external connection
 @param id The ID of the external connection logical network to delete
 @return ExternalConnectionAPIDeleteExternalConnectionLogicalNetworkRequest
*/
func (a *ExternalConnectionAPIService) DeleteExternalConnectionLogicalNetwork(ctx context.Context, externalConnectionId int32, id int32) ExternalConnectionAPIDeleteExternalConnectionLogicalNetworkRequest {
	return ExternalConnectionAPIDeleteExternalConnectionLogicalNetworkRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalConnectionAPIService) DeleteExternalConnectionLogicalNetworkExecute(r ExternalConnectionAPIDeleteExternalConnectionLogicalNetworkRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.DeleteExternalConnectionLogicalNetwork")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetExternalConnectionByIdRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
}

func (r ExternalConnectionAPIGetExternalConnectionByIdRequest) Execute() (*ExternalConnection, *http.Response, error) {
	return r.ApiService.GetExternalConnectionByIdExecute(r)
}

/*
GetExternalConnectionById Get external connection details

Returns the details of the specified external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @return ExternalConnectionAPIGetExternalConnectionByIdRequest
*/
func (a *ExternalConnectionAPIService) GetExternalConnectionById(ctx context.Context, externalConnectionId int32) ExternalConnectionAPIGetExternalConnectionByIdRequest {
	return ExternalConnectionAPIGetExternalConnectionByIdRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
//  @return ExternalConnection
func (a *ExternalConnectionAPIService) GetExternalConnectionByIdExecute(r ExternalConnectionAPIGetExternalConnectionByIdRequest) (*ExternalConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetExternalConnectionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetExternalConnectionInterfaceByIdRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	externalConnectionInterfaceId int32
}

func (r ExternalConnectionAPIGetExternalConnectionInterfaceByIdRequest) Execute() (*ExternalConnectionInterface, *http.Response, error) {
	return r.ApiService.GetExternalConnectionInterfaceByIdExecute(r)
}

/*
GetExternalConnectionInterfaceById Get external connection interface details

Returns the details of the specified external connection interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @param externalConnectionInterfaceId
 @return ExternalConnectionAPIGetExternalConnectionInterfaceByIdRequest
*/
func (a *ExternalConnectionAPIService) GetExternalConnectionInterfaceById(ctx context.Context, externalConnectionId int32, externalConnectionInterfaceId int32) ExternalConnectionAPIGetExternalConnectionInterfaceByIdRequest {
	return ExternalConnectionAPIGetExternalConnectionInterfaceByIdRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
		externalConnectionInterfaceId: externalConnectionInterfaceId,
	}
}

// Execute executes the request
//  @return ExternalConnectionInterface
func (a *ExternalConnectionAPIService) GetExternalConnectionInterfaceByIdExecute(r ExternalConnectionAPIGetExternalConnectionInterfaceByIdRequest) (*ExternalConnectionInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetExternalConnectionInterfaceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/interfaces/{externalConnectionInterfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionInterfaceId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionInterfaceId, "externalConnectionInterfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetExternalConnectionInterfacesRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	page *float32
	limit *float32
	filterId *[]string
	filterCreatedAt *[]string
	filterUpdatedAt *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) Page(page float32) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) Limit(limit float32) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) FilterId(filterId []string) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	r.filterId = &filterId
	return r
}

// Filter by createdAt query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.createdAt&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.createdAt&#x3D;$not:$like:John Doe&amp;filter.createdAt&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) FilterCreatedAt(filterCreatedAt []string) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// Filter by updatedAt query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.updatedAt&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.updatedAt&#x3D;$not:$like:John Doe&amp;filter.updatedAt&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) FilterUpdatedAt(filterUpdatedAt []string) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	r.filterUpdatedAt = &filterUpdatedAt
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt;&lt;/ul&gt;       
func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) SortBy(sortBy []string) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	r.sortBy = &sortBy
	return r
}

func (r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) Execute() (*ExternalConnectionInterfacePaginatedList, *http.Response, error) {
	return r.ApiService.GetExternalConnectionInterfacesExecute(r)
}

/*
GetExternalConnectionInterfaces List external connection interfaces

Returns list of external connection interfaces for the specified external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @return ExternalConnectionAPIGetExternalConnectionInterfacesRequest
*/
func (a *ExternalConnectionAPIService) GetExternalConnectionInterfaces(ctx context.Context, externalConnectionId int32) ExternalConnectionAPIGetExternalConnectionInterfacesRequest {
	return ExternalConnectionAPIGetExternalConnectionInterfacesRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
//  @return ExternalConnectionInterfacePaginatedList
func (a *ExternalConnectionAPIService) GetExternalConnectionInterfacesExecute(r ExternalConnectionAPIGetExternalConnectionInterfacesRequest) (*ExternalConnectionInterfacePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionInterfacePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetExternalConnectionInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterCreatedAt != nil {
		t := *r.filterCreatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", t, "form", "multi")
		}
	}
	if r.filterUpdatedAt != nil {
		t := *r.filterUpdatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetExternalConnectionLogicalNetworkByIdRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	id int32
}

func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworkByIdRequest) Execute() (*ExternalConnectionLogicalNetwork, *http.Response, error) {
	return r.ApiService.GetExternalConnectionLogicalNetworkByIdExecute(r)
}

/*
GetExternalConnectionLogicalNetworkById Get an external connection logical network by ID

Returns an external connection logical network by its ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId The id of the external connection
 @param id The ID of the external connection logical network to retrieve
 @return ExternalConnectionAPIGetExternalConnectionLogicalNetworkByIdRequest
*/
func (a *ExternalConnectionAPIService) GetExternalConnectionLogicalNetworkById(ctx context.Context, externalConnectionId int32, id int32) ExternalConnectionAPIGetExternalConnectionLogicalNetworkByIdRequest {
	return ExternalConnectionAPIGetExternalConnectionLogicalNetworkByIdRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalConnectionLogicalNetwork
func (a *ExternalConnectionAPIService) GetExternalConnectionLogicalNetworkByIdExecute(r ExternalConnectionAPIGetExternalConnectionLogicalNetworkByIdRequest) (*ExternalConnectionLogicalNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionLogicalNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetExternalConnectionLogicalNetworkById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/logical-networks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	page *float32
	limit *float32
	filterId *[]string
	filterExternalConnectionId *[]string
	filterLogicalNetworkId *[]string
	filterCreatedAt *[]string
	filterUpdatedAt *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) Page(page float32) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) Limit(limit float32) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) FilterId(filterId []string) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.filterId = &filterId
	return r
}

// Filter by externalConnectionId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.externalConnectionId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.externalConnectionId&#x3D;$not:$like:John Doe&amp;filter.externalConnectionId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) FilterExternalConnectionId(filterExternalConnectionId []string) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.filterExternalConnectionId = &filterExternalConnectionId
	return r
}

// Filter by logicalNetworkId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.logicalNetworkId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.logicalNetworkId&#x3D;$not:$like:John Doe&amp;filter.logicalNetworkId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) FilterLogicalNetworkId(filterLogicalNetworkId []string) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.filterLogicalNetworkId = &filterLogicalNetworkId
	return r
}

// Filter by createdAt query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.createdAt&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.createdAt&#x3D;$not:$like:John Doe&amp;filter.createdAt&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) FilterCreatedAt(filterCreatedAt []string) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// Filter by updatedAt query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.updatedAt&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.updatedAt&#x3D;$not:$like:John Doe&amp;filter.updatedAt&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) FilterUpdatedAt(filterUpdatedAt []string) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.filterUpdatedAt = &filterUpdatedAt
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt; &lt;li&gt;externalConnectionId&lt;/li&gt; &lt;li&gt;logicalNetworkId&lt;/li&gt;&lt;/ul&gt;       
func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) SortBy(sortBy []string) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	r.sortBy = &sortBy
	return r
}

func (r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) Execute() (*ExternalConnectionLogicalNetworkPaginatedList, *http.Response, error) {
	return r.ApiService.GetExternalConnectionLogicalNetworksExecute(r)
}

/*
GetExternalConnectionLogicalNetworks Get all logical networks of an external connection

Returns list of all external connection logical networks for the specified external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId The id of the external connection
 @return ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest
*/
func (a *ExternalConnectionAPIService) GetExternalConnectionLogicalNetworks(ctx context.Context, externalConnectionId int32) ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest {
	return ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
//  @return ExternalConnectionLogicalNetworkPaginatedList
func (a *ExternalConnectionAPIService) GetExternalConnectionLogicalNetworksExecute(r ExternalConnectionAPIGetExternalConnectionLogicalNetworksRequest) (*ExternalConnectionLogicalNetworkPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionLogicalNetworkPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetExternalConnectionLogicalNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/logical-networks"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterExternalConnectionId != nil {
		t := *r.filterExternalConnectionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.externalConnectionId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.externalConnectionId", t, "form", "multi")
		}
	}
	if r.filterLogicalNetworkId != nil {
		t := *r.filterLogicalNetworkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.logicalNetworkId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.logicalNetworkId", t, "form", "multi")
		}
	}
	if r.filterCreatedAt != nil {
		t := *r.filterCreatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", t, "form", "multi")
		}
	}
	if r.filterUpdatedAt != nil {
		t := *r.filterUpdatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetExternalConnectionsRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterFabricId *[]string
	filterCreatedAt *[]string
	filterUpdatedAt *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ExternalConnectionAPIGetExternalConnectionsRequest) Page(page float32) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ExternalConnectionAPIGetExternalConnectionsRequest) Limit(limit float32) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionsRequest) FilterId(filterId []string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.filterId = &filterId
	return r
}

// Filter by fabricId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fabricId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fabricId&#x3D;$not:$like:John Doe&amp;filter.fabricId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionsRequest) FilterFabricId(filterFabricId []string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.filterFabricId = &filterFabricId
	return r
}

// Filter by createdAt query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.createdAt&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.createdAt&#x3D;$not:$like:John Doe&amp;filter.createdAt&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionsRequest) FilterCreatedAt(filterCreatedAt []string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.filterCreatedAt = &filterCreatedAt
	return r
}

// Filter by updatedAt query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.updatedAt&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.updatedAt&#x3D;$not:$like:John Doe&amp;filter.updatedAt&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r ExternalConnectionAPIGetExternalConnectionsRequest) FilterUpdatedAt(filterUpdatedAt []string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.filterUpdatedAt = &filterUpdatedAt
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt;&lt;/ul&gt;       
func (r ExternalConnectionAPIGetExternalConnectionsRequest) SortBy(sortBy []string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r ExternalConnectionAPIGetExternalConnectionsRequest) Search(search string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; name,label           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;name&lt;/li&gt; &lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;         
func (r ExternalConnectionAPIGetExternalConnectionsRequest) SearchBy(searchBy []string) ExternalConnectionAPIGetExternalConnectionsRequest {
	r.searchBy = &searchBy
	return r
}

func (r ExternalConnectionAPIGetExternalConnectionsRequest) Execute() (*ExternalConnectionPaginatedList, *http.Response, error) {
	return r.ApiService.GetExternalConnectionsExecute(r)
}

/*
GetExternalConnections List external connections

Returns list of external connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ExternalConnectionAPIGetExternalConnectionsRequest
*/
func (a *ExternalConnectionAPIService) GetExternalConnections(ctx context.Context) ExternalConnectionAPIGetExternalConnectionsRequest {
	return ExternalConnectionAPIGetExternalConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExternalConnectionPaginatedList
func (a *ExternalConnectionAPIService) GetExternalConnectionsExecute(r ExternalConnectionAPIGetExternalConnectionsRequest) (*ExternalConnectionPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetExternalConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterFabricId != nil {
		t := *r.filterFabricId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", t, "form", "multi")
		}
	}
	if r.filterCreatedAt != nil {
		t := *r.filterCreatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.createdAt", t, "form", "multi")
		}
	}
	if r.filterUpdatedAt != nil {
		t := *r.filterUpdatedAt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.updatedAt", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIGetNetworkDeviceInterfacesAndExternalConnectionsRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	networkDeviceId float32
}

func (r ExternalConnectionAPIGetNetworkDeviceInterfacesAndExternalConnectionsRequest) Execute() (*NetworkDeviceExternalConnectionInterfaces, *http.Response, error) {
	return r.ApiService.GetNetworkDeviceInterfacesAndExternalConnectionsExecute(r)
}

/*
GetNetworkDeviceInterfacesAndExternalConnections List network device interfaces associated with external connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return ExternalConnectionAPIGetNetworkDeviceInterfacesAndExternalConnectionsRequest
*/
func (a *ExternalConnectionAPIService) GetNetworkDeviceInterfacesAndExternalConnections(ctx context.Context, networkDeviceId float32) ExternalConnectionAPIGetNetworkDeviceInterfacesAndExternalConnectionsRequest {
	return ExternalConnectionAPIGetNetworkDeviceInterfacesAndExternalConnectionsRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return NetworkDeviceExternalConnectionInterfaces
func (a *ExternalConnectionAPIService) GetNetworkDeviceInterfacesAndExternalConnectionsExecute(r ExternalConnectionAPIGetNetworkDeviceInterfacesAndExternalConnectionsRequest) (*NetworkDeviceExternalConnectionInterfaces, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkDeviceExternalConnectionInterfaces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.GetNetworkDeviceInterfacesAndExternalConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/network-devices/{networkDeviceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIUpdateExternalConnectionRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	updateExternalConnection *UpdateExternalConnection
	ifMatch *string
}

// The external connection configuration changes
func (r ExternalConnectionAPIUpdateExternalConnectionRequest) UpdateExternalConnection(updateExternalConnection UpdateExternalConnection) ExternalConnectionAPIUpdateExternalConnectionRequest {
	r.updateExternalConnection = &updateExternalConnection
	return r
}

// Entity tag
func (r ExternalConnectionAPIUpdateExternalConnectionRequest) IfMatch(ifMatch string) ExternalConnectionAPIUpdateExternalConnectionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ExternalConnectionAPIUpdateExternalConnectionRequest) Execute() (*ExternalConnection, *http.Response, error) {
	return r.ApiService.UpdateExternalConnectionExecute(r)
}

/*
UpdateExternalConnection Update external connection

Updates the specified external connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @return ExternalConnectionAPIUpdateExternalConnectionRequest
*/
func (a *ExternalConnectionAPIService) UpdateExternalConnection(ctx context.Context, externalConnectionId int32) ExternalConnectionAPIUpdateExternalConnectionRequest {
	return ExternalConnectionAPIUpdateExternalConnectionRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
	}
}

// Execute executes the request
//  @return ExternalConnection
func (a *ExternalConnectionAPIService) UpdateExternalConnectionExecute(r ExternalConnectionAPIUpdateExternalConnectionRequest) (*ExternalConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.UpdateExternalConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateExternalConnection == nil {
		return localVarReturnValue, nil, reportError("updateExternalConnection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateExternalConnection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest struct {
	ctx context.Context
	ApiService *ExternalConnectionAPIService
	externalConnectionId int32
	externalConnectionInterfaceId int32
	updateExternalConnectionInterface *UpdateExternalConnectionInterface
	ifMatch *string
}

// The external connection interface configuration changes
func (r ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest) UpdateExternalConnectionInterface(updateExternalConnectionInterface UpdateExternalConnectionInterface) ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest {
	r.updateExternalConnectionInterface = &updateExternalConnectionInterface
	return r
}

// Entity tag
func (r ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest) IfMatch(ifMatch string) ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest) Execute() (*ExternalConnectionInterface, *http.Response, error) {
	return r.ApiService.UpdateExternalConnectionInterfaceExecute(r)
}

/*
UpdateExternalConnectionInterface Update external connection interface

Updates the specified external connection interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param externalConnectionId
 @param externalConnectionInterfaceId
 @return ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest
*/
func (a *ExternalConnectionAPIService) UpdateExternalConnectionInterface(ctx context.Context, externalConnectionId int32, externalConnectionInterfaceId int32) ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest {
	return ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		externalConnectionId: externalConnectionId,
		externalConnectionInterfaceId: externalConnectionInterfaceId,
	}
}

// Execute executes the request
//  @return ExternalConnectionInterface
func (a *ExternalConnectionAPIService) UpdateExternalConnectionInterfaceExecute(r ExternalConnectionAPIUpdateExternalConnectionInterfaceRequest) (*ExternalConnectionInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalConnectionInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalConnectionAPIService.UpdateExternalConnectionInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/external-connections/{externalConnectionId}/interfaces/{externalConnectionInterfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionId, "externalConnectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalConnectionInterfaceId"+"}", url.PathEscape(parameterValueToString(r.externalConnectionInterfaceId, "externalConnectionInterfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateExternalConnectionInterface == nil {
		return localVarReturnValue, nil, reportError("updateExternalConnectionInterface is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateExternalConnectionInterface
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
