/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// RouteDomainAPIService RouteDomainAPI service
type RouteDomainAPIService service

type RouteDomainAPICreateRouteDomainRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	createRouteDomain *CreateRouteDomain
}

// The route domain to create
func (r RouteDomainAPICreateRouteDomainRequest) CreateRouteDomain(createRouteDomain CreateRouteDomain) RouteDomainAPICreateRouteDomainRequest {
	r.createRouteDomain = &createRouteDomain
	return r
}

func (r RouteDomainAPICreateRouteDomainRequest) Execute() (*RouteDomain, *http.Response, error) {
	return r.ApiService.CreateRouteDomainExecute(r)
}

/*
CreateRouteDomain Create a Route Domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RouteDomainAPICreateRouteDomainRequest
*/
func (a *RouteDomainAPIService) CreateRouteDomain(ctx context.Context) RouteDomainAPICreateRouteDomainRequest {
	return RouteDomainAPICreateRouteDomainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteDomain
func (a *RouteDomainAPIService) CreateRouteDomainExecute(r RouteDomainAPICreateRouteDomainRequest) (*RouteDomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteDomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.CreateRouteDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRouteDomain == nil {
		return localVarReturnValue, nil, reportError("createRouteDomain is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRouteDomain
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	ifMatch *string
	createVlanAllocationStrategy *CreateVlanAllocationStrategy
}

// Entity tag
func (r RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest) CreateVlanAllocationStrategy(createVlanAllocationStrategy CreateVlanAllocationStrategy) RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest {
	r.createVlanAllocationStrategy = &createVlanAllocationStrategy
	return r
}

func (r RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest) Execute() (*VlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateRouteDomainConfigL3VlanAllocationStrategyExecute(r)
}

/*
CreateRouteDomainConfigL3VlanAllocationStrategy Create L3 Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) CreateRouteDomainConfigL3VlanAllocationStrategy(ctx context.Context, id float32) RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest {
	return RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VlanAllocationStrategy
func (a *RouteDomainAPIService) CreateRouteDomainConfigL3VlanAllocationStrategyExecute(r RouteDomainAPICreateRouteDomainConfigL3VlanAllocationStrategyRequest) (*VlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.CreateRouteDomainConfigL3VlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVlanAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVlanAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVlanAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	ifMatch *string
	createVniAllocationStrategy *CreateVniAllocationStrategy
}

// Entity tag
func (r RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest) CreateVniAllocationStrategy(createVniAllocationStrategy CreateVniAllocationStrategy) RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest {
	r.createVniAllocationStrategy = &createVniAllocationStrategy
	return r
}

func (r RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest) Execute() (*VniAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateRouteDomainConfigVniAllocationStrategyExecute(r)
}

/*
CreateRouteDomainConfigVniAllocationStrategy Create Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) CreateRouteDomainConfigVniAllocationStrategy(ctx context.Context, id float32) RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest {
	return RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VniAllocationStrategy
func (a *RouteDomainAPIService) CreateRouteDomainConfigVniAllocationStrategyExecute(r RouteDomainAPICreateRouteDomainConfigVniAllocationStrategyRequest) (*VniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.CreateRouteDomainConfigVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVniAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVniAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVniAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	ifMatch *string
	createManualVrfAllocationStrategy *CreateManualVrfAllocationStrategy
}

// Entity tag
func (r RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest) CreateManualVrfAllocationStrategy(createManualVrfAllocationStrategy CreateManualVrfAllocationStrategy) RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest {
	r.createManualVrfAllocationStrategy = &createManualVrfAllocationStrategy
	return r
}

func (r RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest) Execute() (*ManualVrfAllocationStrategy, *http.Response, error) {
	return r.ApiService.CreateRouteDomainConfigVrfAllocationStrategyExecute(r)
}

/*
CreateRouteDomainConfigVrfAllocationStrategy Create Vrf allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) CreateRouteDomainConfigVrfAllocationStrategy(ctx context.Context, id float32) RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest {
	return RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ManualVrfAllocationStrategy
func (a *RouteDomainAPIService) CreateRouteDomainConfigVrfAllocationStrategyExecute(r RouteDomainAPICreateRouteDomainConfigVrfAllocationStrategyRequest) (*ManualVrfAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualVrfAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.CreateRouteDomainConfigVrfAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/vrf-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createManualVrfAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createManualVrfAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createManualVrfAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIDeleteRouteDomainRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	ifMatch *string
}

// Entity tag
func (r RouteDomainAPIDeleteRouteDomainRequest) IfMatch(ifMatch string) RouteDomainAPIDeleteRouteDomainRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIDeleteRouteDomainRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRouteDomainExecute(r)
}

/*
DeleteRouteDomain Delete a Route Domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIDeleteRouteDomainRequest
*/
func (a *RouteDomainAPIService) DeleteRouteDomain(ctx context.Context, id float32) RouteDomainAPIDeleteRouteDomainRequest {
	return RouteDomainAPIDeleteRouteDomainRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RouteDomainAPIService) DeleteRouteDomainExecute(r RouteDomainAPIDeleteRouteDomainRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.DeleteRouteDomain")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRouteDomainConfigL3VlanAllocationStrategyExecute(r)
}

/*
DeleteRouteDomainConfigL3VlanAllocationStrategy Delete L3 Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) DeleteRouteDomainConfigL3VlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest {
	return RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *RouteDomainAPIService) DeleteRouteDomainConfigL3VlanAllocationStrategyExecute(r RouteDomainAPIDeleteRouteDomainConfigL3VlanAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.DeleteRouteDomainConfigL3VlanAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRouteDomainConfigL3VniAllocationStrategyExecute(r)
}

/*
DeleteRouteDomainConfigL3VniAllocationStrategy Delete L3 Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) DeleteRouteDomainConfigL3VniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest {
	return RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *RouteDomainAPIService) DeleteRouteDomainConfigL3VniAllocationStrategyExecute(r RouteDomainAPIDeleteRouteDomainConfigL3VniAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.DeleteRouteDomainConfigL3VniAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRouteDomainConfigVrfAllocationStrategyExecute(r)
}

/*
DeleteRouteDomainConfigVrfAllocationStrategy Delete Vrf allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) DeleteRouteDomainConfigVrfAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest {
	return RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *RouteDomainAPIService) DeleteRouteDomainConfigVrfAllocationStrategyExecute(r RouteDomainAPIDeleteRouteDomainConfigVrfAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.DeleteRouteDomainConfigVrfAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/vrf-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return nil, reportError("ifMatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
}

func (r RouteDomainAPIGetRouteDomainRequest) Execute() (*RouteDomain, *http.Response, error) {
	return r.ApiService.GetRouteDomainExecute(r)
}

/*
GetRouteDomain Get a Route Domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIGetRouteDomainRequest
*/
func (a *RouteDomainAPIService) GetRouteDomain(ctx context.Context, id float32) RouteDomainAPIGetRouteDomainRequest {
	return RouteDomainAPIGetRouteDomainRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteDomain
func (a *RouteDomainAPIService) GetRouteDomainExecute(r RouteDomainAPIGetRouteDomainRequest) (*RouteDomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteDomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
}

func (r RouteDomainAPIGetRouteDomainConfigRequest) Execute() (*RouteDomainConfig, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigExecute(r)
}

/*
GetRouteDomainConfig Get the config for a Route Domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIGetRouteDomainConfigRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfig(ctx context.Context, id float32) RouteDomainAPIGetRouteDomainConfigRequest {
	return RouteDomainAPIGetRouteDomainConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteDomainConfig
func (a *RouteDomainAPIService) GetRouteDomainConfigExecute(r RouteDomainAPIGetRouteDomainConfigRequest) (*RouteDomainConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteDomainConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) Page(page float32) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) Limit(limit float32) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) FilterId(filterId []string) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) FilterKind(filterKind []string) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) SortBy(sortBy []string) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) Execute() (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigL3VlanAllocationStrategiesExecute(r)
}

/*
GetRouteDomainConfigL3VlanAllocationStrategies Get all L3 Vlan allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VlanAllocationStrategies(ctx context.Context, id float32) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest {
	return RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVlanAllocationStrategy
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VlanAllocationStrategiesExecute(r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategiesRequest) (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfigL3VlanAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
}

func (r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategyRequest) Execute() (*VlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigL3VlanAllocationStrategyExecute(r)
}

/*
GetRouteDomainConfigL3VlanAllocationStrategy Get a L3 Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategyRequest {
	return RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VlanAllocationStrategy
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VlanAllocationStrategyExecute(r RouteDomainAPIGetRouteDomainConfigL3VlanAllocationStrategyRequest) (*VlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfigL3VlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) Page(page float32) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) Limit(limit float32) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) FilterId(filterId []string) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) FilterKind(filterKind []string) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) SortBy(sortBy []string) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) Execute() (*PaginatedVniAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigL3VniAllocationStrategiesExecute(r)
}

/*
GetRouteDomainConfigL3VniAllocationStrategies Get all L3 Vni allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VniAllocationStrategies(ctx context.Context, id float32) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest {
	return RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVniAllocationStrategy
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VniAllocationStrategiesExecute(r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategiesRequest) (*PaginatedVniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfigL3VniAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
}

func (r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategyRequest) Execute() (*VniAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigL3VniAllocationStrategyExecute(r)
}

/*
GetRouteDomainConfigL3VniAllocationStrategy Get a L3 Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategyRequest {
	return RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VniAllocationStrategy
func (a *RouteDomainAPIService) GetRouteDomainConfigL3VniAllocationStrategyExecute(r RouteDomainAPIGetRouteDomainConfigL3VniAllocationStrategyRequest) (*VniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfigL3VniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) Page(page float32) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 100    **Max Value:** 1000   If provided value is greater than max value, max value will be applied. 
func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) Limit(limit float32) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) FilterId(filterId []string) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$btw:John Doe&amp;filter.kind&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) FilterKind(filterKind []string) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) SortBy(sortBy []string) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) Execute() (*PaginatedVrfAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigVrfAllocationStrategiesExecute(r)
}

/*
GetRouteDomainConfigVrfAllocationStrategies Get all Vrf allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfigVrfAllocationStrategies(ctx context.Context, id float32) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest {
	return RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVrfAllocationStrategy
func (a *RouteDomainAPIService) GetRouteDomainConfigVrfAllocationStrategiesExecute(r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategiesRequest) (*PaginatedVrfAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVrfAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfigVrfAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/vrf-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
}

func (r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategyRequest) Execute() (*ManualVrfAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetRouteDomainConfigVrfAllocationStrategyExecute(r)
}

/*
GetRouteDomainConfigVrfAllocationStrategy Get a Vrf allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) GetRouteDomainConfigVrfAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategyRequest {
	return RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return ManualVrfAllocationStrategy
func (a *RouteDomainAPIService) GetRouteDomainConfigVrfAllocationStrategyExecute(r RouteDomainAPIGetRouteDomainConfigVrfAllocationStrategyRequest) (*ManualVrfAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualVrfAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomainConfigVrfAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/vrf-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIGetRouteDomainsRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	filterLabel *[]string
	filterName *[]string
	filterFabricId *[]string
	filterInfrastructureId *[]string
	filterServiceStatus *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r RouteDomainAPIGetRouteDomainsRequest) Page(page float32) RouteDomainAPIGetRouteDomainsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** -1   If provided value is greater than max value, max value will be applied. 
func (r RouteDomainAPIGetRouteDomainsRequest) Limit(limit float32) RouteDomainAPIGetRouteDomainsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$eq:John Doe&amp;filter.id&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterId(filterId []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.  **Format:** filter.kind&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.kind&#x3D;$eq:John Doe&amp;filter.kind&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterKind(filterKind []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterKind = &filterKind
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterLabel(filterLabel []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.  **Format:** filter.name&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.name&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterName(filterName []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterName = &filterName
	return r
}

// Filter by fabricId query param.  **Format:** filter.fabricId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.fabricId&#x3D;$eq:John Doe&amp;filter.fabricId&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterFabricId(filterFabricId []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterFabricId = &filterFabricId
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$eq:John Doe&amp;filter.infrastructureId&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $not  - $null  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterInfrastructureId(filterInfrastructureId []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe&amp;filter.serviceStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterServiceStatus(filterServiceStatus []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r RouteDomainAPIGetRouteDomainsRequest) FilterConfigDeployType(filterConfigDeployType []string) RouteDomainAPIGetRouteDomainsRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC   **Default Value:** id:ASC  **Available Fields** - id 
func (r RouteDomainAPIGetRouteDomainsRequest) SortBy(sortBy []string) RouteDomainAPIGetRouteDomainsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r RouteDomainAPIGetRouteDomainsRequest) Search(search string) RouteDomainAPIGetRouteDomainsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,label,name   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - label  - name 
func (r RouteDomainAPIGetRouteDomainsRequest) SearchBy(searchBy []string) RouteDomainAPIGetRouteDomainsRequest {
	r.searchBy = &searchBy
	return r
}

func (r RouteDomainAPIGetRouteDomainsRequest) Execute() (*PaginatedRouteDomainList, *http.Response, error) {
	return r.ApiService.GetRouteDomainsExecute(r)
}

/*
GetRouteDomains Get all Route Domains

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RouteDomainAPIGetRouteDomainsRequest
*/
func (a *RouteDomainAPIService) GetRouteDomains(ctx context.Context) RouteDomainAPIGetRouteDomainsRequest {
	return RouteDomainAPIGetRouteDomainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRouteDomainList
func (a *RouteDomainAPIService) GetRouteDomainsExecute(r RouteDomainAPIGetRouteDomainsRequest) (*PaginatedRouteDomainList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRouteDomainList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.GetRouteDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterFabricId != nil {
		t := *r.filterFabricId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createVlanAllocationStrategy *CreateVlanAllocationStrategy
}

// Entity tag
func (r RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest) CreateVlanAllocationStrategy(createVlanAllocationStrategy CreateVlanAllocationStrategy) RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest {
	r.createVlanAllocationStrategy = &createVlanAllocationStrategy
	return r
}

func (r RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest) Execute() (*VlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceRouteDomainConfigL3VlanAllocationStrategyExecute(r)
}

/*
ReplaceRouteDomainConfigL3VlanAllocationStrategy Replace L3 Vlan allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) ReplaceRouteDomainConfigL3VlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest {
	return RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VlanAllocationStrategy
func (a *RouteDomainAPIService) ReplaceRouteDomainConfigL3VlanAllocationStrategyExecute(r RouteDomainAPIReplaceRouteDomainConfigL3VlanAllocationStrategyRequest) (*VlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.ReplaceRouteDomainConfigL3VlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVlanAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVlanAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVlanAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createVniAllocationStrategy *CreateVniAllocationStrategy
}

// Entity tag
func (r RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest) CreateVniAllocationStrategy(createVniAllocationStrategy CreateVniAllocationStrategy) RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest {
	r.createVniAllocationStrategy = &createVniAllocationStrategy
	return r
}

func (r RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest) Execute() (*VniAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceRouteDomainConfigL3VniAllocationStrategyExecute(r)
}

/*
ReplaceRouteDomainConfigL3VniAllocationStrategy Replace L3 Vni allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) ReplaceRouteDomainConfigL3VniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest {
	return RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return VniAllocationStrategy
func (a *RouteDomainAPIService) ReplaceRouteDomainConfigL3VniAllocationStrategyExecute(r RouteDomainAPIReplaceRouteDomainConfigL3VniAllocationStrategyRequest) (*VniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.ReplaceRouteDomainConfigL3VniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/l3-vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createVniAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createVniAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createVniAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
	createManualVrfAllocationStrategy *CreateManualVrfAllocationStrategy
}

// Entity tag
func (r RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest) IfMatch(ifMatch string) RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest) CreateManualVrfAllocationStrategy(createManualVrfAllocationStrategy CreateManualVrfAllocationStrategy) RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest {
	r.createManualVrfAllocationStrategy = &createManualVrfAllocationStrategy
	return r
}

func (r RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest) Execute() (*ManualVrfAllocationStrategy, *http.Response, error) {
	return r.ApiService.ReplaceRouteDomainConfigVrfAllocationStrategyExecute(r)
}

/*
ReplaceRouteDomainConfigVrfAllocationStrategy Replace Vrf allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest
*/
func (a *RouteDomainAPIService) ReplaceRouteDomainConfigVrfAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest {
	return RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return ManualVrfAllocationStrategy
func (a *RouteDomainAPIService) ReplaceRouteDomainConfigVrfAllocationStrategyExecute(r RouteDomainAPIReplaceRouteDomainConfigVrfAllocationStrategyRequest) (*ManualVrfAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualVrfAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.ReplaceRouteDomainConfigVrfAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config/vrf-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.createManualVrfAllocationStrategy == nil {
		return localVarReturnValue, nil, reportError("createManualVrfAllocationStrategy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.createManualVrfAllocationStrategy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIUpdateRouteDomainRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	ifMatch *string
	updateRouteDomain *UpdateRouteDomain
}

// Entity tag
func (r RouteDomainAPIUpdateRouteDomainRequest) IfMatch(ifMatch string) RouteDomainAPIUpdateRouteDomainRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIUpdateRouteDomainRequest) UpdateRouteDomain(updateRouteDomain UpdateRouteDomain) RouteDomainAPIUpdateRouteDomainRequest {
	r.updateRouteDomain = &updateRouteDomain
	return r
}

func (r RouteDomainAPIUpdateRouteDomainRequest) Execute() (*RouteDomain, *http.Response, error) {
	return r.ApiService.UpdateRouteDomainExecute(r)
}

/*
UpdateRouteDomain Update Route Domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIUpdateRouteDomainRequest
*/
func (a *RouteDomainAPIService) UpdateRouteDomain(ctx context.Context, id float32) RouteDomainAPIUpdateRouteDomainRequest {
	return RouteDomainAPIUpdateRouteDomainRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteDomain
func (a *RouteDomainAPIService) UpdateRouteDomainExecute(r RouteDomainAPIUpdateRouteDomainRequest) (*RouteDomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteDomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.UpdateRouteDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.updateRouteDomain == nil {
		return localVarReturnValue, nil, reportError("updateRouteDomain is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.updateRouteDomain
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RouteDomainAPIUpdateRouteDomainConfigRequest struct {
	ctx context.Context
	ApiService *RouteDomainAPIService
	id float32
	ifMatch *string
	body *map[string]interface{}
}

// Entity tag
func (r RouteDomainAPIUpdateRouteDomainConfigRequest) IfMatch(ifMatch string) RouteDomainAPIUpdateRouteDomainConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r RouteDomainAPIUpdateRouteDomainConfigRequest) Body(body map[string]interface{}) RouteDomainAPIUpdateRouteDomainConfigRequest {
	r.body = &body
	return r
}

func (r RouteDomainAPIUpdateRouteDomainConfigRequest) Execute() (*RouteDomainConfig, *http.Response, error) {
	return r.ApiService.UpdateRouteDomainConfigExecute(r)
}

/*
UpdateRouteDomainConfig Update Route Domain config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return RouteDomainAPIUpdateRouteDomainConfigRequest
*/
func (a *RouteDomainAPIService) UpdateRouteDomainConfig(ctx context.Context, id float32) RouteDomainAPIUpdateRouteDomainConfigRequest {
	return RouteDomainAPIUpdateRouteDomainConfigRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteDomainConfig
func (a *RouteDomainAPIService) UpdateRouteDomainConfigExecute(r RouteDomainAPIUpdateRouteDomainConfigRequest) (*RouteDomainConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteDomainConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RouteDomainAPIService.UpdateRouteDomainConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/route-domains/{id}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifMatch == nil {
		return localVarReturnValue, nil, reportError("ifMatch is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
