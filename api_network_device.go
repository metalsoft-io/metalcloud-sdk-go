/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// NetworkDeviceAPIService NetworkDeviceAPI service
type NetworkDeviceAPIService service

type NetworkDeviceAPIAddNetworkDeviceDefaultsRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	createNetworkDeviceDefaults *CreateNetworkDeviceDefaults
}

// Network device defaults
func (r NetworkDeviceAPIAddNetworkDeviceDefaultsRequest) CreateNetworkDeviceDefaults(createNetworkDeviceDefaults CreateNetworkDeviceDefaults) NetworkDeviceAPIAddNetworkDeviceDefaultsRequest {
	r.createNetworkDeviceDefaults = &createNetworkDeviceDefaults
	return r
}

func (r NetworkDeviceAPIAddNetworkDeviceDefaultsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddNetworkDeviceDefaultsExecute(r)
}

/*
AddNetworkDeviceDefaults Add network device defaults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkDeviceAPIAddNetworkDeviceDefaultsRequest
*/
func (a *NetworkDeviceAPIService) AddNetworkDeviceDefaults(ctx context.Context) NetworkDeviceAPIAddNetworkDeviceDefaultsRequest {
	return NetworkDeviceAPIAddNetworkDeviceDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) AddNetworkDeviceDefaultsExecute(r NetworkDeviceAPIAddNetworkDeviceDefaultsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.AddNetworkDeviceDefaults")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNetworkDeviceDefaults == nil {
		return nil, reportError("createNetworkDeviceDefaults is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkDeviceDefaults
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIChangeNetworkDeviceStatusRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	networkDeviceStatus *NetworkDeviceStatus
}

// Network device status
func (r NetworkDeviceAPIChangeNetworkDeviceStatusRequest) NetworkDeviceStatus(networkDeviceStatus NetworkDeviceStatus) NetworkDeviceAPIChangeNetworkDeviceStatusRequest {
	r.networkDeviceStatus = &networkDeviceStatus
	return r
}

func (r NetworkDeviceAPIChangeNetworkDeviceStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChangeNetworkDeviceStatusExecute(r)
}

/*
ChangeNetworkDeviceStatus Change status of a network device

Change status of a network device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId Network device ID
 @return NetworkDeviceAPIChangeNetworkDeviceStatusRequest
*/
func (a *NetworkDeviceAPIService) ChangeNetworkDeviceStatus(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIChangeNetworkDeviceStatusRequest {
	return NetworkDeviceAPIChangeNetworkDeviceStatusRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) ChangeNetworkDeviceStatusExecute(r NetworkDeviceAPIChangeNetworkDeviceStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.ChangeNetworkDeviceStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/actions/change-status"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkDeviceStatus == nil {
		return nil, reportError("networkDeviceStatus is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkDeviceStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIDiscoverNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	body *map[string]interface{}
}

func (r NetworkDeviceAPIDiscoverNetworkDeviceRequest) Body(body map[string]interface{}) NetworkDeviceAPIDiscoverNetworkDeviceRequest {
	r.body = &body
	return r
}

func (r NetworkDeviceAPIDiscoverNetworkDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DiscoverNetworkDeviceExecute(r)
}

/*
DiscoverNetworkDevice Discover network device interfaces, hardware and software configuration

Discover network device interfaces, hardware and software configuration and return them and/or persist them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId Network device identifier
 @return NetworkDeviceAPIDiscoverNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) DiscoverNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIDiscoverNetworkDeviceRequest {
	return NetworkDeviceAPIDiscoverNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) DiscoverNetworkDeviceExecute(r NetworkDeviceAPIDiscoverNetworkDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.DiscoverNetworkDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/actions/discover"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIEnableNetworkDeviceSyslogRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPIEnableNetworkDeviceSyslogRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableNetworkDeviceSyslogExecute(r)
}

/*
EnableNetworkDeviceSyslog Enables remote syslog for a network device

Enables remote syslog for a network device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId Network device ID
 @return NetworkDeviceAPIEnableNetworkDeviceSyslogRequest
*/
func (a *NetworkDeviceAPIService) EnableNetworkDeviceSyslog(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIEnableNetworkDeviceSyslogRequest {
	return NetworkDeviceAPIEnableNetworkDeviceSyslogRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) EnableNetworkDeviceSyslogExecute(r NetworkDeviceAPIEnableNetworkDeviceSyslogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.EnableNetworkDeviceSyslog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/actions/syslog-subscribe"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIGetNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPIGetNetworkDeviceRequest) Execute() (*NetworkDevice, *http.Response, error) {
	return r.ApiService.GetNetworkDeviceExecute(r)
}

/*
GetNetworkDevice Get Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPIGetNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) GetNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIGetNetworkDeviceRequest {
	return NetworkDeviceAPIGetNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return NetworkDevice
func (a *NetworkDeviceAPIService) GetNetworkDeviceExecute(r NetworkDeviceAPIGetNetworkDeviceRequest) (*NetworkDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.GetNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPIGetNetworkDeviceDefaultsRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	datacenterName string
}

func (r NetworkDeviceAPIGetNetworkDeviceDefaultsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNetworkDeviceDefaultsExecute(r)
}

/*
GetNetworkDeviceDefaults Get network device defaults for a datacenter

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param datacenterName
 @return NetworkDeviceAPIGetNetworkDeviceDefaultsRequest
*/
func (a *NetworkDeviceAPIService) GetNetworkDeviceDefaults(ctx context.Context, datacenterName string) NetworkDeviceAPIGetNetworkDeviceDefaultsRequest {
	return NetworkDeviceAPIGetNetworkDeviceDefaultsRequest{
		ApiService: a,
		ctx: ctx,
		datacenterName: datacenterName,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *NetworkDeviceAPIService) GetNetworkDeviceDefaultsExecute(r NetworkDeviceAPIGetNetworkDeviceDefaultsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.GetNetworkDeviceDefaults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/defaults/{datacenterName}"
	localVarPath = strings.Replace(localVarPath, "{"+"datacenterName"+"}", url.PathEscape(parameterValueToString(r.datacenterName, "datacenterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPIGetNetworkDeviceInventoryPortsRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPIGetNetworkDeviceInventoryPortsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNetworkDeviceInventoryPortsExecute(r)
}

/*
GetNetworkDeviceInventoryPorts Get all ports for network device from the inventory (cached)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPIGetNetworkDeviceInventoryPortsRequest
*/
func (a *NetworkDeviceAPIService) GetNetworkDeviceInventoryPorts(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIGetNetworkDeviceInventoryPortsRequest {
	return NetworkDeviceAPIGetNetworkDeviceInventoryPortsRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) GetNetworkDeviceInventoryPortsExecute(r NetworkDeviceAPIGetNetworkDeviceInventoryPortsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.GetNetworkDeviceInventoryPorts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/ports"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIGetNetworkDevicePortsRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPIGetNetworkDevicePortsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNetworkDevicePortsExecute(r)
}

/*
GetNetworkDevicePorts Get port statistics for network device directly from the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPIGetNetworkDevicePortsRequest
*/
func (a *NetworkDeviceAPIService) GetNetworkDevicePorts(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIGetNetworkDevicePortsRequest {
	return NetworkDeviceAPIGetNetworkDevicePortsRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) GetNetworkDevicePortsExecute(r NetworkDeviceAPIGetNetworkDevicePortsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.GetNetworkDevicePorts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/actions/ports"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIGetNetworkDevicesRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	page *float32
	limit *float32
	filterSwitchId *[]string
	filterStatus *[]string
	filterDatacenterName *[]string
	filterChassisIdentifier *[]string
	filterManagementAddress *[]string
	filterManagementPort *[]string
	filterProvisionerType *[]string
	filterPosition *[]string
	filterIdentifierString *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r NetworkDeviceAPIGetNetworkDevicesRequest) Page(page float32) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r NetworkDeviceAPIGetNetworkDevicesRequest) Limit(limit float32) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.limit = &limit
	return r
}

// Filter by switchId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.switchId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.switchId&#x3D;$not:$like:John Doe&amp;filter.switchId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterSwitchId(filterSwitchId []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterSwitchId = &filterSwitchId
	return r
}

// Filter by status query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.status&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.status&#x3D;$not:$like:John Doe&amp;filter.status&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterStatus(filterStatus []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterStatus = &filterStatus
	return r
}

// Filter by datacenterName query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.datacenterName&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.datacenterName&#x3D;$not:$like:John Doe&amp;filter.datacenterName&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterDatacenterName(filterDatacenterName []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterDatacenterName = &filterDatacenterName
	return r
}

// Filter by chassisIdentifier query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.chassisIdentifier&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.chassisIdentifier&#x3D;$not:$like:John Doe&amp;filter.chassisIdentifier&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterChassisIdentifier(filterChassisIdentifier []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterChassisIdentifier = &filterChassisIdentifier
	return r
}

// Filter by managementAddress query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.managementAddress&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.managementAddress&#x3D;$not:$like:John Doe&amp;filter.managementAddress&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterManagementAddress(filterManagementAddress []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterManagementAddress = &filterManagementAddress
	return r
}

// Filter by managementPort query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.managementPort&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.managementPort&#x3D;$not:$like:John Doe&amp;filter.managementPort&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterManagementPort(filterManagementPort []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterManagementPort = &filterManagementPort
	return r
}

// Filter by provisionerType query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.provisionerType&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.provisionerType&#x3D;$not:$like:John Doe&amp;filter.provisionerType&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterProvisionerType(filterProvisionerType []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterProvisionerType = &filterProvisionerType
	return r
}

// Filter by position query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.position&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.position&#x3D;$not:$like:John Doe&amp;filter.position&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterPosition(filterPosition []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterPosition = &filterPosition
	return r
}

// Filter by identifierString query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.identifierString&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.identifierString&#x3D;$not:$like:John Doe&amp;filter.identifierString&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r NetworkDeviceAPIGetNetworkDevicesRequest) FilterIdentifierString(filterIdentifierString []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.filterIdentifierString = &filterIdentifierString
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; switchId:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;switchId&lt;/li&gt; &lt;li&gt;status&lt;/li&gt; &lt;li&gt;datacenterName&lt;/li&gt; &lt;li&gt;status&lt;/li&gt; &lt;li&gt;position&lt;/li&gt;&lt;/ul&gt;       
func (r NetworkDeviceAPIGetNetworkDevicesRequest) SortBy(sortBy []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r NetworkDeviceAPIGetNetworkDevicesRequest) Search(search string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; switchId,status,datacenterName,managementAddress,provisionerType           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;switchId&lt;/li&gt; &lt;li&gt;status&lt;/li&gt; &lt;li&gt;datacenterName&lt;/li&gt; &lt;li&gt;managementAddress&lt;/li&gt; &lt;li&gt;provisionerType&lt;/li&gt; &lt;li&gt;position&lt;/li&gt;&lt;/ul&gt;         
func (r NetworkDeviceAPIGetNetworkDevicesRequest) SearchBy(searchBy []string) NetworkDeviceAPIGetNetworkDevicesRequest {
	r.searchBy = &searchBy
	return r
}

func (r NetworkDeviceAPIGetNetworkDevicesRequest) Execute() (*NetworkDevicePaginatedList, *http.Response, error) {
	return r.ApiService.GetNetworkDevicesExecute(r)
}

/*
GetNetworkDevices Get paginated Network Devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkDeviceAPIGetNetworkDevicesRequest
*/
func (a *NetworkDeviceAPIService) GetNetworkDevices(ctx context.Context) NetworkDeviceAPIGetNetworkDevicesRequest {
	return NetworkDeviceAPIGetNetworkDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NetworkDevicePaginatedList
func (a *NetworkDeviceAPIService) GetNetworkDevicesExecute(r NetworkDeviceAPIGetNetworkDevicesRequest) (*NetworkDevicePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkDevicePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.GetNetworkDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterSwitchId != nil {
		t := *r.filterSwitchId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.switchId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.switchId", t, "form", "multi")
		}
	}
	if r.filterStatus != nil {
		t := *r.filterStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.status", t, "form", "multi")
		}
	}
	if r.filterDatacenterName != nil {
		t := *r.filterDatacenterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.datacenterName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.datacenterName", t, "form", "multi")
		}
	}
	if r.filterChassisIdentifier != nil {
		t := *r.filterChassisIdentifier
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.chassisIdentifier", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.chassisIdentifier", t, "form", "multi")
		}
	}
	if r.filterManagementAddress != nil {
		t := *r.filterManagementAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.managementAddress", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.managementAddress", t, "form", "multi")
		}
	}
	if r.filterManagementPort != nil {
		t := *r.filterManagementPort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.managementPort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.managementPort", t, "form", "multi")
		}
	}
	if r.filterProvisionerType != nil {
		t := *r.filterProvisionerType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.provisionerType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.provisionerType", t, "form", "multi")
		}
	}
	if r.filterPosition != nil {
		t := *r.filterPosition
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.position", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.position", t, "form", "multi")
		}
	}
	if r.filterIdentifierString != nil {
		t := *r.filterIdentifierString
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.identifierString", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.identifierString", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	networkDeviceControllerUpdateTagsForNetworkDeviceRequest *NetworkDeviceControllerUpdateTagsForNetworkDeviceRequest
}

// The tags to add
func (r NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest) NetworkDeviceControllerUpdateTagsForNetworkDeviceRequest(networkDeviceControllerUpdateTagsForNetworkDeviceRequest NetworkDeviceControllerUpdateTagsForNetworkDeviceRequest) NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest {
	r.networkDeviceControllerUpdateTagsForNetworkDeviceRequest = &networkDeviceControllerUpdateTagsForNetworkDeviceRequest
	return r
}

func (r NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.NetworkDeviceControllerAddTagsToNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerAddTagsToNetworkDevice Add tags to Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerAddTagsToNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NetworkDeviceAPIService) NetworkDeviceControllerAddTagsToNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerAddTagsToNetworkDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerAddTagsToNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/network-devices/{networkDeviceId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkDeviceControllerUpdateTagsForNetworkDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("networkDeviceControllerUpdateTagsForNetworkDeviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkDeviceControllerUpdateTagsForNetworkDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	createNetworkDevice *CreateNetworkDevice
}

// The Network Device create object
func (r NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest) CreateNetworkDevice(createNetworkDevice CreateNetworkDevice) NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest {
	r.createNetworkDevice = &createNetworkDevice
	return r
}

func (r NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest) Execute() (*NetworkDevice, *http.Response, error) {
	return r.ApiService.NetworkDeviceControllerCreateNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerCreateNetworkDevice Create Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerCreateNetworkDevice(ctx context.Context) NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NetworkDevice
func (a *NetworkDeviceAPIService) NetworkDeviceControllerCreateNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerCreateNetworkDeviceRequest) (*NetworkDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerCreateNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNetworkDevice == nil {
		return localVarReturnValue, nil, reportError("createNetworkDevice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkDevice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerDecommissionNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPINetworkDeviceControllerDecommissionNetworkDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkDeviceControllerDecommissionNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerDecommissionNetworkDevice Decommission network device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerDecommissionNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerDecommissionNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerDecommissionNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerDecommissionNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) NetworkDeviceControllerDecommissionNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerDecommissionNetworkDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerDecommissionNetworkDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/decommission"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerDeleteNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPINetworkDeviceControllerDeleteNetworkDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkDeviceControllerDeleteNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerDeleteNetworkDevice Delete Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerDeleteNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerDeleteNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerDeleteNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerDeleteNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) NetworkDeviceControllerDeleteNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerDeleteNetworkDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerDeleteNetworkDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerGetIscsiBootServersRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPINetworkDeviceControllerGetIscsiBootServersRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkDeviceControllerGetIscsiBootServersExecute(r)
}

/*
NetworkDeviceControllerGetIscsiBootServers Returns information about servers which are setup to boot from iSCSI block devices. This is useful in the event of a switch device reboot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerGetIscsiBootServersRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerGetIscsiBootServers(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerGetIscsiBootServersRequest {
	return NetworkDeviceAPINetworkDeviceControllerGetIscsiBootServersRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) NetworkDeviceControllerGetIscsiBootServersExecute(r NetworkDeviceAPINetworkDeviceControllerGetIscsiBootServersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerGetIscsiBootServers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/iscsi-boot-servers"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerGetNetworkDeviceStatisticsRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
}

func (r NetworkDeviceAPINetworkDeviceControllerGetNetworkDeviceStatisticsRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkDeviceControllerGetNetworkDeviceStatisticsExecute(r)
}

/*
NetworkDeviceControllerGetNetworkDeviceStatistics Get Network Device Statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkDeviceAPINetworkDeviceControllerGetNetworkDeviceStatisticsRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerGetNetworkDeviceStatistics(ctx context.Context) NetworkDeviceAPINetworkDeviceControllerGetNetworkDeviceStatisticsRequest {
	return NetworkDeviceAPINetworkDeviceControllerGetNetworkDeviceStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) NetworkDeviceControllerGetNetworkDeviceStatisticsExecute(r NetworkDeviceAPINetworkDeviceControllerGetNetworkDeviceStatisticsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerGetNetworkDeviceStatistics")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerGetTagsForNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPINetworkDeviceControllerGetTagsForNetworkDeviceRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.NetworkDeviceControllerGetTagsForNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerGetTagsForNetworkDevice Get tags for Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerGetTagsForNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerGetTagsForNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerGetTagsForNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerGetTagsForNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return []string
func (a *NetworkDeviceAPIService) NetworkDeviceControllerGetTagsForNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerGetTagsForNetworkDeviceRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerGetTagsForNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/network-devices/{networkDeviceId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	body *string
}

// The tags to remove
func (r NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest) Body(body string) NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest {
	r.body = &body
	return r
}

func (r NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkDeviceControllerRemoveTagsFromNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerRemoveTagsFromNetworkDevice Clear tags from Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerRemoveTagsFromNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) NetworkDeviceControllerRemoveTagsFromNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerRemoveTagsFromNetworkDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerRemoveTagsFromNetworkDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/network-devices/{networkDeviceId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerReplaceNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPINetworkDeviceControllerReplaceNetworkDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.NetworkDeviceControllerReplaceNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerReplaceNetworkDevice Replace network device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId Network device ID
 @return NetworkDeviceAPINetworkDeviceControllerReplaceNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerReplaceNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerReplaceNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerReplaceNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NetworkDeviceAPIService) NetworkDeviceControllerReplaceNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerReplaceNetworkDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerReplaceNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	updateNetworkDevice *UpdateNetworkDevice
}

// The Network Device update object
func (r NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest) UpdateNetworkDevice(updateNetworkDevice UpdateNetworkDevice) NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest {
	r.updateNetworkDevice = &updateNetworkDevice
	return r
}

func (r NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest) Execute() (*NetworkDevice, *http.Response, error) {
	return r.ApiService.NetworkDeviceControllerUpdateNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerUpdateNetworkDevice Update Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerUpdateNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return NetworkDevice
func (a *NetworkDeviceAPIService) NetworkDeviceControllerUpdateNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerUpdateNetworkDeviceRequest) (*NetworkDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerUpdateNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateNetworkDevice == nil {
		return localVarReturnValue, nil, reportError("updateNetworkDevice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkDevice
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	networkDeviceControllerUpdateTagsForNetworkDeviceRequest *NetworkDeviceControllerUpdateTagsForNetworkDeviceRequest
}

// The tags to update
func (r NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest) NetworkDeviceControllerUpdateTagsForNetworkDeviceRequest(networkDeviceControllerUpdateTagsForNetworkDeviceRequest NetworkDeviceControllerUpdateTagsForNetworkDeviceRequest) NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest {
	r.networkDeviceControllerUpdateTagsForNetworkDeviceRequest = &networkDeviceControllerUpdateTagsForNetworkDeviceRequest
	return r
}

func (r NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.NetworkDeviceControllerUpdateTagsForNetworkDeviceExecute(r)
}

/*
NetworkDeviceControllerUpdateTagsForNetworkDevice Update tags for Network Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId
 @return NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) NetworkDeviceControllerUpdateTagsForNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest {
	return NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NetworkDeviceAPIService) NetworkDeviceControllerUpdateTagsForNetworkDeviceExecute(r NetworkDeviceAPINetworkDeviceControllerUpdateTagsForNetworkDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.NetworkDeviceControllerUpdateTagsForNetworkDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/network-devices/{networkDeviceId}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkDeviceControllerUpdateTagsForNetworkDeviceRequest == nil {
		return localVarReturnValue, nil, reportError("networkDeviceControllerUpdateTagsForNetworkDeviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkDeviceControllerUpdateTagsForNetworkDeviceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPIReProvisionNetworkEquipmentRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	body *map[string]interface{}
}

// The network equipment re-provision options
func (r NetworkDeviceAPIReProvisionNetworkEquipmentRequest) Body(body map[string]interface{}) NetworkDeviceAPIReProvisionNetworkEquipmentRequest {
	r.body = &body
	return r
}

func (r NetworkDeviceAPIReProvisionNetworkEquipmentRequest) Execute() (*JobInfo, *http.Response, error) {
	return r.ApiService.ReProvisionNetworkEquipmentExecute(r)
}

/*
ReProvisionNetworkEquipment Re-provision network equipment

Re-provision network equipment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkDeviceAPIReProvisionNetworkEquipmentRequest
*/
func (a *NetworkDeviceAPIService) ReProvisionNetworkEquipment(ctx context.Context) NetworkDeviceAPIReProvisionNetworkEquipmentRequest {
	return NetworkDeviceAPIReProvisionNetworkEquipmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobInfo
func (a *NetworkDeviceAPIService) ReProvisionNetworkEquipmentExecute(r NetworkDeviceAPIReProvisionNetworkEquipmentRequest) (*JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.ReProvisionNetworkEquipment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/re-provision"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	requestBody *[]float32
}

// Network device defaults IDs
func (r NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest) RequestBody(requestBody []float32) NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest {
	r.requestBody = &requestBody
	return r
}

func (r NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveNetworkDeviceDefaultsExecute(r)
}

/*
RemoveNetworkDeviceDefaults Remove network device defaults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest
*/
func (a *NetworkDeviceAPIService) RemoveNetworkDeviceDefaults(ctx context.Context) NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest {
	return NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) RemoveNetworkDeviceDefaultsExecute(r NetworkDeviceAPIRemoveNetworkDeviceDefaultsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.RemoveNetworkDeviceDefaults")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPIResetNetworkDeviceRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
}

func (r NetworkDeviceAPIResetNetworkDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResetNetworkDeviceExecute(r)
}

/*
ResetNetworkDevice Resets a network device to default state

Resets a network device to default state and destroy all configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId Network device ID
 @return NetworkDeviceAPIResetNetworkDeviceRequest
*/
func (a *NetworkDeviceAPIService) ResetNetworkDevice(ctx context.Context, networkDeviceId float32) NetworkDeviceAPIResetNetworkDeviceRequest {
	return NetworkDeviceAPIResetNetworkDeviceRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) ResetNetworkDeviceExecute(r NetworkDeviceAPIResetNetworkDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.ResetNetworkDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/actions/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type NetworkDeviceAPISetNetworkDevicePortStatusRequest struct {
	ctx context.Context
	ApiService *NetworkDeviceAPIService
	networkDeviceId float32
	networkDevicePortStatus *NetworkDevicePortStatus
}

// Port status
func (r NetworkDeviceAPISetNetworkDevicePortStatusRequest) NetworkDevicePortStatus(networkDevicePortStatus NetworkDevicePortStatus) NetworkDeviceAPISetNetworkDevicePortStatusRequest {
	r.networkDevicePortStatus = &networkDevicePortStatus
	return r
}

func (r NetworkDeviceAPISetNetworkDevicePortStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetNetworkDevicePortStatusExecute(r)
}

/*
SetNetworkDevicePortStatus Set port status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkDeviceId Network device ID
 @return NetworkDeviceAPISetNetworkDevicePortStatusRequest
*/
func (a *NetworkDeviceAPIService) SetNetworkDevicePortStatus(ctx context.Context, networkDeviceId float32) NetworkDeviceAPISetNetworkDevicePortStatusRequest {
	return NetworkDeviceAPISetNetworkDevicePortStatusRequest{
		ApiService: a,
		ctx: ctx,
		networkDeviceId: networkDeviceId,
	}
}

// Execute executes the request
func (a *NetworkDeviceAPIService) SetNetworkDevicePortStatusExecute(r NetworkDeviceAPISetNetworkDevicePortStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkDeviceAPIService.SetNetworkDevicePortStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/network-devices/{networkDeviceId}/actions/set-port-status"
	localVarPath = strings.Replace(localVarPath, "{"+"networkDeviceId"+"}", url.PathEscape(parameterValueToString(r.networkDeviceId, "networkDeviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkDevicePortStatus == nil {
		return nil, reportError("networkDevicePortStatus is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkDevicePortStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
