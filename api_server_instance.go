/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ServerInstanceAPIService ServerInstanceAPI service
type ServerInstanceAPIService service

type ServerInstanceAPICreateServerInstanceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	infrastructureId int32
	serverInstanceCreate *ServerInstanceCreate
}

// The Server Instance to create
func (r ServerInstanceAPICreateServerInstanceRequest) ServerInstanceCreate(serverInstanceCreate ServerInstanceCreate) ServerInstanceAPICreateServerInstanceRequest {
	r.serverInstanceCreate = &serverInstanceCreate
	return r
}

func (r ServerInstanceAPICreateServerInstanceRequest) Execute() (*ServerInstance, *http.Response, error) {
	return r.ApiService.CreateServerInstanceExecute(r)
}

/*
CreateServerInstance Add Server Instance to an infrastructure

Adds Server Instance to the specified infrastructure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return ServerInstanceAPICreateServerInstanceRequest
*/
func (a *ServerInstanceAPIService) CreateServerInstance(ctx context.Context, infrastructureId int32) ServerInstanceAPICreateServerInstanceRequest {
	return ServerInstanceAPICreateServerInstanceRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return ServerInstance
func (a *ServerInstanceAPIService) CreateServerInstanceExecute(r ServerInstanceAPICreateServerInstanceRequest) (*ServerInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.CreateServerInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/server-instances"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstanceCreate == nil {
		return localVarReturnValue, nil, reportError("serverInstanceCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serverInstanceCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIDeleteServerInstanceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	ifMatch *string
}

// Entity tag
func (r ServerInstanceAPIDeleteServerInstanceRequest) IfMatch(ifMatch string) ServerInstanceAPIDeleteServerInstanceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceAPIDeleteServerInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServerInstanceExecute(r)
}

/*
DeleteServerInstance Delete Server Instance

Deletes the specified Server Instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIDeleteServerInstanceRequest
*/
func (a *ServerInstanceAPIService) DeleteServerInstance(ctx context.Context, serverInstanceId int32) ServerInstanceAPIDeleteServerInstanceRequest {
	return ServerInstanceAPIDeleteServerInstanceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) DeleteServerInstanceExecute(r ServerInstanceAPIDeleteServerInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.DeleteServerInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceAPIGetInfrastructureServerInstancesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	infrastructureId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterGroupId *[]string
	filterServerId *[]string
	filterServiceStatus *[]string
	filterConfigServerId *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) Page(page float32) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) Limit(limit float32) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterInfrastructureId(filterInfrastructureId []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by groupId query param.  **Format:** filter.groupId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.groupId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterGroupId(filterGroupId []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterGroupId = &filterGroupId
	return r
}

// Filter by serverId query param.  **Format:** filter.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serverId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterServerId(filterServerId []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterServiceStatus(filterServiceStatus []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.serverId query param.  **Format:** filter.config.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.serverId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterConfigServerId(filterConfigServerId []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterConfigServerId = &filterConfigServerId
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) FilterConfigDeployType(filterConfigDeployType []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;label:DESC   **Default Value:** id:DESC  **Available Fields** - id  - label 
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) SortBy(sortBy []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) Search(search string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** label   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - label 
func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) SearchBy(searchBy []string) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerInstanceAPIGetInfrastructureServerInstancesRequest) Execute() (*ServerInstancePaginatedList, *http.Response, error) {
	return r.ApiService.GetInfrastructureServerInstancesExecute(r)
}

/*
GetInfrastructureServerInstances List Server Instances for an infrastructure

Returns list of Server Instances in the specified infrastructure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return ServerInstanceAPIGetInfrastructureServerInstancesRequest
*/
func (a *ServerInstanceAPIService) GetInfrastructureServerInstances(ctx context.Context, infrastructureId int32) ServerInstanceAPIGetInfrastructureServerInstancesRequest {
	return ServerInstanceAPIGetInfrastructureServerInstancesRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return ServerInstancePaginatedList
func (a *ServerInstanceAPIService) GetInfrastructureServerInstancesExecute(r ServerInstanceAPIGetInfrastructureServerInstancesRequest) (*ServerInstancePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstancePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetInfrastructureServerInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/server-instances"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterGroupId != nil {
		t := *r.filterGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigServerId != nil {
		t := *r.filterConfigServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.serverId", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetPowerFromServerInstanceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
}

func (r ServerInstanceAPIGetPowerFromServerInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPowerFromServerInstanceExecute(r)
}

/*
GetPowerFromServerInstance Get the power status of the Server Instance

Get the power status of the Server Instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetPowerFromServerInstanceRequest
*/
func (a *ServerInstanceAPIService) GetPowerFromServerInstance(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetPowerFromServerInstanceRequest {
	return ServerInstanceAPIGetPowerFromServerInstanceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) GetPowerFromServerInstanceExecute(r ServerInstanceAPIGetPowerFromServerInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetPowerFromServerInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/actions/power-get"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceAPIGetPowerStatusBatchRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	infrastructureId int32
	requestBody *[]string
}

// The list of server instance ids
func (r ServerInstanceAPIGetPowerStatusBatchRequest) RequestBody(requestBody []string) ServerInstanceAPIGetPowerStatusBatchRequest {
	r.requestBody = &requestBody
	return r
}

func (r ServerInstanceAPIGetPowerStatusBatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPowerStatusBatchExecute(r)
}

/*
GetPowerStatusBatch Gets power status of multiple servers

Gets the power status of the servers associated with specified instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return ServerInstanceAPIGetPowerStatusBatchRequest
*/
func (a *ServerInstanceAPIService) GetPowerStatusBatch(ctx context.Context, infrastructureId int32) ServerInstanceAPIGetPowerStatusBatchRequest {
	return ServerInstanceAPIGetPowerStatusBatchRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServerInstanceAPIService) GetPowerStatusBatchExecute(r ServerInstanceAPIGetPowerStatusBatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetPowerStatusBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/actions/power-get"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
}

func (r ServerInstanceAPIGetServerInstanceRequest) Execute() (*ServerInstance, *http.Response, error) {
	return r.ApiService.GetServerInstanceExecute(r)
}

/*
GetServerInstance Get Server Instance details

Returns the details of the specified Server Instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceRequest
*/
func (a *ServerInstanceAPIService) GetServerInstance(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceRequest {
	return ServerInstanceAPIGetServerInstanceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstance
func (a *ServerInstanceAPIService) GetServerInstanceExecute(r ServerInstanceAPIGetServerInstanceRequest) (*ServerInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceConfigRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
}

func (r ServerInstanceAPIGetServerInstanceConfigRequest) Execute() (*ServerInstanceConfiguration, *http.Response, error) {
	return r.ApiService.GetServerInstanceConfigExecute(r)
}

/*
GetServerInstanceConfig Get Server Instance config details

Returns the config details of the specified Server Instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceConfigRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceConfig(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceConfigRequest {
	return ServerInstanceAPIGetServerInstanceConfigRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstanceConfiguration
func (a *ServerInstanceAPIService) GetServerInstanceConfigExecute(r ServerInstanceAPIGetServerInstanceConfigRequest) (*ServerInstanceConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceCredentialsRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
}

func (r ServerInstanceAPIGetServerInstanceCredentialsRequest) Execute() (*ServerInstanceCredentials, *http.Response, error) {
	return r.ApiService.GetServerInstanceCredentialsExecute(r)
}

/*
GetServerInstanceCredentials Get Server Instance credentials

Returns the credentials for various protocols including the IPs allocated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceCredentialsRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceCredentials(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceCredentialsRequest {
	return ServerInstanceAPIGetServerInstanceCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstanceCredentials
func (a *ServerInstanceAPIService) GetServerInstanceCredentialsExecute(r ServerInstanceAPIGetServerInstanceCredentialsRequest) (*ServerInstanceCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceDrivesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
}

func (r ServerInstanceAPIGetServerInstanceDrivesRequest) Execute() (*DriveList, *http.Response, error) {
	return r.ApiService.GetServerInstanceDrivesExecute(r)
}

/*
GetServerInstanceDrives Get Server Instance Drives

Returns the drives

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceDrivesRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceDrives(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceDrivesRequest {
	return ServerInstanceAPIGetServerInstanceDrivesRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return DriveList
func (a *ServerInstanceAPIService) GetServerInstanceDrivesExecute(r ServerInstanceAPIGetServerInstanceDrivesRequest) (*DriveList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DriveList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceDrives")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/drives"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceInterfaceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	interfaceId int32
}

func (r ServerInstanceAPIGetServerInstanceInterfaceRequest) Execute() (*ServerInstanceInterface, *http.Response, error) {
	return r.ApiService.GetServerInstanceInterfaceExecute(r)
}

/*
GetServerInstanceInterface Get Server Instance Interface details

Returns the details of the specified Server Instance Interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @param interfaceId
 @return ServerInstanceAPIGetServerInstanceInterfaceRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceInterface(ctx context.Context, serverInstanceId int32, interfaceId int32) ServerInstanceAPIGetServerInstanceInterfaceRequest {
	return ServerInstanceAPIGetServerInstanceInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ServerInstanceInterface
func (a *ServerInstanceAPIService) GetServerInstanceInterfaceExecute(r ServerInstanceAPIGetServerInstanceInterfaceRequest) (*ServerInstanceInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/interfaces/{interfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceInterfacesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterServiceStatus *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) Page(page float32) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) Limit(limit float32) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) FilterInfrastructureId(filterInfrastructureId []string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) FilterServiceStatus(filterServiceStatus []string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) FilterConfigDeployType(filterConfigDeployType []string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;infrastructureId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - infrastructureId  - serviceStatus  - config.deployStatus  - config.deployType 
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) SortBy(sortBy []string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) Search(search string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,label,subdomain,subdomainPermanent,infrastructureId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - label  - subdomain  - subdomainPermanent  - infrastructureId  - serviceStatus  - config.deployStatus  - config.deployType 
func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) SearchBy(searchBy []string) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerInstanceAPIGetServerInstanceInterfacesRequest) Execute() (*ServerInstanceInterfacePaginatedList, *http.Response, error) {
	return r.ApiService.GetServerInstanceInterfacesExecute(r)
}

/*
GetServerInstanceInterfaces Get Server Instance Interfaces

Returns the interfaces for the specified Server Instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceInterfacesRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceInterfaces(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceInterfacesRequest {
	return ServerInstanceAPIGetServerInstanceInterfacesRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstanceInterfacePaginatedList
func (a *ServerInstanceAPIService) GetServerInstanceInterfacesExecute(r ServerInstanceAPIGetServerInstanceInterfacesRequest) (*ServerInstanceInterfacePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceInterfacePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceOSInstallationDataRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	usage *VariableUsageType
	removeEmpty *int32
}

// Filter by variable usage
func (r ServerInstanceAPIGetServerInstanceOSInstallationDataRequest) Usage(usage VariableUsageType) ServerInstanceAPIGetServerInstanceOSInstallationDataRequest {
	r.usage = &usage
	return r
}

// Remove empty fields from the response
func (r ServerInstanceAPIGetServerInstanceOSInstallationDataRequest) RemoveEmpty(removeEmpty int32) ServerInstanceAPIGetServerInstanceOSInstallationDataRequest {
	r.removeEmpty = &removeEmpty
	return r
}

func (r ServerInstanceAPIGetServerInstanceOSInstallationDataRequest) Execute() (*ServerInstanceContextOSInstallationData, *http.Response, error) {
	return r.ApiService.GetServerInstanceOSInstallationDataExecute(r)
}

/*
GetServerInstanceOSInstallationData Get server instance OS installation data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceOSInstallationDataRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceOSInstallationData(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceOSInstallationDataRequest {
	return ServerInstanceAPIGetServerInstanceOSInstallationDataRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstanceContextOSInstallationData
func (a *ServerInstanceAPIService) GetServerInstanceOSInstallationDataExecute(r ServerInstanceAPIGetServerInstanceOSInstallationDataRequest) (*ServerInstanceContextOSInstallationData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceContextOSInstallationData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceOSInstallationData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/os-installation-data"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.usage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage", r.usage, "form", "")
	}
	if r.removeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeEmpty", r.removeEmpty, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceStatisticsRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
}

func (r ServerInstanceAPIGetServerInstanceStatisticsRequest) Execute() (*ServerInstanceStatistics, *http.Response, error) {
	return r.ApiService.GetServerInstanceStatisticsExecute(r)
}

/*
GetServerInstanceStatistics Get Server Instance counters

Returns the statistics related to server instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ServerInstanceAPIGetServerInstanceStatisticsRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceStatistics(ctx context.Context) ServerInstanceAPIGetServerInstanceStatisticsRequest {
	return ServerInstanceAPIGetServerInstanceStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServerInstanceStatistics
func (a *ServerInstanceAPIService) GetServerInstanceStatisticsExecute(r ServerInstanceAPIGetServerInstanceStatisticsRequest) (*ServerInstanceStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstanceVariablesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	usage *VariableUsageType
}

// Filter by variable usage
func (r ServerInstanceAPIGetServerInstanceVariablesRequest) Usage(usage VariableUsageType) ServerInstanceAPIGetServerInstanceVariablesRequest {
	r.usage = &usage
	return r
}

func (r ServerInstanceAPIGetServerInstanceVariablesRequest) Execute() (*ServerInstanceContextVariables, *http.Response, error) {
	return r.ApiService.GetServerInstanceVariablesExecute(r)
}

/*
GetServerInstanceVariables Get server instance variables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIGetServerInstanceVariablesRequest
*/
func (a *ServerInstanceAPIService) GetServerInstanceVariables(ctx context.Context, serverInstanceId int32) ServerInstanceAPIGetServerInstanceVariablesRequest {
	return ServerInstanceAPIGetServerInstanceVariablesRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstanceContextVariables
func (a *ServerInstanceAPIService) GetServerInstanceVariablesExecute(r ServerInstanceAPIGetServerInstanceVariablesRequest) (*ServerInstanceContextVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceContextVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstanceVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.usage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage", r.usage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIGetServerInstancesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterGroupId *[]string
	filterServerId *[]string
	filterServiceStatus *[]string
	filterConfigServerId *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r ServerInstanceAPIGetServerInstancesRequest) Page(page float32) ServerInstanceAPIGetServerInstancesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r ServerInstanceAPIGetServerInstancesRequest) Limit(limit float32) ServerInstanceAPIGetServerInstancesRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterInfrastructureId(filterInfrastructureId []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by groupId query param.  **Format:** filter.groupId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.groupId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterGroupId(filterGroupId []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterGroupId = &filterGroupId
	return r
}

// Filter by serverId query param.  **Format:** filter.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serverId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterServerId(filterServerId []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterServiceStatus(filterServiceStatus []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.serverId query param.  **Format:** filter.config.serverId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.serverId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterConfigServerId(filterConfigServerId []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterConfigServerId = &filterConfigServerId
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r ServerInstanceAPIGetServerInstancesRequest) FilterConfigDeployType(filterConfigDeployType []string) ServerInstanceAPIGetServerInstancesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;label:DESC   **Default Value:** id:DESC  **Available Fields** - id  - label 
func (r ServerInstanceAPIGetServerInstancesRequest) SortBy(sortBy []string) ServerInstanceAPIGetServerInstancesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r ServerInstanceAPIGetServerInstancesRequest) Search(search string) ServerInstanceAPIGetServerInstancesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** label   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - label 
func (r ServerInstanceAPIGetServerInstancesRequest) SearchBy(searchBy []string) ServerInstanceAPIGetServerInstancesRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerInstanceAPIGetServerInstancesRequest) Execute() (*ServerInstancePaginatedList, *http.Response, error) {
	return r.ApiService.GetServerInstancesExecute(r)
}

/*
GetServerInstances List Server Instances

Returns list of Server Instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ServerInstanceAPIGetServerInstancesRequest
*/
func (a *ServerInstanceAPIService) GetServerInstances(ctx context.Context) ServerInstanceAPIGetServerInstancesRequest {
	return ServerInstanceAPIGetServerInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServerInstancePaginatedList
func (a *ServerInstanceAPIService) GetServerInstancesExecute(r ServerInstanceAPIGetServerInstancesRequest) (*ServerInstancePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstancePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.GetServerInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterGroupId != nil {
		t := *r.filterGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigServerId != nil {
		t := *r.filterConfigServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.serverId", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIReinstallServerInstanceOSRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	serverInstanceReinstallOS *ServerInstanceReinstallOS
	ifMatch *string
}

// reinstall OS options
func (r ServerInstanceAPIReinstallServerInstanceOSRequest) ServerInstanceReinstallOS(serverInstanceReinstallOS ServerInstanceReinstallOS) ServerInstanceAPIReinstallServerInstanceOSRequest {
	r.serverInstanceReinstallOS = &serverInstanceReinstallOS
	return r
}

// Entity tag
func (r ServerInstanceAPIReinstallServerInstanceOSRequest) IfMatch(ifMatch string) ServerInstanceAPIReinstallServerInstanceOSRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceAPIReinstallServerInstanceOSRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReinstallServerInstanceOSExecute(r)
}

/*
ReinstallServerInstanceOS Manage the flag to reinstall the operating system on the server

Manage the flag to reinstall the operating system on the server. The reinstall operation is executed during the next deploy operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIReinstallServerInstanceOSRequest
*/
func (a *ServerInstanceAPIService) ReinstallServerInstanceOS(ctx context.Context, serverInstanceId int32) ServerInstanceAPIReinstallServerInstanceOSRequest {
	return ServerInstanceAPIReinstallServerInstanceOSRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) ReinstallServerInstanceOSExecute(r ServerInstanceAPIReinstallServerInstanceOSRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.ReinstallServerInstanceOS")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/actions/reinstall-os"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstanceReinstallOS == nil {
		return nil, reportError("serverInstanceReinstallOS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.serverInstanceReinstallOS
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceAPIResetServerInstanceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	ifMatch *string
}

// Entity tag
func (r ServerInstanceAPIResetServerInstanceRequest) IfMatch(ifMatch string) ServerInstanceAPIResetServerInstanceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceAPIResetServerInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResetServerInstanceExecute(r)
}

/*
ResetServerInstance Reset a deployed server

Resets deployed server. The operation is executed immediately.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIResetServerInstanceRequest
*/
func (a *ServerInstanceAPIService) ResetServerInstance(ctx context.Context, serverInstanceId int32) ServerInstanceAPIResetServerInstanceRequest {
	return ServerInstanceAPIResetServerInstanceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) ResetServerInstanceExecute(r ServerInstanceAPIResetServerInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.ResetServerInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/actions/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceAPISetPowerStatusBatchRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	infrastructureId int32
	instancesSetPowerState *InstancesSetPowerState
}

// The list of server instance ids
func (r ServerInstanceAPISetPowerStatusBatchRequest) InstancesSetPowerState(instancesSetPowerState InstancesSetPowerState) ServerInstanceAPISetPowerStatusBatchRequest {
	r.instancesSetPowerState = &instancesSetPowerState
	return r
}

func (r ServerInstanceAPISetPowerStatusBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetPowerStatusBatchExecute(r)
}

/*
SetPowerStatusBatch sets power status of multiple servers

Initiates shutdown or powers on the servers associated with the specified instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return ServerInstanceAPISetPowerStatusBatchRequest
*/
func (a *ServerInstanceAPIService) SetPowerStatusBatch(ctx context.Context, infrastructureId int32) ServerInstanceAPISetPowerStatusBatchRequest {
	return ServerInstanceAPISetPowerStatusBatchRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) SetPowerStatusBatchExecute(r ServerInstanceAPISetPowerStatusBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.SetPowerStatusBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/actions/power-set"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instancesSetPowerState == nil {
		return nil, reportError("instancesSetPowerState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.instancesSetPowerState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceAPISetPowerToServerInstanceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	serverInstancePowerSet *ServerInstancePowerSet
	ifMatch *string
}

func (r ServerInstanceAPISetPowerToServerInstanceRequest) ServerInstancePowerSet(serverInstancePowerSet ServerInstancePowerSet) ServerInstanceAPISetPowerToServerInstanceRequest {
	r.serverInstancePowerSet = &serverInstancePowerSet
	return r
}

// Entity tag
func (r ServerInstanceAPISetPowerToServerInstanceRequest) IfMatch(ifMatch string) ServerInstanceAPISetPowerToServerInstanceRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceAPISetPowerToServerInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetPowerToServerInstanceExecute(r)
}

/*
SetPowerToServerInstance Set power to the Server Instance

Set power to this Server Instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPISetPowerToServerInstanceRequest
*/
func (a *ServerInstanceAPIService) SetPowerToServerInstance(ctx context.Context, serverInstanceId int32) ServerInstanceAPISetPowerToServerInstanceRequest {
	return ServerInstanceAPISetPowerToServerInstanceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) SetPowerToServerInstanceExecute(r ServerInstanceAPISetPowerToServerInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.SetPowerToServerInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/actions/power-set"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstancePowerSet == nil {
		return nil, reportError("serverInstancePowerSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.serverInstancePowerSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceAPIUpdateServerInstanceConfigRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	serverInstanceUpdate *ServerInstanceUpdate
	ifMatch *string
}

// The Server Instance configuration changes
func (r ServerInstanceAPIUpdateServerInstanceConfigRequest) ServerInstanceUpdate(serverInstanceUpdate ServerInstanceUpdate) ServerInstanceAPIUpdateServerInstanceConfigRequest {
	r.serverInstanceUpdate = &serverInstanceUpdate
	return r
}

// Entity tag
func (r ServerInstanceAPIUpdateServerInstanceConfigRequest) IfMatch(ifMatch string) ServerInstanceAPIUpdateServerInstanceConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceAPIUpdateServerInstanceConfigRequest) Execute() (*ServerInstanceConfiguration, *http.Response, error) {
	return r.ApiService.UpdateServerInstanceConfigExecute(r)
}

/*
UpdateServerInstanceConfig Update Server Instance configuration

Updates the specified Server Instance configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIUpdateServerInstanceConfigRequest
*/
func (a *ServerInstanceAPIService) UpdateServerInstanceConfig(ctx context.Context, serverInstanceId int32) ServerInstanceAPIUpdateServerInstanceConfigRequest {
	return ServerInstanceAPIUpdateServerInstanceConfigRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
//  @return ServerInstanceConfiguration
func (a *ServerInstanceAPIService) UpdateServerInstanceConfigExecute(r ServerInstanceAPIUpdateServerInstanceConfigRequest) (*ServerInstanceConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.UpdateServerInstanceConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstanceUpdate == nil {
		return localVarReturnValue, nil, reportError("serverInstanceUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.serverInstanceUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	interfaceId int32
	serverInstanceInterfaceUpdate *ServerInstanceInterfaceUpdate
	ifMatch *string
}

// The Server Instance Interface configuration changes
func (r ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest) ServerInstanceInterfaceUpdate(serverInstanceInterfaceUpdate ServerInstanceInterfaceUpdate) ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest {
	r.serverInstanceInterfaceUpdate = &serverInstanceInterfaceUpdate
	return r
}

// Entity tag
func (r ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest) IfMatch(ifMatch string) ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest) Execute() (*ServerInstanceInterfaceConfiguration, *http.Response, error) {
	return r.ApiService.UpdateServerInstanceInterfaceConfigExecute(r)
}

/*
UpdateServerInstanceInterfaceConfig Update Server Instance Interface configuration

Updates a Server Instance Interface (such as by attaching it to a network)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @param interfaceId
 @return ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest
*/
func (a *ServerInstanceAPIService) UpdateServerInstanceInterfaceConfig(ctx context.Context, serverInstanceId int32, interfaceId int32) ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest {
	return ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ServerInstanceInterfaceConfiguration
func (a *ServerInstanceAPIService) UpdateServerInstanceInterfaceConfigExecute(r ServerInstanceAPIUpdateServerInstanceInterfaceConfigRequest) (*ServerInstanceInterfaceConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceInterfaceConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.UpdateServerInstanceInterfaceConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/interfaces/{interfaceId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstanceInterfaceUpdate == nil {
		return localVarReturnValue, nil, reportError("serverInstanceInterfaceUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.serverInstanceInterfaceUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceAPIUpdateServerInstanceMetaRequest struct {
	ctx context.Context
	ApiService *ServerInstanceAPIService
	serverInstanceId int32
	genericMeta *GenericMeta
}

// The Server Instance meta information
func (r ServerInstanceAPIUpdateServerInstanceMetaRequest) GenericMeta(genericMeta GenericMeta) ServerInstanceAPIUpdateServerInstanceMetaRequest {
	r.genericMeta = &genericMeta
	return r
}

func (r ServerInstanceAPIUpdateServerInstanceMetaRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateServerInstanceMetaExecute(r)
}

/*
UpdateServerInstanceMeta Update an Server Instance meta information

Updates the specified Server Instance meta information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceId
 @return ServerInstanceAPIUpdateServerInstanceMetaRequest
*/
func (a *ServerInstanceAPIService) UpdateServerInstanceMeta(ctx context.Context, serverInstanceId int32) ServerInstanceAPIUpdateServerInstanceMetaRequest {
	return ServerInstanceAPIUpdateServerInstanceMetaRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceId: serverInstanceId,
	}
}

// Execute executes the request
func (a *ServerInstanceAPIService) UpdateServerInstanceMetaExecute(r ServerInstanceAPIUpdateServerInstanceMetaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceAPIService.UpdateServerInstanceMeta")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instances/{serverInstanceId}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceId, "serverInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.genericMeta == nil {
		return nil, reportError("genericMeta is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.genericMeta
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
