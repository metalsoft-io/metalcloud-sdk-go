/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LogicalNetworkProfileAPIService LogicalNetworkProfileAPI service
type LogicalNetworkProfileAPIService service

type LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	createLogicalNetworkProfileRequest *CreateLogicalNetworkProfileRequest
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest) CreateLogicalNetworkProfileRequest(createLogicalNetworkProfileRequest CreateLogicalNetworkProfileRequest) LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest {
	r.createLogicalNetworkProfileRequest = &createLogicalNetworkProfileRequest
	return r
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest) Execute() (*CreateLogicalNetworkProfile201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkProfileExecute(r)
}

/*
CreateLogicalNetworkProfile Create a Logical Network Profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest
*/
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfile(ctx context.Context) LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest {
	return LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfile201Response
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileExecute(r LogicalNetworkProfileAPICreateLogicalNetworkProfileRequest) (*CreateLogicalNetworkProfile201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfile201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.CreateLogicalNetworkProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy Create Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy(ctx context.Context, id float32) LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv4/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy Create Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy(ctx context.Context, id float32) LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPICreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv6/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	createLogicalNetworkProfileVlanAllocationStrategyRequest *CreateLogicalNetworkProfileVlanAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest) CreateLogicalNetworkProfileVlanAllocationStrategyRequest(createLogicalNetworkProfileVlanAllocationStrategyRequest CreateLogicalNetworkProfileVlanAllocationStrategyRequest) LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest {
	r.createLogicalNetworkProfileVlanAllocationStrategyRequest = &createLogicalNetworkProfileVlanAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkProfileVlanAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkProfileVlanAllocationStrategy Create Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileVlanAllocationStrategy(ctx context.Context, id float32) LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest {
	return LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVlanAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileVlanAllocationStrategyExecute(r LogicalNetworkProfileAPICreateLogicalNetworkProfileVlanAllocationStrategyRequest) (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVlanAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.CreateLogicalNetworkProfileVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vlan/vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileVlanAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVlanAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVlanAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	createLogicalNetworkProfileVniAllocationStrategyRequest *CreateLogicalNetworkProfileVniAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest) CreateLogicalNetworkProfileVniAllocationStrategyRequest(createLogicalNetworkProfileVniAllocationStrategyRequest CreateLogicalNetworkProfileVniAllocationStrategyRequest) LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest {
	r.createLogicalNetworkProfileVniAllocationStrategyRequest = &createLogicalNetworkProfileVniAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.CreateLogicalNetworkProfileVniAllocationStrategyExecute(r)
}

/*
CreateLogicalNetworkProfileVniAllocationStrategy Create Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileVniAllocationStrategy(ctx context.Context, id float32) LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest {
	return LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVniAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) CreateLogicalNetworkProfileVniAllocationStrategyExecute(r LogicalNetworkProfileAPICreateLogicalNetworkProfileVniAllocationStrategyRequest) (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVniAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.CreateLogicalNetworkProfileVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vxlan/vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileVniAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVniAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVniAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkProfileExecute(r)
}

/*
DeleteLogicalNetworkProfile Delete a Logical Network Profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest
*/
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfile(ctx context.Context, id float32) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest {
	return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileExecute(r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.DeleteLogicalNetworkProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkProfileIpv4SubnetAllocationStrategy Delete Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.DeleteLogicalNetworkProfileIpv4SubnetAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkProfileIpv6SubnetAllocationStrategy Delete Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.DeleteLogicalNetworkProfileIpv6SubnetAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkProfileVlanAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkProfileVlanAllocationStrategy Delete Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest {
	return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileVlanAllocationStrategyExecute(r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVlanAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.DeleteLogicalNetworkProfileVlanAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	ifMatch *string
}

// Entity tag
func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLogicalNetworkProfileVniAllocationStrategyExecute(r)
}

/*
DeleteLogicalNetworkProfileVniAllocationStrategy Delete Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest {
	return LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
func (a *LogicalNetworkProfileAPIService) DeleteLogicalNetworkProfileVniAllocationStrategyExecute(r LogicalNetworkProfileAPIDeleteLogicalNetworkProfileVniAllocationStrategyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.DeleteLogicalNetworkProfileVniAllocationStrategy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileRequest) Execute() (*CreateLogicalNetworkProfile201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileExecute(r)
}

/*
GetLogicalNetworkProfile Get a Logical Network Profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfile(ctx context.Context, id float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfile201Response
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileRequest) (*CreateLogicalNetworkProfile201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfile201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) Page(page float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) Execute() (*PaginatedIpv4SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileIpv4SubnetAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkProfileIpv4SubnetAllocationStrategies Get all Ipv4 Subnet allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv4SubnetAllocationStrategies(ctx context.Context, id float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIpv4SubnetAllocationStrategy
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv4SubnetAllocationStrategiesExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategiesRequest) (*PaginatedIpv4SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIpv4SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileIpv4SubnetAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv4/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkProfileIpv4SubnetAllocationStrategy Get a Ipv4 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) Page(page float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) Execute() (*PaginatedIpv6SubnetAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileIpv6SubnetAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkProfileIpv6SubnetAllocationStrategies Get all Ipv6 Subnet allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv6SubnetAllocationStrategies(ctx context.Context, id float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedIpv6SubnetAllocationStrategy
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv6SubnetAllocationStrategiesExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategiesRequest) (*PaginatedIpv6SubnetAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIpv6SubnetAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileIpv6SubnetAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv6/subnet-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkProfileIpv6SubnetAllocationStrategy Get a Ipv6 Subnet allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) Page(page float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) Execute() (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileVlanAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkProfileVlanAllocationStrategies Get all Vlan allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVlanAllocationStrategies(ctx context.Context, id float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVlanAllocationStrategy
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVlanAllocationStrategiesExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategiesRequest) (*PaginatedVlanAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVlanAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileVlanAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vlan/vlan-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileVlanAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkProfileVlanAllocationStrategy Get a Vlan allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategyRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVlanAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVlanAllocationStrategyExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileVlanAllocationStrategyRequest) (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVlanAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	sortBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) Page(page float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 100           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 1000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) Limit(limit float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) FilterId(filterId []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$and&lt;/li&gt; &lt;li&gt;$or&lt;/li&gt; &lt;li&gt;$not&lt;/li&gt; &lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$gt&lt;/li&gt; &lt;li&gt;$gte&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt; &lt;li&gt;$lt&lt;/li&gt; &lt;li&gt;$lte&lt;/li&gt; &lt;li&gt;$btw&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$sw&lt;/li&gt; &lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) FilterKind(filterKind []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest {
	r.filterKind = &filterKind
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) SortBy(sortBy []string) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest {
	r.sortBy = &sortBy
	return r
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) Execute() (*PaginatedVniAllocationStrategy, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileVniAllocationStrategiesExecute(r)
}

/*
GetLogicalNetworkProfileVniAllocationStrategies Get all Vni allocation strategies.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVniAllocationStrategies(ctx context.Context, id float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedVniAllocationStrategy
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVniAllocationStrategiesExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategiesRequest) (*PaginatedVniAllocationStrategy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVniAllocationStrategy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileVniAllocationStrategies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vxlan/vni-allocation-strategies"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfileVniAllocationStrategyExecute(r)
}

/*
GetLogicalNetworkProfileVniAllocationStrategy Get a Vni allocation strategy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategyRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVniAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfileVniAllocationStrategyExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfileVniAllocationStrategyRequest) (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVniAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfileVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterKind *[]string
	filterLabel *[]string
	filterName *[]string
	filterFabricId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) Page(page float32) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; -1           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) Limit(limit float32) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) FilterId(filterId []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.filterId = &filterId
	return r
}

// Filter by kind query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.kind&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.kind&#x3D;$not:$like:John Doe&amp;filter.kind&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) FilterKind(filterKind []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.filterKind = &filterKind
	return r
}

// Filter by label query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.label&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.label&#x3D;$not:$like:John Doe&amp;filter.label&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) FilterLabel(filterLabel []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by name query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.name&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.name&#x3D;$not:$like:John Doe&amp;filter.name&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) FilterName(filterName []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.filterName = &filterName
	return r
}

// Filter by fabricId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fabricId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fabricId&#x3D;$not:$like:John Doe&amp;filter.fabricId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) FilterFabricId(filterFabricId []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.filterFabricId = &filterFabricId
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:ASC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;&lt;/ul&gt;       
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) SortBy(sortBy []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) Search(search string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,label,name           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt; &lt;li&gt;name&lt;/li&gt;&lt;/ul&gt;         
func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) SearchBy(searchBy []string) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	r.searchBy = &searchBy
	return r
}

func (r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) Execute() (*PaginatedLogicalNetworkProfile, *http.Response, error) {
	return r.ApiService.GetLogicalNetworkProfilesExecute(r)
}

/*
GetLogicalNetworkProfiles Get all Logical Network Profiles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest
*/
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfiles(ctx context.Context) LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest {
	return LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedLogicalNetworkProfile
func (a *LogicalNetworkProfileAPIService) GetLogicalNetworkProfilesExecute(r LogicalNetworkProfileAPIGetLogicalNetworkProfilesRequest) (*PaginatedLogicalNetworkProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLogicalNetworkProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.GetLogicalNetworkProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterKind != nil {
		t := *r.filterKind
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.kind", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterName != nil {
		t := *r.filterName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.name", t, "form", "multi")
		}
	}
	if r.filterFabricId != nil {
		t := *r.filterFabricId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.fabricId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategy Replace Ipv4 Subnet allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv4SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.ReplaceLogicalNetworkProfileIpv4SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv4/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv4SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest(createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest CreateLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest = &createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategy Replace Ipv6 Subnet allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest {
	return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyExecute(r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest) (*CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileIpv6SubnetAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.ReplaceLogicalNetworkProfileIpv6SubnetAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/ipv6/subnet-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileIpv6SubnetAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	createLogicalNetworkProfileVlanAllocationStrategyRequest *CreateLogicalNetworkProfileVlanAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest) CreateLogicalNetworkProfileVlanAllocationStrategyRequest(createLogicalNetworkProfileVlanAllocationStrategyRequest CreateLogicalNetworkProfileVlanAllocationStrategyRequest) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest {
	r.createLogicalNetworkProfileVlanAllocationStrategyRequest = &createLogicalNetworkProfileVlanAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkProfileVlanAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkProfileVlanAllocationStrategy Replace Vlan allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileVlanAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest {
	return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVlanAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileVlanAllocationStrategyExecute(r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVlanAllocationStrategyRequest) (*CreateLogicalNetworkProfileVlanAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVlanAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.ReplaceLogicalNetworkProfileVlanAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vlan/vlan-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileVlanAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVlanAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVlanAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	allocationStrategyId float32
	createLogicalNetworkProfileVniAllocationStrategyRequest *CreateLogicalNetworkProfileVniAllocationStrategyRequest
	ifMatch *string
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest) CreateLogicalNetworkProfileVniAllocationStrategyRequest(createLogicalNetworkProfileVniAllocationStrategyRequest CreateLogicalNetworkProfileVniAllocationStrategyRequest) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest {
	r.createLogicalNetworkProfileVniAllocationStrategyRequest = &createLogicalNetworkProfileVniAllocationStrategyRequest
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest) Execute() (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	return r.ApiService.ReplaceLogicalNetworkProfileVniAllocationStrategyExecute(r)
}

/*
ReplaceLogicalNetworkProfileVniAllocationStrategy Replace Vni allocation strategy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param allocationStrategyId
 @return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest
*/
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileVniAllocationStrategy(ctx context.Context, id float32, allocationStrategyId float32) LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest {
	return LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		allocationStrategyId: allocationStrategyId,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfileVniAllocationStrategy201Response
func (a *LogicalNetworkProfileAPIService) ReplaceLogicalNetworkProfileVniAllocationStrategyExecute(r LogicalNetworkProfileAPIReplaceLogicalNetworkProfileVniAllocationStrategyRequest) (*CreateLogicalNetworkProfileVniAllocationStrategy201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfileVniAllocationStrategy201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.ReplaceLogicalNetworkProfileVniAllocationStrategy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}/vxlan/vni-allocation-strategies/{allocationStrategyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationStrategyId"+"}", url.PathEscape(parameterValueToString(r.allocationStrategyId, "allocationStrategyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkProfileVniAllocationStrategyRequest == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkProfileVniAllocationStrategyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.createLogicalNetworkProfileVniAllocationStrategyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest struct {
	ctx context.Context
	ApiService *LogicalNetworkProfileAPIService
	id float32
	updateLogicalNetworkProfile *UpdateLogicalNetworkProfile
	ifMatch *string
}

func (r LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest) UpdateLogicalNetworkProfile(updateLogicalNetworkProfile UpdateLogicalNetworkProfile) LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest {
	r.updateLogicalNetworkProfile = &updateLogicalNetworkProfile
	return r
}

// Entity tag
func (r LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest) IfMatch(ifMatch string) LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest) Execute() (*CreateLogicalNetworkProfile201Response, *http.Response, error) {
	return r.ApiService.UpdateLogicalNetworkProfileExecute(r)
}

/*
UpdateLogicalNetworkProfile Update Logical Network Profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest
*/
func (a *LogicalNetworkProfileAPIService) UpdateLogicalNetworkProfile(ctx context.Context, id float32) LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest {
	return LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateLogicalNetworkProfile201Response
func (a *LogicalNetworkProfileAPIService) UpdateLogicalNetworkProfileExecute(r LogicalNetworkProfileAPIUpdateLogicalNetworkProfileRequest) (*CreateLogicalNetworkProfile201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLogicalNetworkProfile201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogicalNetworkProfileAPIService.UpdateLogicalNetworkProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/logical-network-profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLogicalNetworkProfile == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetworkProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateLogicalNetworkProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
