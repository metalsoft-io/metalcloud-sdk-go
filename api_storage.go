/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// StorageAPIService StorageAPI service
type StorageAPIService service

type StorageAPICreateStorageRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	createStorage *CreateStorage
}

// The Storage create object
func (r StorageAPICreateStorageRequest) CreateStorage(createStorage CreateStorage) StorageAPICreateStorageRequest {
	r.createStorage = &createStorage
	return r
}

func (r StorageAPICreateStorageRequest) Execute() (*RegisterStorageResponse, *http.Response, error) {
	return r.ApiService.CreateStorageExecute(r)
}

/*
CreateStorage Creates a Storage

Creates a Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return StorageAPICreateStorageRequest
*/
func (a *StorageAPIService) CreateStorage(ctx context.Context) StorageAPICreateStorageRequest {
	return StorageAPICreateStorageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterStorageResponse
func (a *StorageAPIService) CreateStorageExecute(r StorageAPICreateStorageRequest) (*RegisterStorageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterStorageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.CreateStorage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createStorage == nil {
		return localVarReturnValue, nil, reportError("createStorage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createStorage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPICreateStorageNetworkDeviceConfigurationRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	createStorageNetworkDeviceConfiguration *CreateStorageNetworkDeviceConfiguration
}

// The new Storage Network Device Configuration object
func (r StorageAPICreateStorageNetworkDeviceConfigurationRequest) CreateStorageNetworkDeviceConfiguration(createStorageNetworkDeviceConfiguration CreateStorageNetworkDeviceConfiguration) StorageAPICreateStorageNetworkDeviceConfigurationRequest {
	r.createStorageNetworkDeviceConfiguration = &createStorageNetworkDeviceConfiguration
	return r
}

func (r StorageAPICreateStorageNetworkDeviceConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateStorageNetworkDeviceConfigurationExecute(r)
}

/*
CreateStorageNetworkDeviceConfiguration Creates a Storage Network Device Configuration

Creates a Storage Network Device Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPICreateStorageNetworkDeviceConfigurationRequest
*/
func (a *StorageAPIService) CreateStorageNetworkDeviceConfiguration(ctx context.Context, storageId float32) StorageAPICreateStorageNetworkDeviceConfigurationRequest {
	return StorageAPICreateStorageNetworkDeviceConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
func (a *StorageAPIService) CreateStorageNetworkDeviceConfigurationExecute(r StorageAPICreateStorageNetworkDeviceConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.CreateStorageNetworkDeviceConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/network-device-configurations"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createStorageNetworkDeviceConfiguration == nil {
		return nil, reportError("createStorageNetworkDeviceConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createStorageNetworkDeviceConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type StorageAPIDeleteStorageRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	ifMatch *string
}

// Entity tag
func (r StorageAPIDeleteStorageRequest) IfMatch(ifMatch string) StorageAPIDeleteStorageRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r StorageAPIDeleteStorageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteStorageExecute(r)
}

/*
DeleteStorage Deletes a Storage

Deletes a Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIDeleteStorageRequest
*/
func (a *StorageAPIService) DeleteStorage(ctx context.Context, storageId float32) StorageAPIDeleteStorageRequest {
	return StorageAPIDeleteStorageRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
func (a *StorageAPIService) DeleteStorageExecute(r StorageAPIDeleteStorageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.DeleteStorage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type StorageAPIDeleteStorageNetworkDeviceConfigurationRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	storageNetworkDeviceConfigurationId float32
}

func (r StorageAPIDeleteStorageNetworkDeviceConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteStorageNetworkDeviceConfigurationExecute(r)
}

/*
DeleteStorageNetworkDeviceConfiguration Deletes a Storage Network Device Configuration

Deletes a Storage Network Device Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @param storageNetworkDeviceConfigurationId
 @return StorageAPIDeleteStorageNetworkDeviceConfigurationRequest
*/
func (a *StorageAPIService) DeleteStorageNetworkDeviceConfiguration(ctx context.Context, storageId float32, storageNetworkDeviceConfigurationId float32) StorageAPIDeleteStorageNetworkDeviceConfigurationRequest {
	return StorageAPIDeleteStorageNetworkDeviceConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
		storageNetworkDeviceConfigurationId: storageNetworkDeviceConfigurationId,
	}
}

// Execute executes the request
func (a *StorageAPIService) DeleteStorageNetworkDeviceConfigurationExecute(r StorageAPIDeleteStorageNetworkDeviceConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.DeleteStorageNetworkDeviceConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/network-device-configurations/{storageNetworkDeviceConfigurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageNetworkDeviceConfigurationId"+"}", url.PathEscape(parameterValueToString(r.storageNetworkDeviceConfigurationId, "storageNetworkDeviceConfigurationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type StorageAPIGetStorageRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
}

func (r StorageAPIGetStorageRequest) Execute() (*Storage, *http.Response, error) {
	return r.ApiService.GetStorageExecute(r)
}

/*
GetStorage Retrieves a Storage

Retrieves a Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageRequest
*/
func (a *StorageAPIService) GetStorage(ctx context.Context, storageId float32) StorageAPIGetStorageRequest {
	return StorageAPIGetStorageRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return Storage
func (a *StorageAPIService) GetStorageExecute(r StorageAPIGetStorageRequest) (*Storage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Storage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStorageBucketsRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	page *float32
	limit *float32
	filterId *[]string
	filterLabel *[]string
	filterSubdomain *[]string
	filterSubdomainPermanent *[]string
	filterServiceStatus *[]string
	filterStoragePoolId *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r StorageAPIGetStorageBucketsRequest) Page(page float32) StorageAPIGetStorageBucketsRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r StorageAPIGetStorageBucketsRequest) Limit(limit float32) StorageAPIGetStorageBucketsRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterId(filterId []string) StorageAPIGetStorageBucketsRequest {
	r.filterId = &filterId
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterLabel(filterLabel []string) StorageAPIGetStorageBucketsRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by subdomain query param.  **Format:** filter.subdomain&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.subdomain&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterSubdomain(filterSubdomain []string) StorageAPIGetStorageBucketsRequest {
	r.filterSubdomain = &filterSubdomain
	return r
}

// Filter by subdomainPermanent query param.  **Format:** filter.subdomainPermanent&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.subdomainPermanent&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterSubdomainPermanent(filterSubdomainPermanent []string) StorageAPIGetStorageBucketsRequest {
	r.filterSubdomainPermanent = &filterSubdomainPermanent
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe&amp;filter.serviceStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterServiceStatus(filterServiceStatus []string) StorageAPIGetStorageBucketsRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by storagePoolId query param.  **Format:** filter.storagePoolId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.storagePoolId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterStoragePoolId(filterStoragePoolId []string) StorageAPIGetStorageBucketsRequest {
	r.filterStoragePoolId = &filterStoragePoolId
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) StorageAPIGetStorageBucketsRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageBucketsRequest) FilterConfigDeployType(filterConfigDeployType []string) StorageAPIGetStorageBucketsRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;infrastructureId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - infrastructureId  - storagePoolId  - serviceStatus  - config.deployStatus  - config.deployType 
func (r StorageAPIGetStorageBucketsRequest) SortBy(sortBy []string) StorageAPIGetStorageBucketsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r StorageAPIGetStorageBucketsRequest) Search(search string) StorageAPIGetStorageBucketsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,label,subdomain,subdomainPermanent,storagePoolId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - label  - subdomain  - subdomainPermanent  - storagePoolId  - serviceStatus  - infrastructureId  - config.deployStatus  - config.deployType 
func (r StorageAPIGetStorageBucketsRequest) SearchBy(searchBy []string) StorageAPIGetStorageBucketsRequest {
	r.searchBy = &searchBy
	return r
}

func (r StorageAPIGetStorageBucketsRequest) Execute() (*BucketPaginatedList, *http.Response, error) {
	return r.ApiService.GetStorageBucketsExecute(r)
}

/*
GetStorageBuckets Get all Buckets linked to the specified storage

Returns list of all Buckets linked to the specified Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageBucketsRequest
*/
func (a *StorageAPIService) GetStorageBuckets(ctx context.Context, storageId float32) StorageAPIGetStorageBucketsRequest {
	return StorageAPIGetStorageBucketsRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return BucketPaginatedList
func (a *StorageAPIService) GetStorageBucketsExecute(r StorageAPIGetStorageBucketsRequest) (*BucketPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorageBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterSubdomain != nil {
		t := *r.filterSubdomain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomain", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomain", t, "form", "multi")
		}
	}
	if r.filterSubdomainPermanent != nil {
		t := *r.filterSubdomainPermanent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomainPermanent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomainPermanent", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterStoragePoolId != nil {
		t := *r.filterStoragePoolId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storagePoolId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storagePoolId", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStorageCredentialsRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
}

func (r StorageAPIGetStorageCredentialsRequest) Execute() (*StorageCredentials, *http.Response, error) {
	return r.ApiService.GetStorageCredentialsExecute(r)
}

/*
GetStorageCredentials Get Storage credentials

Returns Storage credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageCredentialsRequest
*/
func (a *StorageAPIService) GetStorageCredentials(ctx context.Context, storageId float32) StorageAPIGetStorageCredentialsRequest {
	return StorageAPIGetStorageCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return StorageCredentials
func (a *StorageAPIService) GetStorageCredentialsExecute(r StorageAPIGetStorageCredentialsRequest) (*StorageCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StorageCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorageCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStorageDrivesRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	page *float32
	limit *float32
	filterLabel *[]string
	filterSubdomain *[]string
	filterSubdomainPermanent *[]string
	filterInfrastructureId *[]string
	filterStoragePoolId *[]string
	filterServiceStatus *[]string
	filterWwn *[]string
	filterQoS *[]string
	filterLogicalNetworkId *[]string
	filterAllocationAffinity *[]string
	filterProvisioningProtocol *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	filterConfigLogicalNetworkId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r StorageAPIGetStorageDrivesRequest) Page(page float32) StorageAPIGetStorageDrivesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r StorageAPIGetStorageDrivesRequest) Limit(limit float32) StorageAPIGetStorageDrivesRequest {
	r.limit = &limit
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterLabel(filterLabel []string) StorageAPIGetStorageDrivesRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by subdomain query param.  **Format:** filter.subdomain&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.subdomain&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterSubdomain(filterSubdomain []string) StorageAPIGetStorageDrivesRequest {
	r.filterSubdomain = &filterSubdomain
	return r
}

// Filter by subdomainPermanent query param.  **Format:** filter.subdomainPermanent&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.subdomainPermanent&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterSubdomainPermanent(filterSubdomainPermanent []string) StorageAPIGetStorageDrivesRequest {
	r.filterSubdomainPermanent = &filterSubdomainPermanent
	return r
}

// Filter by infrastructureId query param.  **Format:** filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.infrastructureId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterInfrastructureId(filterInfrastructureId []string) StorageAPIGetStorageDrivesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by storagePoolId query param.  **Format:** filter.storagePoolId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.storagePoolId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterStoragePoolId(filterStoragePoolId []string) StorageAPIGetStorageDrivesRequest {
	r.filterStoragePoolId = &filterStoragePoolId
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterServiceStatus(filterServiceStatus []string) StorageAPIGetStorageDrivesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by wwn query param.  **Format:** filter.wwn&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.wwn&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterWwn(filterWwn []string) StorageAPIGetStorageDrivesRequest {
	r.filterWwn = &filterWwn
	return r
}

// Filter by qoS query param.  **Format:** filter.qoS&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.qoS&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterQoS(filterQoS []string) StorageAPIGetStorageDrivesRequest {
	r.filterQoS = &filterQoS
	return r
}

// Filter by logicalNetworkId query param.  **Format:** filter.logicalNetworkId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.logicalNetworkId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterLogicalNetworkId(filterLogicalNetworkId []string) StorageAPIGetStorageDrivesRequest {
	r.filterLogicalNetworkId = &filterLogicalNetworkId
	return r
}

// Filter by allocationAffinity query param.  **Format:** filter.allocationAffinity&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.allocationAffinity&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterAllocationAffinity(filterAllocationAffinity []string) StorageAPIGetStorageDrivesRequest {
	r.filterAllocationAffinity = &filterAllocationAffinity
	return r
}

// Filter by provisioningProtocol query param.  **Format:** filter.provisioningProtocol&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.provisioningProtocol&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterProvisioningProtocol(filterProvisioningProtocol []string) StorageAPIGetStorageDrivesRequest {
	r.filterProvisioningProtocol = &filterProvisioningProtocol
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) StorageAPIGetStorageDrivesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterConfigDeployType(filterConfigDeployType []string) StorageAPIGetStorageDrivesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Filter by config.logicalNetworkId query param.  **Format:** filter.config.logicalNetworkId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.logicalNetworkId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageDrivesRequest) FilterConfigLogicalNetworkId(filterConfigLogicalNetworkId []string) StorageAPIGetStorageDrivesRequest {
	r.filterConfigLogicalNetworkId = &filterConfigLogicalNetworkId
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;storagePoolId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - storagePoolId  - infrastructureId  - serviceStatus  - config.deployStatus  - config.deployType 
func (r StorageAPIGetStorageDrivesRequest) SortBy(sortBy []string) StorageAPIGetStorageDrivesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r StorageAPIGetStorageDrivesRequest) Search(search string) StorageAPIGetStorageDrivesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,label,subdomain,subdomainPermanent,infrastructureId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - label  - subdomain  - subdomainPermanent  - infrastructureId  - storagePoolId  - serviceStatus  - wwn  - qoS  - logicalNetworkId  - allocationAffinity  - provisioningProtocol  - config.deployStatus  - config.deployType  - config.logicalNetworkId 
func (r StorageAPIGetStorageDrivesRequest) SearchBy(searchBy []string) StorageAPIGetStorageDrivesRequest {
	r.searchBy = &searchBy
	return r
}

func (r StorageAPIGetStorageDrivesRequest) Execute() (*SharedDrivePaginatedList, *http.Response, error) {
	return r.ApiService.GetStorageDrivesExecute(r)
}

/*
GetStorageDrives Get all Drives linked to the specified storage

Returns list of all Drives linked to the specified Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageDrivesRequest
*/
func (a *StorageAPIService) GetStorageDrives(ctx context.Context, storageId float32) StorageAPIGetStorageDrivesRequest {
	return StorageAPIGetStorageDrivesRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return SharedDrivePaginatedList
func (a *StorageAPIService) GetStorageDrivesExecute(r StorageAPIGetStorageDrivesRequest) (*SharedDrivePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharedDrivePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorageDrives")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/drives"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterSubdomain != nil {
		t := *r.filterSubdomain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomain", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomain", t, "form", "multi")
		}
	}
	if r.filterSubdomainPermanent != nil {
		t := *r.filterSubdomainPermanent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomainPermanent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomainPermanent", t, "form", "multi")
		}
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterStoragePoolId != nil {
		t := *r.filterStoragePoolId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storagePoolId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storagePoolId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterWwn != nil {
		t := *r.filterWwn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.wwn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.wwn", t, "form", "multi")
		}
	}
	if r.filterQoS != nil {
		t := *r.filterQoS
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.qoS", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.qoS", t, "form", "multi")
		}
	}
	if r.filterLogicalNetworkId != nil {
		t := *r.filterLogicalNetworkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.logicalNetworkId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.logicalNetworkId", t, "form", "multi")
		}
	}
	if r.filterAllocationAffinity != nil {
		t := *r.filterAllocationAffinity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.allocationAffinity", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.allocationAffinity", t, "form", "multi")
		}
	}
	if r.filterProvisioningProtocol != nil {
		t := *r.filterProvisioningProtocol
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.provisioningProtocol", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.provisioningProtocol", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.filterConfigLogicalNetworkId != nil {
		t := *r.filterConfigLogicalNetworkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.logicalNetworkId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.logicalNetworkId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStorageFileSharesRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	page *float32
	limit *float32
	filterId *[]string
	filterLabel *[]string
	filterSubdomain *[]string
	filterSubdomainPermanent *[]string
	filterServiceStatus *[]string
	filterStoragePoolId *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r StorageAPIGetStorageFileSharesRequest) Page(page float32) StorageAPIGetStorageFileSharesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r StorageAPIGetStorageFileSharesRequest) Limit(limit float32) StorageAPIGetStorageFileSharesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterId(filterId []string) StorageAPIGetStorageFileSharesRequest {
	r.filterId = &filterId
	return r
}

// Filter by label query param.  **Format:** filter.label&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.label&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterLabel(filterLabel []string) StorageAPIGetStorageFileSharesRequest {
	r.filterLabel = &filterLabel
	return r
}

// Filter by subdomain query param.  **Format:** filter.subdomain&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.subdomain&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterSubdomain(filterSubdomain []string) StorageAPIGetStorageFileSharesRequest {
	r.filterSubdomain = &filterSubdomain
	return r
}

// Filter by subdomainPermanent query param.  **Format:** filter.subdomainPermanent&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.subdomainPermanent&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterSubdomainPermanent(filterSubdomainPermanent []string) StorageAPIGetStorageFileSharesRequest {
	r.filterSubdomainPermanent = &filterSubdomainPermanent
	return r
}

// Filter by serviceStatus query param.  **Format:** filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.serviceStatus&#x3D;$eq:John Doe&amp;filter.serviceStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterServiceStatus(filterServiceStatus []string) StorageAPIGetStorageFileSharesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by storagePoolId query param.  **Format:** filter.storagePoolId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.storagePoolId&#x3D;$eq:John Doe  **Available Operations** - $eq  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterStoragePoolId(filterStoragePoolId []string) StorageAPIGetStorageFileSharesRequest {
	r.filterStoragePoolId = &filterStoragePoolId
	return r
}

// Filter by config.deployStatus query param.  **Format:** filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployStatus&#x3D;$eq:John Doe&amp;filter.config.deployStatus&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) StorageAPIGetStorageFileSharesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.  **Format:** filter.config.deployType&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.config.deployType&#x3D;$eq:John Doe&amp;filter.config.deployType&#x3D;$in:John Doe  **Available Operations** - $eq  - $in  - $and  - $or
func (r StorageAPIGetStorageFileSharesRequest) FilterConfigDeployType(filterConfigDeployType []string) StorageAPIGetStorageFileSharesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;infrastructureId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - infrastructureId  - storagePoolId  - serviceStatus  - config.deployStatus  - config.deployType 
func (r StorageAPIGetStorageFileSharesRequest) SortBy(sortBy []string) StorageAPIGetStorageFileSharesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r StorageAPIGetStorageFileSharesRequest) Search(search string) StorageAPIGetStorageFileSharesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,label,subdomain,subdomainPermanent,storagePoolId   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - label  - subdomain  - subdomainPermanent  - storagePoolId  - serviceStatus  - infrastructureId  - config.deployStatus  - config.deployType 
func (r StorageAPIGetStorageFileSharesRequest) SearchBy(searchBy []string) StorageAPIGetStorageFileSharesRequest {
	r.searchBy = &searchBy
	return r
}

func (r StorageAPIGetStorageFileSharesRequest) Execute() (*FileSharePaginatedList, *http.Response, error) {
	return r.ApiService.GetStorageFileSharesExecute(r)
}

/*
GetStorageFileShares Get all File Shares linked to the specified storage

Returns list of all File Shares linked to the specified Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageFileSharesRequest
*/
func (a *StorageAPIService) GetStorageFileShares(ctx context.Context, storageId float32) StorageAPIGetStorageFileSharesRequest {
	return StorageAPIGetStorageFileSharesRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return FileSharePaginatedList
func (a *StorageAPIService) GetStorageFileSharesExecute(r StorageAPIGetStorageFileSharesRequest) (*FileSharePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSharePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorageFileShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/file-shares"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterLabel != nil {
		t := *r.filterLabel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.label", t, "form", "multi")
		}
	}
	if r.filterSubdomain != nil {
		t := *r.filterSubdomain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomain", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomain", t, "form", "multi")
		}
	}
	if r.filterSubdomainPermanent != nil {
		t := *r.filterSubdomainPermanent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomainPermanent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.subdomainPermanent", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterStoragePoolId != nil {
		t := *r.filterStoragePoolId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storagePoolId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.storagePoolId", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStorageNetworkDeviceConfigurationsRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
}

func (r StorageAPIGetStorageNetworkDeviceConfigurationsRequest) Execute() ([]StorageNetworkDeviceConfiguration, *http.Response, error) {
	return r.ApiService.GetStorageNetworkDeviceConfigurationsExecute(r)
}

/*
GetStorageNetworkDeviceConfigurations Retrieves Storage Network Device Configurations

Retrieves Storage Network Device Configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageNetworkDeviceConfigurationsRequest
*/
func (a *StorageAPIService) GetStorageNetworkDeviceConfigurations(ctx context.Context, storageId float32) StorageAPIGetStorageNetworkDeviceConfigurationsRequest {
	return StorageAPIGetStorageNetworkDeviceConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return []StorageNetworkDeviceConfiguration
func (a *StorageAPIService) GetStorageNetworkDeviceConfigurationsExecute(r StorageAPIGetStorageNetworkDeviceConfigurationsRequest) ([]StorageNetworkDeviceConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StorageNetworkDeviceConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorageNetworkDeviceConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/network-device-configurations"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStorageStatisticsRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
}

func (r StorageAPIGetStorageStatisticsRequest) Execute() (*StorageStatistics, *http.Response, error) {
	return r.ApiService.GetStorageStatisticsExecute(r)
}

/*
GetStorageStatistics Get Storages statistics

Returns Storages statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIGetStorageStatisticsRequest
*/
func (a *StorageAPIService) GetStorageStatistics(ctx context.Context, storageId float32) StorageAPIGetStorageStatisticsRequest {
	return StorageAPIGetStorageStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return StorageStatistics
func (a *StorageAPIService) GetStorageStatisticsExecute(r StorageAPIGetStorageStatisticsRequest) (*StorageStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StorageStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorageStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStoragesRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	page *float32
	limit *float32
	filterId *[]string
	filterUserId *[]string
	filterSiteId *[]string
	filterTechnologies *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve. If you provide invalid value the default page number will applied  **Example:** 1   **Default Value:** 1  
func (r StorageAPIGetStoragesRequest) Page(page float32) StorageAPIGetStoragesRequest {
	r.page = &page
	return r
}

// Number of records per page.   **Example:** 20    **Default Value:** 20    **Max Value:** 100   If provided value is greater than max value, max value will be applied. 
func (r StorageAPIGetStoragesRequest) Limit(limit float32) StorageAPIGetStoragesRequest {
	r.limit = &limit
	return r
}

// Filter by id query param.  **Format:** filter.id&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.id&#x3D;$btw:John Doe&amp;filter.id&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r StorageAPIGetStoragesRequest) FilterId(filterId []string) StorageAPIGetStoragesRequest {
	r.filterId = &filterId
	return r
}

// Filter by userId query param.  **Format:** filter.userId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.userId&#x3D;$btw:John Doe&amp;filter.userId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r StorageAPIGetStoragesRequest) FilterUserId(filterUserId []string) StorageAPIGetStoragesRequest {
	r.filterUserId = &filterUserId
	return r
}

// Filter by siteId query param.  **Format:** filter.siteId&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.siteId&#x3D;$btw:John Doe&amp;filter.siteId&#x3D;$contains:John Doe  **Available Operations** - $eq  - $gt  - $gte  - $in  - $null  - $lt  - $lte  - $btw  - $ilike  - $sw  - $contains  - $not  - $and  - $or
func (r StorageAPIGetStoragesRequest) FilterSiteId(filterSiteId []string) StorageAPIGetStoragesRequest {
	r.filterSiteId = &filterSiteId
	return r
}

// Filter by technologies query param.  **Format:** filter.technologies&#x3D;{$not}:OPERATION:VALUE    **Example:** filter.technologies&#x3D;$in:John Doe  **Available Operations** - $in  - $and  - $or
func (r StorageAPIGetStoragesRequest) FilterTechnologies(filterTechnologies []string) StorageAPIGetStoragesRequest {
	r.filterTechnologies = &filterTechnologies
	return r
}

// Parameter to sort by. To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting  **Format:** {fieldName}:{DIRECTION}   **Example:** sortBy&#x3D;id:DESC&amp;sortBy&#x3D;userId:DESC   **Default Value:** id:DESC  **Available Fields** - id  - userId  - siteId  - driver  - technologies 
func (r StorageAPIGetStoragesRequest) SortBy(sortBy []string) StorageAPIGetStoragesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values  **Example:** John   **Default Value:** No default value  
func (r StorageAPIGetStoragesRequest) Search(search string) StorageAPIGetStoragesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values  **Example:** id,userId,siteId,driver,technologies   **Default Value:** By default all fields mentioned below will be used to search by term  **Available Fields** - id  - userId  - siteId  - driver  - technologies 
func (r StorageAPIGetStoragesRequest) SearchBy(searchBy []string) StorageAPIGetStoragesRequest {
	r.searchBy = &searchBy
	return r
}

func (r StorageAPIGetStoragesRequest) Execute() (*StoragePaginatedList, *http.Response, error) {
	return r.ApiService.GetStoragesExecute(r)
}

/*
GetStorages Get a list of Storages

Returns a list of Storages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return StorageAPIGetStoragesRequest
*/
func (a *StorageAPIService) GetStorages(ctx context.Context) StorageAPIGetStoragesRequest {
	return StorageAPIGetStoragesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StoragePaginatedList
func (a *StorageAPIService) GetStoragesExecute(r StorageAPIGetStoragesRequest) (*StoragePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StoragePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStorages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterId != nil {
		t := *r.filterId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.id", t, "form", "multi")
		}
	}
	if r.filterUserId != nil {
		t := *r.filterUserId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.userId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.userId", t, "form", "multi")
		}
	}
	if r.filterSiteId != nil {
		t := *r.filterSiteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", t, "form", "multi")
		}
	}
	if r.filterTechnologies != nil {
		t := *r.filterTechnologies
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.technologies", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.technologies", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIGetStoragesStatisticsRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	includeMaintenance *string
	includeExperimental *string
	minimumSpace *float32
}

// Include storages in maintenance.
func (r StorageAPIGetStoragesStatisticsRequest) IncludeMaintenance(includeMaintenance string) StorageAPIGetStoragesStatisticsRequest {
	r.includeMaintenance = &includeMaintenance
	return r
}

// Include experimental storages.
func (r StorageAPIGetStoragesStatisticsRequest) IncludeExperimental(includeExperimental string) StorageAPIGetStoragesStatisticsRequest {
	r.includeExperimental = &includeExperimental
	return r
}

// Minimum space.
func (r StorageAPIGetStoragesStatisticsRequest) MinimumSpace(minimumSpace float32) StorageAPIGetStoragesStatisticsRequest {
	r.minimumSpace = &minimumSpace
	return r
}

func (r StorageAPIGetStoragesStatisticsRequest) Execute() (*StoragesStatistics, *http.Response, error) {
	return r.ApiService.GetStoragesStatisticsExecute(r)
}

/*
GetStoragesStatistics Get statistics for all Storages

Returns statistics for all Storages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return StorageAPIGetStoragesStatisticsRequest
*/
func (a *StorageAPIService) GetStoragesStatistics(ctx context.Context) StorageAPIGetStoragesStatisticsRequest {
	return StorageAPIGetStoragesStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StoragesStatistics
func (a *StorageAPIService) GetStoragesStatisticsExecute(r StorageAPIGetStoragesStatisticsRequest) (*StoragesStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StoragesStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.GetStoragesStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeMaintenance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMaintenance", r.includeMaintenance, "form", "")
	}
	if r.includeExperimental != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExperimental", r.includeExperimental, "form", "")
	}
	if r.minimumSpace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumSpace", r.minimumSpace, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIUpdateStorageRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	updateStorage *UpdateStorage
	ifMatch *string
}

// The Storage update object
func (r StorageAPIUpdateStorageRequest) UpdateStorage(updateStorage UpdateStorage) StorageAPIUpdateStorageRequest {
	r.updateStorage = &updateStorage
	return r
}

// Entity tag
func (r StorageAPIUpdateStorageRequest) IfMatch(ifMatch string) StorageAPIUpdateStorageRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r StorageAPIUpdateStorageRequest) Execute() (*Storage, *http.Response, error) {
	return r.ApiService.UpdateStorageExecute(r)
}

/*
UpdateStorage Updates a Storage

Updates a Storage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @return StorageAPIUpdateStorageRequest
*/
func (a *StorageAPIService) UpdateStorage(ctx context.Context, storageId float32) StorageAPIUpdateStorageRequest {
	return StorageAPIUpdateStorageRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
	}
}

// Execute executes the request
//  @return Storage
func (a *StorageAPIService) UpdateStorageExecute(r StorageAPIUpdateStorageRequest) (*Storage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Storage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.UpdateStorage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateStorage == nil {
		return localVarReturnValue, nil, reportError("updateStorage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateStorage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type StorageAPIUpdateStorageNetworkDeviceConfigurationRequest struct {
	ctx context.Context
	ApiService *StorageAPIService
	storageId float32
	storageNetworkDeviceConfigurationId float32
	updateStorageNetworkDeviceConfiguration *UpdateStorageNetworkDeviceConfiguration
}

// The updated Storage Network Device Configuration object
func (r StorageAPIUpdateStorageNetworkDeviceConfigurationRequest) UpdateStorageNetworkDeviceConfiguration(updateStorageNetworkDeviceConfiguration UpdateStorageNetworkDeviceConfiguration) StorageAPIUpdateStorageNetworkDeviceConfigurationRequest {
	r.updateStorageNetworkDeviceConfiguration = &updateStorageNetworkDeviceConfiguration
	return r
}

func (r StorageAPIUpdateStorageNetworkDeviceConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateStorageNetworkDeviceConfigurationExecute(r)
}

/*
UpdateStorageNetworkDeviceConfiguration Updates a Storage Network Device Configuration

Updates a Storage Network Device Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storageId
 @param storageNetworkDeviceConfigurationId
 @return StorageAPIUpdateStorageNetworkDeviceConfigurationRequest
*/
func (a *StorageAPIService) UpdateStorageNetworkDeviceConfiguration(ctx context.Context, storageId float32, storageNetworkDeviceConfigurationId float32) StorageAPIUpdateStorageNetworkDeviceConfigurationRequest {
	return StorageAPIUpdateStorageNetworkDeviceConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		storageId: storageId,
		storageNetworkDeviceConfigurationId: storageNetworkDeviceConfigurationId,
	}
}

// Execute executes the request
func (a *StorageAPIService) UpdateStorageNetworkDeviceConfigurationExecute(r StorageAPIUpdateStorageNetworkDeviceConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageAPIService.UpdateStorageNetworkDeviceConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/storages/{storageId}/network-device-configurations/{storageNetworkDeviceConfigurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", url.PathEscape(parameterValueToString(r.storageId, "storageId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageNetworkDeviceConfigurationId"+"}", url.PathEscape(parameterValueToString(r.storageNetworkDeviceConfigurationId, "storageNetworkDeviceConfigurationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateStorageNetworkDeviceConfiguration == nil {
		return nil, reportError("updateStorageNetworkDeviceConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStorageNetworkDeviceConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
