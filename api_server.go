/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ServerAPIService ServerAPI service
type ServerAPIService service

type ServerAPIArchiveServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	ifMatch *string
}

// Entity tag
func (r ServerAPIArchiveServerRequest) IfMatch(ifMatch string) ServerAPIArchiveServerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIArchiveServerRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveServerExecute(r)
}

/*
ArchiveServer Archives a Server

Archives a Server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIArchiveServerRequest
*/
func (a *ServerAPIService) ArchiveServer(ctx context.Context, serverId float32) ServerAPIArchiveServerRequest {
	return ServerAPIArchiveServerRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
func (a *ServerAPIService) ArchiveServerExecute(r ServerAPIArchiveServerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.ArchiveServer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerAPIDeleteServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	ifMatch *string
}

// Entity tag
func (r ServerAPIDeleteServerRequest) IfMatch(ifMatch string) ServerAPIDeleteServerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIDeleteServerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServerExecute(r)
}

/*
DeleteServer Deletes a Server

Deletes a Server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIDeleteServerRequest
*/
func (a *ServerAPIService) DeleteServer(ctx context.Context, serverId float32) ServerAPIDeleteServerRequest {
	return ServerAPIDeleteServerRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
func (a *ServerAPIService) DeleteServerExecute(r ServerAPIDeleteServerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.DeleteServer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerAPIEnableServerSyslogRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	ifMatch *string
}

// Entity tag
func (r ServerAPIEnableServerSyslogRequest) IfMatch(ifMatch string) ServerAPIEnableServerSyslogRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIEnableServerSyslogRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableServerSyslogExecute(r)
}

/*
EnableServerSyslog Enables remote syslog for a server

Enables remote syslog for a server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIEnableServerSyslogRequest
*/
func (a *ServerAPIService) EnableServerSyslog(ctx context.Context, serverId float32) ServerAPIEnableServerSyslogRequest {
	return ServerAPIEnableServerSyslogRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
func (a *ServerAPIService) EnableServerSyslogExecute(r ServerAPIEnableServerSyslogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.EnableServerSyslog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/syslog-subscribe"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerAPIGetServerCapabilitiesRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIGetServerCapabilitiesRequest) Execute() (*ServerCapabilities, *http.Response, error) {
	return r.ApiService.GetServerCapabilitiesExecute(r)
}

/*
GetServerCapabilities Get Server capabilities

Returns Server capabilities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIGetServerCapabilitiesRequest
*/
func (a *ServerAPIService) GetServerCapabilities(ctx context.Context, serverId float32) ServerAPIGetServerCapabilitiesRequest {
	return ServerAPIGetServerCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return ServerCapabilities
func (a *ServerAPIService) GetServerCapabilitiesExecute(r ServerAPIGetServerCapabilitiesRequest) (*ServerCapabilities, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerCapabilities
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServerCapabilities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/capabilities"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServerCredentialsRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIGetServerCredentialsRequest) Execute() (*ServerCredentials, *http.Response, error) {
	return r.ApiService.GetServerCredentialsExecute(r)
}

/*
GetServerCredentials Get Server credentials

Returns Server credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIGetServerCredentialsRequest
*/
func (a *ServerAPIService) GetServerCredentials(ctx context.Context, serverId float32) ServerAPIGetServerCredentialsRequest {
	return ServerAPIGetServerCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return ServerCredentials
func (a *ServerAPIService) GetServerCredentialsExecute(r ServerAPIGetServerCredentialsRequest) (*ServerCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServerCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServerInfoRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIGetServerInfoRequest) Execute() (*Server, *http.Response, error) {
	return r.ApiService.GetServerInfoExecute(r)
}

/*
GetServerInfo Get Server information

Returns Server information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIGetServerInfoRequest
*/
func (a *ServerAPIService) GetServerInfo(ctx context.Context, serverId float32) ServerAPIGetServerInfoRequest {
	return ServerAPIGetServerInfoRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return Server
func (a *ServerAPIService) GetServerInfoExecute(r ServerAPIGetServerInfoRequest) (*Server, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Server
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServerInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServerPowerStatusRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIGetServerPowerStatusRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetServerPowerStatusExecute(r)
}

/*
GetServerPowerStatus Gets the power state of a server

Gets the power state of a server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIGetServerPowerStatusRequest
*/
func (a *ServerAPIService) GetServerPowerStatus(ctx context.Context, serverId float32) ServerAPIGetServerPowerStatusRequest {
	return ServerAPIGetServerPowerStatusRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return string
func (a *ServerAPIService) GetServerPowerStatusExecute(r ServerAPIGetServerPowerStatusRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServerPowerStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/get-power"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServerRemoteConsoleInfoRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIGetServerRemoteConsoleInfoRequest) Execute() (*RemoteConsoleInfo, *http.Response, error) {
	return r.ApiService.GetServerRemoteConsoleInfoExecute(r)
}

/*
GetServerRemoteConsoleInfo Get Remote Console information

Returns Remote Console information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIGetServerRemoteConsoleInfoRequest
*/
func (a *ServerAPIService) GetServerRemoteConsoleInfo(ctx context.Context, serverId float32) ServerAPIGetServerRemoteConsoleInfoRequest {
	return ServerAPIGetServerRemoteConsoleInfoRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return RemoteConsoleInfo
func (a *ServerAPIService) GetServerRemoteConsoleInfoExecute(r ServerAPIGetServerRemoteConsoleInfoRequest) (*RemoteConsoleInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoteConsoleInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServerRemoteConsoleInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/remote-console-info"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServerVNCInfoRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIGetServerVNCInfoRequest) Execute() (*ServerVNCInfo, *http.Response, error) {
	return r.ApiService.GetServerVNCInfoExecute(r)
}

/*
GetServerVNCInfo Get VNC information

Returns VNC information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIGetServerVNCInfoRequest
*/
func (a *ServerAPIService) GetServerVNCInfo(ctx context.Context, serverId float32) ServerAPIGetServerVNCInfoRequest {
	return ServerAPIGetServerVNCInfoRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return ServerVNCInfo
func (a *ServerAPIService) GetServerVNCInfoExecute(r ServerAPIGetServerVNCInfoRequest) (*ServerVNCInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerVNCInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServerVNCInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/vnc-info"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServersRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	page *float32
	limit *float32
	filterServerTypeId *[]string
	filterServerId *[]string
	filterSiteId *[]string
	filterVendor *[]string
	filterSerialNumber *[]string
	filterManagementAddress *[]string
	filterModel *[]string
	filterAdministrationState *[]string
	filterServerDiskWipe *[]string
	filterPowerStatus *[]string
	filterServerDhcpStatus *[]string
	filterServerClass *[]string
	filterServerStatus *[]string
	filterRequiresManualCleaning *[]string
	filterInstanceInfrastructureInfrastructureId *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ServerAPIGetServersRequest) Page(page float32) ServerAPIGetServersRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ServerAPIGetServersRequest) Limit(limit float32) ServerAPIGetServersRequest {
	r.limit = &limit
	return r
}

// Filter by serverTypeId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverTypeId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverTypeId&#x3D;$not:$like:John Doe&amp;filter.serverTypeId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterServerTypeId(filterServerTypeId []string) ServerAPIGetServersRequest {
	r.filterServerTypeId = &filterServerTypeId
	return r
}

// Filter by serverId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverId&#x3D;$not:$like:John Doe&amp;filter.serverId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterServerId(filterServerId []string) ServerAPIGetServersRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by siteId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.siteId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.siteId&#x3D;$not:$like:John Doe&amp;filter.siteId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterSiteId(filterSiteId []string) ServerAPIGetServersRequest {
	r.filterSiteId = &filterSiteId
	return r
}

// Filter by vendor query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.vendor&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.vendor&#x3D;$not:$like:John Doe&amp;filter.vendor&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterVendor(filterVendor []string) ServerAPIGetServersRequest {
	r.filterVendor = &filterVendor
	return r
}

// Filter by serialNumber query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serialNumber&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serialNumber&#x3D;$not:$like:John Doe&amp;filter.serialNumber&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterSerialNumber(filterSerialNumber []string) ServerAPIGetServersRequest {
	r.filterSerialNumber = &filterSerialNumber
	return r
}

// Filter by managementAddress query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.managementAddress&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.managementAddress&#x3D;$not:$like:John Doe&amp;filter.managementAddress&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterManagementAddress(filterManagementAddress []string) ServerAPIGetServersRequest {
	r.filterManagementAddress = &filterManagementAddress
	return r
}

// Filter by model query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.model&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.model&#x3D;$not:$like:John Doe&amp;filter.model&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterModel(filterModel []string) ServerAPIGetServersRequest {
	r.filterModel = &filterModel
	return r
}

// Filter by administrationState query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.administrationState&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.administrationState&#x3D;$not:$like:John Doe&amp;filter.administrationState&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterAdministrationState(filterAdministrationState []string) ServerAPIGetServersRequest {
	r.filterAdministrationState = &filterAdministrationState
	return r
}

// Filter by serverDiskWipe query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverDiskWipe&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverDiskWipe&#x3D;$not:$like:John Doe&amp;filter.serverDiskWipe&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterServerDiskWipe(filterServerDiskWipe []string) ServerAPIGetServersRequest {
	r.filterServerDiskWipe = &filterServerDiskWipe
	return r
}

// Filter by powerStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.powerStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.powerStatus&#x3D;$not:$like:John Doe&amp;filter.powerStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterPowerStatus(filterPowerStatus []string) ServerAPIGetServersRequest {
	r.filterPowerStatus = &filterPowerStatus
	return r
}

// Filter by serverDhcpStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverDhcpStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverDhcpStatus&#x3D;$not:$like:John Doe&amp;filter.serverDhcpStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterServerDhcpStatus(filterServerDhcpStatus []string) ServerAPIGetServersRequest {
	r.filterServerDhcpStatus = &filterServerDhcpStatus
	return r
}

// Filter by serverClass query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverClass&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverClass&#x3D;$not:$like:John Doe&amp;filter.serverClass&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterServerClass(filterServerClass []string) ServerAPIGetServersRequest {
	r.filterServerClass = &filterServerClass
	return r
}

// Filter by serverStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverStatus&#x3D;$not:$like:John Doe&amp;filter.serverStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterServerStatus(filterServerStatus []string) ServerAPIGetServersRequest {
	r.filterServerStatus = &filterServerStatus
	return r
}

// Filter by requiresManualCleaning query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.requiresManualCleaning&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.requiresManualCleaning&#x3D;$not:$like:John Doe&amp;filter.requiresManualCleaning&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterRequiresManualCleaning(filterRequiresManualCleaning []string) ServerAPIGetServersRequest {
	r.filterRequiresManualCleaning = &filterRequiresManualCleaning
	return r
}

// Filter by instance.infrastructure.infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.instance.infrastructure.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.instance.infrastructure.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.instance.infrastructure.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerAPIGetServersRequest) FilterInstanceInfrastructureInfrastructureId(filterInstanceInfrastructureInfrastructureId []string) ServerAPIGetServersRequest {
	r.filterInstanceInfrastructureInfrastructureId = &filterInstanceInfrastructureInfrastructureId
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; serverId:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;serverId&lt;/li&gt; &lt;li&gt;serverTypeId&lt;/li&gt;&lt;/ul&gt;       
func (r ServerAPIGetServersRequest) SortBy(sortBy []string) ServerAPIGetServersRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r ServerAPIGetServersRequest) Search(search string) ServerAPIGetServersRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; vendor,model           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;vendor&lt;/li&gt; &lt;li&gt;model&lt;/li&gt;&lt;/ul&gt;         
func (r ServerAPIGetServersRequest) SearchBy(searchBy []string) ServerAPIGetServersRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerAPIGetServersRequest) Execute() (*ServerPaginatedList, *http.Response, error) {
	return r.ApiService.GetServersExecute(r)
}

/*
GetServers Get a list of Servers

Returns a list of Servers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ServerAPIGetServersRequest
*/
func (a *ServerAPIService) GetServers(ctx context.Context) ServerAPIGetServersRequest {
	return ServerAPIGetServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServerPaginatedList
func (a *ServerAPIService) GetServersExecute(r ServerAPIGetServersRequest) (*ServerPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterServerTypeId != nil {
		t := *r.filterServerTypeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverTypeId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverTypeId", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterSiteId != nil {
		t := *r.filterSiteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.siteId", t, "form", "multi")
		}
	}
	if r.filterVendor != nil {
		t := *r.filterVendor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vendor", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.vendor", t, "form", "multi")
		}
	}
	if r.filterSerialNumber != nil {
		t := *r.filterSerialNumber
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serialNumber", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serialNumber", t, "form", "multi")
		}
	}
	if r.filterManagementAddress != nil {
		t := *r.filterManagementAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.managementAddress", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.managementAddress", t, "form", "multi")
		}
	}
	if r.filterModel != nil {
		t := *r.filterModel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.model", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.model", t, "form", "multi")
		}
	}
	if r.filterAdministrationState != nil {
		t := *r.filterAdministrationState
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.administrationState", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.administrationState", t, "form", "multi")
		}
	}
	if r.filterServerDiskWipe != nil {
		t := *r.filterServerDiskWipe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverDiskWipe", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverDiskWipe", t, "form", "multi")
		}
	}
	if r.filterPowerStatus != nil {
		t := *r.filterPowerStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.powerStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.powerStatus", t, "form", "multi")
		}
	}
	if r.filterServerDhcpStatus != nil {
		t := *r.filterServerDhcpStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverDhcpStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverDhcpStatus", t, "form", "multi")
		}
	}
	if r.filterServerClass != nil {
		t := *r.filterServerClass
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverClass", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverClass", t, "form", "multi")
		}
	}
	if r.filterServerStatus != nil {
		t := *r.filterServerStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverStatus", t, "form", "multi")
		}
	}
	if r.filterRequiresManualCleaning != nil {
		t := *r.filterRequiresManualCleaning
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.requiresManualCleaning", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.requiresManualCleaning", t, "form", "multi")
		}
	}
	if r.filterInstanceInfrastructureInfrastructureId != nil {
		t := *r.filterInstanceInfrastructureInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.instance.infrastructure.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.instance.infrastructure.infrastructureId", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIGetServersStatisticsRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
}

func (r ServerAPIGetServersStatisticsRequest) Execute() (*ServerStatistics, *http.Response, error) {
	return r.ApiService.GetServersStatisticsExecute(r)
}

/*
GetServersStatistics Get Servers statistics

Returns Servers statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ServerAPIGetServersStatisticsRequest
*/
func (a *ServerAPIService) GetServersStatistics(ctx context.Context) ServerAPIGetServersStatisticsRequest {
	return ServerAPIGetServersStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServerStatistics
func (a *ServerAPIService) GetServersStatisticsExecute(r ServerAPIGetServersStatisticsRequest) (*ServerStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.GetServersStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIIdentifyServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
}

func (r ServerAPIIdentifyServerRequest) Execute() (*http.Response, error) {
	return r.ApiService.IdentifyServerExecute(r)
}

/*
IdentifyServer identify the server chassis by blinking the LED

identify the server chassis by blinking the LED

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIIdentifyServerRequest
*/
func (a *ServerAPIService) IdentifyServer(ctx context.Context, serverId float32) ServerAPIIdentifyServerRequest {
	return ServerAPIIdentifyServerRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
func (a *ServerAPIService) IdentifyServerExecute(r ServerAPIIdentifyServerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.IdentifyServer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/identify-server"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerAPIReRegisterServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	ifMatch *string
}

// Entity tag
func (r ServerAPIReRegisterServerRequest) IfMatch(ifMatch string) ServerAPIReRegisterServerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIReRegisterServerRequest) Execute() (*ReRegisterServerResponse, *http.Response, error) {
	return r.ApiService.ReRegisterServerExecute(r)
}

/*
ReRegisterServer Re-register a server

Re-registers a server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIReRegisterServerRequest
*/
func (a *ServerAPIService) ReRegisterServer(ctx context.Context, serverId float32) ServerAPIReRegisterServerRequest {
	return ServerAPIReRegisterServerRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return ReRegisterServerResponse
func (a *ServerAPIService) ReRegisterServerExecute(r ServerAPIReRegisterServerRequest) (*ReRegisterServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReRegisterServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.ReRegisterServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/re-register"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIRegisterProductionServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	registerProductionServer *RegisterProductionServer
}

// The production server registration information
func (r ServerAPIRegisterProductionServerRequest) RegisterProductionServer(registerProductionServer RegisterProductionServer) ServerAPIRegisterProductionServerRequest {
	r.registerProductionServer = &registerProductionServer
	return r
}

func (r ServerAPIRegisterProductionServerRequest) Execute() (*RegisterServerResponse, *http.Response, error) {
	return r.ApiService.RegisterProductionServerExecute(r)
}

/*
RegisterProductionServer Initialize a production (live) server

Collects the production server information and registers it in the system without modifying the server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ServerAPIRegisterProductionServerRequest
*/
func (a *ServerAPIService) RegisterProductionServer(ctx context.Context) ServerAPIRegisterProductionServerRequest {
	return ServerAPIRegisterProductionServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterServerResponse
func (a *ServerAPIService) RegisterProductionServerExecute(r ServerAPIRegisterProductionServerRequest) (*RegisterServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.RegisterProductionServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/actions/register-production"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.registerProductionServer == nil {
		return localVarReturnValue, nil, reportError("registerProductionServer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registerProductionServer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIRegisterServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	registerServer *RegisterServer
}

// The server registration information
func (r ServerAPIRegisterServerRequest) RegisterServer(registerServer RegisterServer) ServerAPIRegisterServerRequest {
	r.registerServer = &registerServer
	return r
}

func (r ServerAPIRegisterServerRequest) Execute() (*RegisterServerResponse, *http.Response, error) {
	return r.ApiService.RegisterServerExecute(r)
}

/*
RegisterServer Initialize server registration

Initializes server registration process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ServerAPIRegisterServerRequest
*/
func (a *ServerAPIService) RegisterServer(ctx context.Context) ServerAPIRegisterServerRequest {
	return ServerAPIRegisterServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterServerResponse
func (a *ServerAPIService) RegisterServerExecute(r ServerAPIRegisterServerRequest) (*RegisterServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.RegisterServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.registerServer == nil {
		return localVarReturnValue, nil, reportError("registerServer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registerServer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIResetServerToFactoryDefaultsRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	ifMatch *string
}

// Entity tag
func (r ServerAPIResetServerToFactoryDefaultsRequest) IfMatch(ifMatch string) ServerAPIResetServerToFactoryDefaultsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIResetServerToFactoryDefaultsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResetServerToFactoryDefaultsExecute(r)
}

/*
ResetServerToFactoryDefaults Resets a server to factory defaults

Resets a server to factory defaults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIResetServerToFactoryDefaultsRequest
*/
func (a *ServerAPIService) ResetServerToFactoryDefaults(ctx context.Context, serverId float32) ServerAPIResetServerToFactoryDefaultsRequest {
	return ServerAPIResetServerToFactoryDefaultsRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
func (a *ServerAPIService) ResetServerToFactoryDefaultsExecute(r ServerAPIResetServerToFactoryDefaultsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.ResetServerToFactoryDefaults")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/factory-reset"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerAPISetServerPowerStateRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	serverPowerSet *ServerPowerSet
	ifMatch *string
}

// The server power options
func (r ServerAPISetServerPowerStateRequest) ServerPowerSet(serverPowerSet ServerPowerSet) ServerAPISetServerPowerStateRequest {
	r.serverPowerSet = &serverPowerSet
	return r
}

// Entity tag
func (r ServerAPISetServerPowerStateRequest) IfMatch(ifMatch string) ServerAPISetServerPowerStateRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPISetServerPowerStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetServerPowerStateExecute(r)
}

/*
SetServerPowerState Sets the power state of a server

Sets the power state of a server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPISetServerPowerStateRequest
*/
func (a *ServerAPIService) SetServerPowerState(ctx context.Context, serverId float32) ServerAPISetServerPowerStateRequest {
	return ServerAPISetServerPowerStateRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
func (a *ServerAPIService) SetServerPowerStateExecute(r ServerAPISetServerPowerStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.SetServerPowerState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/set-power"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverPowerSet == nil {
		return nil, reportError("serverPowerSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.serverPowerSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerAPIUpdateServerRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	updateServer *UpdateServer
	ifMatch *string
}

// The server information update object
func (r ServerAPIUpdateServerRequest) UpdateServer(updateServer UpdateServer) ServerAPIUpdateServerRequest {
	r.updateServer = &updateServer
	return r
}

// Entity tag
func (r ServerAPIUpdateServerRequest) IfMatch(ifMatch string) ServerAPIUpdateServerRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIUpdateServerRequest) Execute() (*Server, *http.Response, error) {
	return r.ApiService.UpdateServerExecute(r)
}

/*
UpdateServer Updates the server information

Updates the server information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIUpdateServerRequest
*/
func (a *ServerAPIService) UpdateServer(ctx context.Context, serverId float32) ServerAPIUpdateServerRequest {
	return ServerAPIUpdateServerRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return Server
func (a *ServerAPIService) UpdateServerExecute(r ServerAPIUpdateServerRequest) (*Server, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Server
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.UpdateServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateServer == nil {
		return localVarReturnValue, nil, reportError("updateServer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateServer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIUpdateServerEnableSnmpRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	ifMatch *string
}

// Entity tag
func (r ServerAPIUpdateServerEnableSnmpRequest) IfMatch(ifMatch string) ServerAPIUpdateServerEnableSnmpRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIUpdateServerEnableSnmpRequest) Execute() (float32, *http.Response, error) {
	return r.ApiService.UpdateServerEnableSnmpExecute(r)
}

/*
UpdateServerEnableSnmp Enables SNMP on a Server

Enables SNMP on a Server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIUpdateServerEnableSnmpRequest
*/
func (a *ServerAPIService) UpdateServerEnableSnmp(ctx context.Context, serverId float32) ServerAPIUpdateServerEnableSnmpRequest {
	return ServerAPIUpdateServerEnableSnmpRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return float32
func (a *ServerAPIService) UpdateServerEnableSnmpExecute(r ServerAPIUpdateServerEnableSnmpRequest) (float32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  float32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.UpdateServerEnableSnmp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/enable-snmp"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerAPIUpdateServerIpmiCredentialsRequest struct {
	ctx context.Context
	ApiService *ServerAPIService
	serverId float32
	updateServerIpmiCredentials *UpdateServerIpmiCredentials
	ifMatch *string
}

// The Server Ipmi credentials object
func (r ServerAPIUpdateServerIpmiCredentialsRequest) UpdateServerIpmiCredentials(updateServerIpmiCredentials UpdateServerIpmiCredentials) ServerAPIUpdateServerIpmiCredentialsRequest {
	r.updateServerIpmiCredentials = &updateServerIpmiCredentials
	return r
}

// Entity tag
func (r ServerAPIUpdateServerIpmiCredentialsRequest) IfMatch(ifMatch string) ServerAPIUpdateServerIpmiCredentialsRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerAPIUpdateServerIpmiCredentialsRequest) Execute() (*ServerCredentials, *http.Response, error) {
	return r.ApiService.UpdateServerIpmiCredentialsExecute(r)
}

/*
UpdateServerIpmiCredentials Update Server ipmi credentials

Updates Server ipmi credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverId
 @return ServerAPIUpdateServerIpmiCredentialsRequest
*/
func (a *ServerAPIService) UpdateServerIpmiCredentials(ctx context.Context, serverId float32) ServerAPIUpdateServerIpmiCredentialsRequest {
	return ServerAPIUpdateServerIpmiCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		serverId: serverId,
	}
}

// Execute executes the request
//  @return ServerCredentials
func (a *ServerAPIService) UpdateServerIpmiCredentialsExecute(r ServerAPIUpdateServerIpmiCredentialsRequest) (*ServerCredentials, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerCredentials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerAPIService.UpdateServerIpmiCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/servers/{serverId}/actions/update-ipmi-credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateServerIpmiCredentials == nil {
		return localVarReturnValue, nil, reportError("updateServerIpmiCredentials is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.updateServerIpmiCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
