/*
MetalSoft REST API

MetalSoft REST API documentation

API version: 2.0
Contact: support@metalsoft.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ServerInstanceGroupAPIService ServerInstanceGroupAPI service
type ServerInstanceGroupAPIService service

type ServerInstanceGroupAPICreateServerInstanceGroupRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	infrastructureId int32
	serverInstanceGroupCreate *ServerInstanceGroupCreate
}

// The Server Instance Group to create
func (r ServerInstanceGroupAPICreateServerInstanceGroupRequest) ServerInstanceGroupCreate(serverInstanceGroupCreate ServerInstanceGroupCreate) ServerInstanceGroupAPICreateServerInstanceGroupRequest {
	r.serverInstanceGroupCreate = &serverInstanceGroupCreate
	return r
}

func (r ServerInstanceGroupAPICreateServerInstanceGroupRequest) Execute() (*ServerInstanceGroup, *http.Response, error) {
	return r.ApiService.CreateServerInstanceGroupExecute(r)
}

/*
CreateServerInstanceGroup Add a Server Instance Group to an infrastructure. By default it will not have any instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return ServerInstanceGroupAPICreateServerInstanceGroupRequest
*/
func (a *ServerInstanceGroupAPIService) CreateServerInstanceGroup(ctx context.Context, infrastructureId int32) ServerInstanceGroupAPICreateServerInstanceGroupRequest {
	return ServerInstanceGroupAPICreateServerInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroup
func (a *ServerInstanceGroupAPIService) CreateServerInstanceGroupExecute(r ServerInstanceGroupAPICreateServerInstanceGroupRequest) (*ServerInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.CreateServerInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/server-instance-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstanceGroupCreate == nil {
		return localVarReturnValue, nil, reportError("serverInstanceGroupCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serverInstanceGroupCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
	createLogicalNetworkACLDto *CreateLogicalNetworkACLDto
}

// The security rule to create
func (r ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest) CreateLogicalNetworkACLDto(createLogicalNetworkACLDto CreateLogicalNetworkACLDto) ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest {
	r.createLogicalNetworkACLDto = &createLogicalNetworkACLDto
	return r
}

func (r ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest) Execute() (*LogicalNetworkACLDto, *http.Response, error) {
	return r.ApiService.CreateServerInstanceGroupLogicalNetworkACLExecute(r)
}

/*
CreateServerInstanceGroupLogicalNetworkACL Create a security rule for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @return ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest
*/
func (a *ServerInstanceGroupAPIService) CreateServerInstanceGroupLogicalNetworkACL(ctx context.Context, serverInstanceGroupId int32, connectionId int32) ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest {
	return ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACLDto
func (a *ServerInstanceGroupAPIService) CreateServerInstanceGroupLogicalNetworkACLExecute(r ServerInstanceGroupAPICreateServerInstanceGroupLogicalNetworkACLRequest) (*LogicalNetworkACLDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACLDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.CreateServerInstanceGroupLogicalNetworkACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}/security/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLogicalNetworkACLDto == nil {
		return localVarReturnValue, nil, reportError("createLogicalNetworkACLDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLogicalNetworkACLDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	createServerInstanceGroupNetworkConnectionDto *CreateServerInstanceGroupNetworkConnectionDto
}

// The network connection object to create
func (r ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest) CreateServerInstanceGroupNetworkConnectionDto(createServerInstanceGroupNetworkConnectionDto CreateServerInstanceGroupNetworkConnectionDto) ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest {
	r.createServerInstanceGroupNetworkConnectionDto = &createServerInstanceGroupNetworkConnectionDto
	return r
}

func (r ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest) Execute() (*ServerInstanceGroupNetworkConnectionDto, *http.Response, error) {
	return r.ApiService.CreateServerInstanceGroupNetworkConfigurationConnectionExecute(r)
}

/*
CreateServerInstanceGroupNetworkConfigurationConnection Create a network connection for a server instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest
*/
func (a *ServerInstanceGroupAPIService) CreateServerInstanceGroupNetworkConfigurationConnection(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest {
	return ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupNetworkConnectionDto
func (a *ServerInstanceGroupAPIService) CreateServerInstanceGroupNetworkConfigurationConnectionExecute(r ServerInstanceGroupAPICreateServerInstanceGroupNetworkConfigurationConnectionRequest) (*ServerInstanceGroupNetworkConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupNetworkConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.CreateServerInstanceGroupNetworkConfigurationConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createServerInstanceGroupNetworkConnectionDto == nil {
		return localVarReturnValue, nil, reportError("createServerInstanceGroupNetworkConnectionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createServerInstanceGroupNetworkConnectionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIDeleteServerInstanceGroupRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	ifMatch *string
}

// Entity tag
func (r ServerInstanceGroupAPIDeleteServerInstanceGroupRequest) IfMatch(ifMatch string) ServerInstanceGroupAPIDeleteServerInstanceGroupRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceGroupAPIDeleteServerInstanceGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServerInstanceGroupExecute(r)
}

/*
DeleteServerInstanceGroup Delete Server Instance Group. Will not take effect if there are instances in this group.

Delete Server Instance Group. Will not take effect if there are instances in this group. To delete the instances in a group mark them for delete individually.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIDeleteServerInstanceGroupRequest
*/
func (a *ServerInstanceGroupAPIService) DeleteServerInstanceGroup(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIDeleteServerInstanceGroupRequest {
	return ServerInstanceGroupAPIDeleteServerInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
func (a *ServerInstanceGroupAPIService) DeleteServerInstanceGroupExecute(r ServerInstanceGroupAPIDeleteServerInstanceGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.DeleteServerInstanceGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIDeleteServerInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
	ruleId int32
}

func (r ServerInstanceGroupAPIDeleteServerInstanceGroupLogicalNetworkACLRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServerInstanceGroupLogicalNetworkACLExecute(r)
}

/*
DeleteServerInstanceGroupLogicalNetworkACL Delete a security rule for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @param ruleId
 @return ServerInstanceGroupAPIDeleteServerInstanceGroupLogicalNetworkACLRequest
*/
func (a *ServerInstanceGroupAPIService) DeleteServerInstanceGroupLogicalNetworkACL(ctx context.Context, serverInstanceGroupId int32, connectionId int32, ruleId int32) ServerInstanceGroupAPIDeleteServerInstanceGroupLogicalNetworkACLRequest {
	return ServerInstanceGroupAPIDeleteServerInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
		ruleId: ruleId,
	}
}

// Execute executes the request
func (a *ServerInstanceGroupAPIService) DeleteServerInstanceGroupLogicalNetworkACLExecute(r ServerInstanceGroupAPIDeleteServerInstanceGroupLogicalNetworkACLRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.DeleteServerInstanceGroupLogicalNetworkACL")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}/security/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIDeleteServerInstanceGroupNetworkConfigurationConnectionRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
}

func (r ServerInstanceGroupAPIDeleteServerInstanceGroupNetworkConfigurationConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServerInstanceGroupNetworkConfigurationConnectionExecute(r)
}

/*
DeleteServerInstanceGroupNetworkConfigurationConnection Delete a network connection for a server instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @return ServerInstanceGroupAPIDeleteServerInstanceGroupNetworkConfigurationConnectionRequest
*/
func (a *ServerInstanceGroupAPIService) DeleteServerInstanceGroupNetworkConfigurationConnection(ctx context.Context, serverInstanceGroupId int32, connectionId int32) ServerInstanceGroupAPIDeleteServerInstanceGroupNetworkConfigurationConnectionRequest {
	return ServerInstanceGroupAPIDeleteServerInstanceGroupNetworkConfigurationConnectionRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
func (a *ServerInstanceGroupAPIService) DeleteServerInstanceGroupNetworkConfigurationConnectionExecute(r ServerInstanceGroupAPIDeleteServerInstanceGroupNetworkConfigurationConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.DeleteServerInstanceGroupNetworkConfigurationConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	infrastructureId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterExtensionInstanceId *[]string
	filterServiceStatus *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) Page(page float32) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) Limit(limit float32) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) FilterInfrastructureId(filterInfrastructureId []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by extensionInstanceId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.extensionInstanceId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.extensionInstanceId&#x3D;$not:$like:John Doe&amp;filter.extensionInstanceId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) FilterExtensionInstanceId(filterExtensionInstanceId []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.filterExtensionInstanceId = &filterExtensionInstanceId
	return r
}

// Filter by serviceStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serviceStatus&#x3D;$not:$like:John Doe&amp;filter.serviceStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) FilterServiceStatus(filterServiceStatus []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.deployStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployStatus&#x3D;$not:$like:John Doe&amp;filter.config.deployStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployType&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployType&#x3D;$not:$like:John Doe&amp;filter.config.deployType&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) FilterConfigDeployType(filterConfigDeployType []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;       
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) SortBy(sortBy []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) Search(search string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; label           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;         
func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) SearchBy(searchBy []string) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) Execute() (*ServerInstanceGroupPaginatedList, *http.Response, error) {
	return r.ApiService.GetInfrastructureServerInstanceGroupsExecute(r)
}

/*
GetInfrastructureServerInstanceGroups List Server Instance Groups for an infrastructure

Returns list of Server Instance Groups in the specified infrastructure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param infrastructureId
 @return ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest
*/
func (a *ServerInstanceGroupAPIService) GetInfrastructureServerInstanceGroups(ctx context.Context, infrastructureId int32) ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest {
	return ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest{
		ApiService: a,
		ctx: ctx,
		infrastructureId: infrastructureId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupPaginatedList
func (a *ServerInstanceGroupAPIService) GetInfrastructureServerInstanceGroupsExecute(r ServerInstanceGroupAPIGetInfrastructureServerInstanceGroupsRequest) (*ServerInstanceGroupPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetInfrastructureServerInstanceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/infrastructures/{infrastructureId}/server-instance-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"infrastructureId"+"}", url.PathEscape(parameterValueToString(r.infrastructureId, "infrastructureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterExtensionInstanceId != nil {
		t := *r.filterExtensionInstanceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.extensionInstanceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.extensionInstanceId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupRequest) Execute() (*ServerInstanceGroup, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupExecute(r)
}

/*
GetServerInstanceGroup Get Server Instance Groups details

Returns the details of the specified Server Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroup(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroup
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupExecute(r ServerInstanceGroupAPIGetServerInstanceGroupRequest) (*ServerInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupConfigRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupConfigRequest) Execute() (*ServerInstanceGroupConfiguration, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupConfigExecute(r)
}

/*
GetServerInstanceGroupConfig Get Server Instance Group config details

Returns the config details of the specified Server Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupConfigRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupConfig(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupConfigRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupConfigRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupConfiguration
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupConfigExecute(r ServerInstanceGroupAPIGetServerInstanceGroupConfigRequest) (*ServerInstanceGroupConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupDriveGroupsRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupDriveGroupsRequest) Execute() (*DriveGroupList, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupDriveGroupsExecute(r)
}

/*
GetServerInstanceGroupDriveGroups Get Server Instance Group Drive Groups

Returns the drive groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupDriveGroupsRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupDriveGroups(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupDriveGroupsRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupDriveGroupsRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return DriveGroupList
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupDriveGroupsExecute(r ServerInstanceGroupAPIGetServerInstanceGroupDriveGroupsRequest) (*DriveGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DriveGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupDriveGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/drive-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupInterfaceRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	interfaceId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfaceRequest) Execute() (*ServerInstanceGroupInterface, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupInterfaceExecute(r)
}

/*
GetServerInstanceGroupInterface Get Server Instance Group Interface details

Returns the details of the specified Server Instance Group Interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param interfaceId
 @return ServerInstanceGroupAPIGetServerInstanceGroupInterfaceRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupInterface(ctx context.Context, serverInstanceGroupId int32, interfaceId int32) ServerInstanceGroupAPIGetServerInstanceGroupInterfaceRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupInterface
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupInterfaceExecute(r ServerInstanceGroupAPIGetServerInstanceGroupInterfaceRequest) (*ServerInstanceGroupInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/interfaces/{interfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterServiceStatus *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) Page(page float32) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) Limit(limit float32) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) FilterInfrastructureId(filterInfrastructureId []string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by serviceStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serviceStatus&#x3D;$not:$like:John Doe&amp;filter.serviceStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) FilterServiceStatus(filterServiceStatus []string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.deployStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployStatus&#x3D;$not:$like:John Doe&amp;filter.config.deployStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployType&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployType&#x3D;$not:$like:John Doe&amp;filter.config.deployType&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) FilterConfigDeployType(filterConfigDeployType []string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;infrastructureId&lt;/li&gt; &lt;li&gt;serviceStatus&lt;/li&gt; &lt;li&gt;config.deployStatus&lt;/li&gt; &lt;li&gt;config.deployType&lt;/li&gt;&lt;/ul&gt;       
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) SortBy(sortBy []string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) Search(search string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,label,subdomain,subdomainPermanent,infrastructureId           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt; &lt;li&gt;subdomain&lt;/li&gt; &lt;li&gt;subdomainPermanent&lt;/li&gt; &lt;li&gt;infrastructureId&lt;/li&gt; &lt;li&gt;serviceStatus&lt;/li&gt; &lt;li&gt;config.deployStatus&lt;/li&gt; &lt;li&gt;config.deployType&lt;/li&gt;&lt;/ul&gt;         
func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) SearchBy(searchBy []string) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) Execute() (*ServerInstanceGroupInterfacePaginatedList, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupInterfacesExecute(r)
}

/*
GetServerInstanceGroupInterfaces Get Server Instance Group Interfaces

Returns the interfaces for the specified Server Instance Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupInterfaces(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupInterfacePaginatedList
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupInterfacesExecute(r ServerInstanceGroupAPIGetServerInstanceGroupInterfacesRequest) (*ServerInstanceGroupInterfacePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupInterfacePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLRequest) Execute() (*LogicalNetworkACLDto, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupLogicalNetworkACLExecute(r)
}

/*
GetServerInstanceGroupLogicalNetworkACL Get the security rules for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @return ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupLogicalNetworkACL(ctx context.Context, serverInstanceGroupId int32, connectionId int32) ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACLDto
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupLogicalNetworkACLExecute(r ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLRequest) (*LogicalNetworkACLDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACLDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupLogicalNetworkACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}/security/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLByIdRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
	ruleId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLByIdRequest) Execute() (*LogicalNetworkACLDto, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupLogicalNetworkACLByIdExecute(r)
}

/*
GetServerInstanceGroupLogicalNetworkACLById Get a security rule for a logical network by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @param ruleId
 @return ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLByIdRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupLogicalNetworkACLById(ctx context.Context, serverInstanceGroupId int32, connectionId int32, ruleId int32) ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLByIdRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLByIdRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACLDto
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupLogicalNetworkACLByIdExecute(r ServerInstanceGroupAPIGetServerInstanceGroupLogicalNetworkACLByIdRequest) (*LogicalNetworkACLDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACLDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupLogicalNetworkACLById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}/security/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationRequest) Execute() (*NetworkEndpointGroup, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupNetworkConfigurationExecute(r)
}

/*
GetServerInstanceGroupNetworkConfiguration Get server instance group network configuration

Returns the network configuration of the specified server instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupNetworkConfiguration(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return NetworkEndpointGroup
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupNetworkConfigurationExecute(r ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationRequest) (*NetworkEndpointGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkEndpointGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupNetworkConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionByIdRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionByIdRequest) Execute() (*ServerInstanceGroupNetworkConnectionDto, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupNetworkConfigurationConnectionByIdExecute(r)
}

/*
GetServerInstanceGroupNetworkConfigurationConnectionById Get server instance group network configuration connection by id

Returns the connection by id of the specified server instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @return ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionByIdRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupNetworkConfigurationConnectionById(ctx context.Context, serverInstanceGroupId int32, connectionId int32) ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionByIdRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionByIdRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupNetworkConnectionDto
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupNetworkConfigurationConnectionByIdExecute(r ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionByIdRequest) (*ServerInstanceGroupNetworkConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupNetworkConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupNetworkConfigurationConnectionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionsRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionsRequest) Execute() (*ServerInstanceGroupNetworkConnectionsList, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupNetworkConfigurationConnectionsExecute(r)
}

/*
GetServerInstanceGroupNetworkConfigurationConnections Get server instance group's network connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionsRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupNetworkConfigurationConnections(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionsRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionsRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupNetworkConnectionsList
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupNetworkConfigurationConnectionsExecute(r ServerInstanceGroupAPIGetServerInstanceGroupNetworkConfigurationConnectionsRequest) (*ServerInstanceGroupNetworkConnectionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupNetworkConnectionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupNetworkConfigurationConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	page *float32
	limit *float32
	filterInfrastructureId *[]string
	filterGroupId *[]string
	filterServerId *[]string
	filterServiceStatus *[]string
	filterConfigServerId *[]string
	filterConfigDeployStatus *[]string
	filterConfigDeployType *[]string
	sortBy *[]string
	search *string
	searchBy *[]string
}

// Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) Page(page float32) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.page = &page
	return r
}

// Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) Limit(limit float32) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.limit = &limit
	return r
}

// Filter by infrastructureId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.infrastructureId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.infrastructureId&#x3D;$not:$like:John Doe&amp;filter.infrastructureId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterInfrastructureId(filterInfrastructureId []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterInfrastructureId = &filterInfrastructureId
	return r
}

// Filter by groupId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.groupId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.groupId&#x3D;$not:$like:John Doe&amp;filter.groupId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterGroupId(filterGroupId []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterGroupId = &filterGroupId
	return r
}

// Filter by serverId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serverId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serverId&#x3D;$not:$like:John Doe&amp;filter.serverId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterServerId(filterServerId []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterServerId = &filterServerId
	return r
}

// Filter by serviceStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.serviceStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.serviceStatus&#x3D;$not:$like:John Doe&amp;filter.serviceStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterServiceStatus(filterServiceStatus []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterServiceStatus = &filterServiceStatus
	return r
}

// Filter by config.serverId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.serverId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.serverId&#x3D;$not:$like:John Doe&amp;filter.config.serverId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterConfigServerId(filterConfigServerId []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterConfigServerId = &filterConfigServerId
	return r
}

// Filter by config.deployStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployStatus&#x3D;$not:$like:John Doe&amp;filter.config.deployStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterConfigDeployStatus(filterConfigDeployStatus []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterConfigDeployStatus = &filterConfigDeployStatus
	return r
}

// Filter by config.deployType query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.config.deployType&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.config.deployType&#x3D;$not:$like:John Doe&amp;filter.config.deployType&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) FilterConfigDeployType(filterConfigDeployType []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.filterConfigDeployType = &filterConfigDeployType
	return r
}

// Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;       
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) SortBy(sortBy []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.sortBy = &sortBy
	return r
}

// Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) Search(search string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.search = &search
	return r
}

// List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; label           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;label&lt;/li&gt;&lt;/ul&gt;         
func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) SearchBy(searchBy []string) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	r.searchBy = &searchBy
	return r
}

func (r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) Execute() (*ServerInstancePaginatedList, *http.Response, error) {
	return r.ApiService.GetServerInstanceGroupServerInstancesExecute(r)
}

/*
GetServerInstanceGroupServerInstances List Server Instances for a Server Instance Group

Returns list of Server Instances in the specified group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest
*/
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupServerInstances(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest {
	return ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstancePaginatedList
func (a *ServerInstanceGroupAPIService) GetServerInstanceGroupServerInstancesExecute(r ServerInstanceGroupAPIGetServerInstanceGroupServerInstancesRequest) (*ServerInstancePaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstancePaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.GetServerInstanceGroupServerInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/server-instances"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.filterInfrastructureId != nil {
		t := *r.filterInfrastructureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.infrastructureId", t, "form", "multi")
		}
	}
	if r.filterGroupId != nil {
		t := *r.filterGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.groupId", t, "form", "multi")
		}
	}
	if r.filterServerId != nil {
		t := *r.filterServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serverId", t, "form", "multi")
		}
	}
	if r.filterServiceStatus != nil {
		t := *r.filterServiceStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.serviceStatus", t, "form", "multi")
		}
	}
	if r.filterConfigServerId != nil {
		t := *r.filterConfigServerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.serverId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.serverId", t, "form", "multi")
		}
	}
	if r.filterConfigDeployStatus != nil {
		t := *r.filterConfigDeployStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployStatus", t, "form", "multi")
		}
	}
	if r.filterConfigDeployType != nil {
		t := *r.filterConfigDeployType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.config.deployType", t, "form", "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.searchBy != nil {
		t := *r.searchBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchBy", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	serverInstanceGroupUpdate *ServerInstanceGroupUpdate
	ifMatch *string
}

// The Server Instance Group configuration changes
func (r ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest) ServerInstanceGroupUpdate(serverInstanceGroupUpdate ServerInstanceGroupUpdate) ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest {
	r.serverInstanceGroupUpdate = &serverInstanceGroupUpdate
	return r
}

// Entity tag
func (r ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest) IfMatch(ifMatch string) ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest) Execute() (*ServerInstanceGroupConfiguration, *http.Response, error) {
	return r.ApiService.UpdateServerInstanceGroupConfigExecute(r)
}

/*
UpdateServerInstanceGroupConfig Updates Server Instance Group configuration

Updates the specified Server Instance Group configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest
*/
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupConfig(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest {
	return ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupConfiguration
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupConfigExecute(r ServerInstanceGroupAPIUpdateServerInstanceGroupConfigRequest) (*ServerInstanceGroupConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.UpdateServerInstanceGroupConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serverInstanceGroupUpdate == nil {
		return localVarReturnValue, nil, reportError("serverInstanceGroupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.serverInstanceGroupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId int32
	ruleId int32
	updateLogicalNetworkACLDto *UpdateLogicalNetworkACLDto
}

// The security rule to update
func (r ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest) UpdateLogicalNetworkACLDto(updateLogicalNetworkACLDto UpdateLogicalNetworkACLDto) ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest {
	r.updateLogicalNetworkACLDto = &updateLogicalNetworkACLDto
	return r
}

func (r ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest) Execute() (*LogicalNetworkACLDto, *http.Response, error) {
	return r.ApiService.UpdateServerInstanceGroupLogicalNetworkACLExecute(r)
}

/*
UpdateServerInstanceGroupLogicalNetworkACL Update a security rule for a logical network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @param ruleId
 @return ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest
*/
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupLogicalNetworkACL(ctx context.Context, serverInstanceGroupId int32, connectionId int32, ruleId int32) ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest {
	return ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return LogicalNetworkACLDto
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupLogicalNetworkACLExecute(r ServerInstanceGroupAPIUpdateServerInstanceGroupLogicalNetworkACLRequest) (*LogicalNetworkACLDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogicalNetworkACLDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.UpdateServerInstanceGroupLogicalNetworkACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}/security/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLogicalNetworkACLDto == nil {
		return localVarReturnValue, nil, reportError("updateLogicalNetworkACLDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLogicalNetworkACLDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	genericMeta *GenericMeta
}

// The Server Instance Group meta information
func (r ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest) GenericMeta(genericMeta GenericMeta) ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest {
	r.genericMeta = &genericMeta
	return r
}

func (r ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateServerInstanceGroupMetaExecute(r)
}

/*
UpdateServerInstanceGroupMeta Update an Server Instance Group meta information

Updates the specified Server Instance Group meta information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @return ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest
*/
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupMeta(ctx context.Context, serverInstanceGroupId int32) ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest {
	return ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
	}
}

// Execute executes the request
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupMetaExecute(r ServerInstanceGroupAPIUpdateServerInstanceGroupMetaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.UpdateServerInstanceGroupMeta")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.genericMeta == nil {
		return nil, reportError("genericMeta is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.genericMeta
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest struct {
	ctx context.Context
	ApiService *ServerInstanceGroupAPIService
	serverInstanceGroupId int32
	connectionId float32
	updateNetworkEndpointGroupLogicalNetworkDto *UpdateNetworkEndpointGroupLogicalNetworkDto
}

// The network connection object to update
func (r ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest) UpdateNetworkEndpointGroupLogicalNetworkDto(updateNetworkEndpointGroupLogicalNetworkDto UpdateNetworkEndpointGroupLogicalNetworkDto) ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest {
	r.updateNetworkEndpointGroupLogicalNetworkDto = &updateNetworkEndpointGroupLogicalNetworkDto
	return r
}

func (r ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest) Execute() (*ServerInstanceGroupNetworkConnectionDto, *http.Response, error) {
	return r.ApiService.UpdateServerInstanceGroupNetworkConfigurationConnectionExecute(r)
}

/*
UpdateServerInstanceGroupNetworkConfigurationConnection Update a network connection for a server instance group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serverInstanceGroupId
 @param connectionId
 @return ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest
*/
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupNetworkConfigurationConnection(ctx context.Context, serverInstanceGroupId int32, connectionId float32) ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest {
	return ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest{
		ApiService: a,
		ctx: ctx,
		serverInstanceGroupId: serverInstanceGroupId,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return ServerInstanceGroupNetworkConnectionDto
func (a *ServerInstanceGroupAPIService) UpdateServerInstanceGroupNetworkConfigurationConnectionExecute(r ServerInstanceGroupAPIUpdateServerInstanceGroupNetworkConfigurationConnectionRequest) (*ServerInstanceGroupNetworkConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerInstanceGroupNetworkConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerInstanceGroupAPIService.UpdateServerInstanceGroupNetworkConfigurationConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/server-instance-groups/{serverInstanceGroupId}/config/networking/connections/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverInstanceGroupId"+"}", url.PathEscape(parameterValueToString(r.serverInstanceGroupId, "serverInstanceGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateNetworkEndpointGroupLogicalNetworkDto == nil {
		return localVarReturnValue, nil, reportError("updateNetworkEndpointGroupLogicalNetworkDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkEndpointGroupLogicalNetworkDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
